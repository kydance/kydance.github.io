[{"categories":["Go语言","并发编程","性能优化","编程原理","最佳实践"],"content":"深入探讨 Go 并发编程的核心概念和实战技巧，从互斥锁、读写锁的原理到超时控制的优雅实现。通过实例讲解并发安全、性能优化和常见陷阱的解决方案，帮助你构建高性能的并发应用。","date":"2024-12-20","objectID":"/posts/golang-concurrecy-programming/","tags":["Go","Golang","并发编程","goroutine","channel","并发控制","并发模式","性能优化","最佳实践","高并发"],"title":"Go 并发编程实战指南：从理论到性能优化","uri":"/posts/golang-concurrecy-programming/"},{"categories":["Go语言","并发编程","性能优化","编程原理","最佳实践"],"content":" 导语 并发编程是 Go 语言最引以为豪的特性之一，但如何正确、高效地使用并发特性却是每个 Go 开发者必须面对的挑战。本文将带你深入探索 Go 并发编程的核心机制，从锁的选择到协程的生命周期管理，通过实战案例和性能数据，帮你掌握并发编程的精髓。无论是构建高并发服务还是优化性能瓶颈，这篇文章都能给你带来实用的指导。 ","date":"2024-12-20","objectID":"/posts/golang-concurrecy-programming/:0:0","tags":["Go","Golang","并发编程","goroutine","channel","并发控制","并发模式","性能优化","最佳实践","高并发"],"title":"Go 并发编程实战指南：从理论到性能优化","uri":"/posts/golang-concurrecy-programming/"},{"categories":["Go语言","并发编程","性能优化","编程原理","最佳实践"],"content":"读写锁与互斥锁 Go 语言标准库 sync 提供了 2 种锁，互斥锁(sync.Mutex)和读写锁(sync.RWMutex)。 ","date":"2024-12-20","objectID":"/posts/golang-concurrecy-programming/:1:0","tags":["Go","Golang","并发编程","goroutine","channel","并发控制","并发模式","性能优化","最佳实践","高并发"],"title":"Go 并发编程实战指南：从理论到性能优化","uri":"/posts/golang-concurrecy-programming/"},{"categories":["Go语言","并发编程","性能优化","编程原理","最佳实践"],"content":"互斥锁(sync.Mutex) 互斥锁(sync.Mutex)，不可同时被多个协程持有，当一个协程获取到互斥锁后，其他协程只能等待该协程释放锁后才能获取锁。 Go 语言标准库 sync 提供了 sync.Mutex 类型，它有两个方法：Lock() 和 Unlock()，分别用于获取和释放锁。 可以在代码前调用 Lock() 方法获取锁，在代码后调用 Unlock() 方法释放锁，也可以使用 defer 语句在函数退出时自动释放锁(可以保证互斥锁一定会被释放)。 互斥锁如何实现公平？ 互斥锁有两种状态：正常状态和饥饿状态。 在正常状态下，所有等待锁的 goroutine 按照FIFO顺序等待。 唤醒的 goroutine 不会直接拥有锁，而是会和新请求锁的 goroutine 竞争锁的拥有。 新请求锁的 goroutine 具有优势：它正在 CPU 上执行，而且可能有好几个，所以刚刚唤醒的 goroutine 有很大可能在锁竞争中失败。在这种情况下，这个被唤醒的 goroutine 会加入到等待队列的前面。 如果一个等待的 goroutine 超过 1ms 没有获取锁，那么它将会把锁转变为饥饿模式。 在饥饿模式下，锁的所有权将从 unlock 的 goroutine 直接交给交给等待队列中的第一个。新来的 goroutine 将不会尝试去获得锁，即使锁看起来是 unlock 状态, 也不会去尝试自旋操作，而是放在等待队列的尾部。 如果一个等待的 goroutine 获取了锁，并且满足一以下其中的任何一个条件：(1)它是队列中的最后一个；(2)它等待的时候小于1ms。它会将锁的状态转换为正常状态。 正常状态有很好的性能表现，饥饿模式也是非常重要的，因为它能阻止尾部延迟的现象。 ","date":"2024-12-20","objectID":"/posts/golang-concurrecy-programming/:1:1","tags":["Go","Golang","并发编程","goroutine","channel","并发控制","并发模式","性能优化","最佳实践","高并发"],"title":"Go 并发编程实战指南：从理论到性能优化","uri":"/posts/golang-concurrecy-programming/"},{"categories":["Go语言","并发编程","性能优化","编程原理","最佳实践"],"content":"读写锁(sync.RWMutex) 为保证读操作的安全，只要保证并发读时没有写操作即可。 在这种场景下，允许同时有多个协程获取读锁，但是只能有一个协程获取写锁，写锁会阻塞其他读锁和写锁，因此也被称为 多读单写锁(multiple readers, single writer lock)，简称读写锁(sync.RWMutex)。 Go 语言标准库 sync 提供了 sync.RWMutex 类型及其四种方法：RLock()、RUnlock()、Lock()、Unlock()，分别用于获取和释放读锁和写锁。 读写锁的存在是为了解决读多写少的性能问题：读场景较多时，读写锁可有效减少锁阻塞的时间。 sync.Mutex 与 sync.RWMutex 性能对比 读写操作耗时 1 微秒： 读写比为 9:1 时，sync.RWMutex 性能约为 sync.Mutex 的 8 倍 读写比为 1:9 时，sync.RWMutex 与 sync.Mutex 性能相当 读写比为 1:1 时，sync.RWMutex 性能约为 sync.Mutex 的 2 倍 读写操作耗时 0.1 微秒：sync.RWMutex 性能优势下降到 3 倍 读写操作耗时 10 微秒：sync.RWMutex 的性能与 1 微秒时基本一致 ","date":"2024-12-20","objectID":"/posts/golang-concurrecy-programming/:1:2","tags":["Go","Golang","并发编程","goroutine","channel","并发控制","并发模式","性能优化","最佳实践","高并发"],"title":"Go 并发编程实战指南：从理论到性能优化","uri":"/posts/golang-concurrecy-programming/"},{"categories":["Go语言","并发编程","性能优化","编程原理","最佳实践"],"content":"协程超时返回 超时控制在网络编程中时非常常见的，利用 context.WithTimeout 和 time.After 可以轻松实现超时返回。 ","date":"2024-12-20","objectID":"/posts/golang-concurrecy-programming/:2:0","tags":["Go","Golang","并发编程","goroutine","channel","并发控制","并发模式","性能优化","最佳实践","高并发"],"title":"Go 并发编程实战指南：从理论到性能优化","uri":"/posts/golang-concurrecy-programming/"},{"categories":["Go语言","并发编程","性能优化","编程原理","最佳实践"],"content":"time.After 实现超时控制 // ziwi.go func doBadThing(done chan struct{}) { time.Sleep(time.Second) done \u003c- struct{}{} } func timeout(f func(chan struct{})) error { done := make(chan struct{}) go f(done) select { case \u003c-done: log.Println(\"done\") return nil case \u003c-time.After(time.Millisecond): return fmt.Errorf(\"timeout\") } } // ziwi_test.go func test(t *testing.T, f func(chan struct{})) { t.Helper() for range 1000 { _ = timeout(f) } time.Sleep(2 * time.Second) t.Log(runtime.NumGoroutine()) } func TestBadTimeout(t *testing.T) { test(t, doBadThing) } 在这个典型的 time.After 实现超时返回的例子中： 利用 time.After 启动一个异步的定时器，返回一个 channel：当超过指定时间后，该 channel 将会收到信号 启动子协程函数 f，函数执行结束后，将向 channel done 发送结束信号 使用 select 阻塞等待 done 或 time.After 的信息：若超时，则返回错误；若没超时，则返回 nil 如果 f 调用能在超时前正常退出，那么启动的子协程（goroutine）将能够正常退出。 然而在发生超时的场景下，测试程序输出如下： $ go test -run ^TestBadTimeout$ . -v === RUN TestBadTimeout ziwi_test.go:20: 1002 --- PASS: TestBadTimeout (3.26s) PASS ok ziwi 3.950s 不难发现，最终程序存在 1002 个协程，说明在主协程退出前，即使 1000 个子协程都执行完成，但子协程并没有正常退出，原因如下： 当超时发生时，select 接收到 time.After 的超时信号，done 则没有了接收方（receiver）， 由于没有接受者且无缓冲区，发送者（sender）done 会一直阻塞，导致协程不能退出，随着时间的积累，造成内存耗尽，程序崩溃 解决方案: 创建有缓冲区的 channel 将创建 channel done 时，缓冲区设置为 1 =\u003e 即使没有接收方，发送方也不会发生阻塞。 func timeoutWithBuffer(f func(chan struct{})) error { done := make(chan struct{}, 1) go f(done) select { case \u003c-done: log.Println(\"done\") return nil case \u003c-time.After(time.Millisecond): return fmt.Errorf(\"timeout\") } } $ go test -run ^TestTimeout . -v === RUN TestTimeoutWithBuffer ziwi_test.go:28: 2 --- PASS: TestTimeoutWithBuffer (3.29s) PASS ok ziwi 3.966s 解决方案: 使用 select 尝试发送 使用 select 尝试向 channel done 发送信号，如果失败，则说明缺少接收者，即超时了，那么直接退出即可。 func doGoodThing(done chan struct{}) { time.Sleep(time.Second) select { case done \u003c- struct{}{}: default: return } } $ go test -run ^TestGood . -v === RUN TestGoodTimeout ziwi_test.go:21: 2 --- PASS: TestGoodTimeout (3.25s) PASS ok ziwi 3.924s ➜ ","date":"2024-12-20","objectID":"/posts/golang-concurrecy-programming/:2:1","tags":["Go","Golang","并发编程","goroutine","channel","并发控制","并发模式","性能优化","最佳实践","高并发"],"title":"Go 并发编程实战指南：从理论到性能优化","uri":"/posts/golang-concurrecy-programming/"},{"categories":["Go语言","并发编程","性能优化","编程原理","最佳实践"],"content":"Channel 关闭原则 一个常用的使用 Go channel 的原则是：不要在数据接收方或在有多个发送者的情况下关闭通道，也就是只应该让一个通道唯一的发送者关闭通道 ","date":"2024-12-20","objectID":"/posts/golang-concurrecy-programming/:3:0","tags":["Go","Golang","并发编程","goroutine","channel","并发控制","并发模式","性能优化","最佳实践","高并发"],"title":"Go 并发编程实战指南：从理论到性能优化","uri":"/posts/golang-concurrecy-programming/"},{"categories":["Go语言","并发编程","性能优化","编程原理","最佳实践"],"content":"粗鲁关闭（非常不推荐） 如果 channel 已经关闭，再次关闭会产生 Panic，这时通过 recover 使程序恢复正常 func SafeClose[T any](ch chan T)(justClosed bool) { defer func () { if recover() != nil { justClosed = false // 一个函数的返回结果可以在 defer 调用中修改 } }() close(ch) // 如果 ch 已关闭，则将 Panic return true } ","date":"2024-12-20","objectID":"/posts/golang-concurrecy-programming/:3:1","tags":["Go","Golang","并发编程","goroutine","channel","并发控制","并发模式","性能优化","最佳实践","高并发"],"title":"Go 并发编程实战指南：从理论到性能优化","uri":"/posts/golang-concurrecy-programming/"},{"categories":["Go语言","并发编程","性能优化","编程原理","最佳实践"],"content":"channel 忘记关闭 // ziwi.go func do(taskCh chan int) { for { select { case t := \u003c-taskCh: time.Sleep(time.Millisecond) fmt.Printf(\"%d \", t) } } } func sendTasks() { tashCh := make(chan int) go do(taskCh) for i := 0; i \u003c 1000; i++ { tashCh \u003c- i } } // ziwi_test.go func TestDo(t *testing.T) { t.Log(runtime.NumGoroutine()) sendTasks() time.Sleep(time.Second) t.Log(runtime.NumGoroutine()) } $ go test -run ^TestDo$ . -v === RUN TestDo ziwi_test.go:33: 2 ziwi_test.go:36: 3 --- PASS: TestDo (2.14s) PASS ok ziwi 3.231s 根据测试结果，不难发现，子协程多了一个，即有一个协程没有得到释放。 显然，这个子协程是 sendTasks 中的 go do(taskCh)，它一直处于阻塞状态，等待接收任务，直到程序结束也没有释放。 ","date":"2024-12-20","objectID":"/posts/golang-concurrecy-programming/:4:0","tags":["Go","Golang","并发编程","goroutine","channel","并发控制","并发模式","性能优化","最佳实践","高并发"],"title":"Go 并发编程实战指南：从理论到性能优化","uri":"/posts/golang-concurrecy-programming/"},{"categories":["Go语言","并发编程","性能优化","编程原理","最佳实践"],"content":"解决方案 func doCheckClose(taskCh chan int) { for { select { case t, beforeClosed := \u003c-taskCh: if !beforeClosed { fmt.Println(\"closed\") return } time.Sleep(time.Millisecond) fmt.Printf(\"%d \", t) } } } func sendTasksCheckClose() { taskCh := make(chan int) go doCheckClose(taskCh) for i := 0; i \u003c 1000; i++ { taskCh \u003c- i } close(taskCh) } t, beforeClosed := \u003c-taskCh：判断 channel 是否已经关闭，beforeClosed 为 false 表示 channel 已被关闭 =\u003e 不再阻塞等待，直接返回，协程退出 sendTasks 函数中，任务发送结束之后，使用 close(taskCh) 将 channel taskCh 关闭 关于 channel 与 Goroutine 的垃圾回收 一个通道被其发送数据协程队列和接收数据协程队列中的所有协程引用着。 因此，如果一个通道的这两个队列只要有一个不为空，则此通道肯定不会被垃圾回收。 另一方面，如果一个协程处于一个通道的某个协程队列之中，则此协程也肯定不会被垃圾回收，即使此通道仅被此协程所引用。 事实上，一个协程只有在退出后才能被垃圾回收。 ","date":"2024-12-20","objectID":"/posts/golang-concurrecy-programming/:4:1","tags":["Go","Golang","并发编程","goroutine","channel","并发控制","并发模式","性能优化","最佳实践","高并发"],"title":"Go 并发编程实战指南：从理论到性能优化","uri":"/posts/golang-concurrecy-programming/"},{"categories":["Go语言","并发编程","性能优化","编程原理","最佳实践"],"content":"常见问题 ","date":"2024-12-20","objectID":"/posts/golang-concurrecy-programming/:5:0","tags":["Go","Golang","并发编程","goroutine","channel","并发控制","并发模式","性能优化","最佳实践","高并发"],"title":"Go 并发编程实战指南：从理论到性能优化","uri":"/posts/golang-concurrecy-programming/"},{"categories":["Go语言","并发编程","性能优化","编程原理","最佳实践"],"content":"1. Kill goroutine 可能吗？ 答案是：不能。 goroutine 只能自己退出，而不能被其他 goroutine 强制关闭或杀死。 goroutine 被设计为不可以从外部无条件地结束掉，只能通过 channel 来与它通信。 也就是说，每一个 goroutine 都需要承担自己退出的责任。 (A goroutine cannot be programmatically killed. It can only commit a cooperative suicide.) Github 讨论：question: is it possible to a goroutine immediately stop another goroutine? 由于 Goroutine 不能被强制关闭或杀死，在超时或其他类似场景下，为了 Goroutine 尽可能正常退出，建议如下： 尽量使用非阻塞 I/O（非阻塞 I/O 常用来实现高性能的网络库），阻塞 I/O 很可能导致 goroutine 在某个调用一直等待，而无法正确结束 业务逻辑总是考虑退出机制，避免死循环 任务分段执行，超时后即时退出，避免 goroutine 无用的执行过多，浪费资源 ","date":"2024-12-20","objectID":"/posts/golang-concurrecy-programming/:5:1","tags":["Go","Golang","并发编程","goroutine","channel","并发控制","并发模式","性能优化","最佳实践","高并发"],"title":"Go 并发编程实战指南：从理论到性能优化","uri":"/posts/golang-concurrecy-programming/"},{"categories":["Golang","Generic","Programe Language","泛型"],"content":" 导语 导语内容 ","date":"2024-11-06","objectID":"/posts/golang-generic/:0:0","tags":["Golang","Generic","Programe Language","泛型"],"title":"Golang Generic","uri":"/posts/golang-generic/"},{"categories":["编程基础","开发工具","编程技巧","文本处理","实用教程"],"content":"全面解析正则表达式的核心概念和实战技巧，从基础语法到高级特性，从简单匹配到复杂模式。通过实例讲解帮助你掌握这门专业的文本处理语言，提升代码开发效率。特别适合需要处理文本数据的开发者。","date":"2024-11-06","objectID":"/posts/regex-in-one/","tags":["正则表达式","Regular Expression","regex","文本处理","字符串匹配","编程工具","开发技巧","代码优化","编程基础","实用技能"],"title":"正则表达式速成宝典：从零基础到实战高手","uri":"/posts/regex-in-one/"},{"categories":["编程基础","开发工具","编程技巧","文本处理","实用教程"],"content":" 导语 正则表达式是程序员必备的技能之一，它不仅是一种强大的文本处理工具，更是提升开发效率的利器。本文将为你揭开正则表达式的神秘面纱，通过系统的讲解和丰富的实例，帮助你掌握从基础到高级的正则表达式技巧。无论是文本搜索、数据验证，还是复杂的模式匹配，正则表达式都能让你事半功倍。 ","date":"2024-11-06","objectID":"/posts/regex-in-one/:0:0","tags":["正则表达式","Regular Expression","regex","文本处理","字符串匹配","编程工具","开发技巧","代码优化","编程基础","实用技能"],"title":"正则表达式速成宝典：从零基础到实战高手","uri":"/posts/regex-in-one/"},{"categories":["编程基础","开发工具","编程技巧","文本处理","实用教程"],"content":"I. 何谓正则表达式 正则表达式(Regular Expression，常简写为 regex、regexp、RE)，又称规律表达式、模式表达式、正则表达式、常规表达式，是计算机科学概念，用简单字符串来描述、匹配文中全部匹配指定格式的字符串，现在很多文本编辑器都支持用正则表达式搜索、取代匹配指定格式的字符串。 总之, Regex 是一种小型的、高度专业化的编程语言, 它被用来检索、替换那些符合某个模式(规则)的文本。 一个正则表达式通常被称为一个模式（pattern），为用来描述或者匹配一系列匹配某个句法规则的字符串. 正则表达式是由普通字符(例如字符 a 到 z)以及特殊字符(称为 “元字符” )组成的文字模式。 模式描述在搜索文本时要匹配的一个或多个字符串。 正则表达式作为一个模板, 将某个字符模式与所搜索的字符串进行匹配。 ","date":"2024-11-06","objectID":"/posts/regex-in-one/:1:0","tags":["正则表达式","Regular Expression","regex","文本处理","字符串匹配","编程工具","开发技巧","代码优化","编程基础","实用技能"],"title":"正则表达式速成宝典：从零基础到实战高手","uri":"/posts/regex-in-one/"},{"categories":["编程基础","开发工具","编程技巧","文本处理","实用教程"],"content":"II. 普通字符 与 元字符 模式 描述 正则表达式 匹配项 普通字符 a ~ z 匹配自身 abc abc . 匹配除换行符 \\n 以外的任意字符 a.c abc / acc / awc \\ 转义字符，使后一个字符改变原来的意思 a\\.c;a\\\\c a.c;a\\c * 匹配前一个字符 0 次或多次 a*c ac / c / aaaaac + 匹配前一个字符 1 次或多次 a+c ac / aac / aaaaac ? 匹配前一个字符 0 次或 1 次 a?c ac / c ^ 匹配字符串开头，在多行模式中匹配每一行的开头 ^ab ab $ 匹配字符串结尾，在多行模式中匹配每一行的结尾 ab$ ab | 或，匹配 | 左右任意一个表达式，从左向右匹配，若没有 | 包括在 () 中，则匹配整个表达式 abc|def abc / def {} {m} 匹配前一个字符 m 次，{m,n} 匹配前一个字符 m 到 n 次 a{2}c aac [] 字符集合，匹配方括号中包含的任意一个字符: 字符可以逐个列出，也可给出范围，所有特殊字符在字符集中都失去其原有的特殊含义（使用 \\ 转义恢复其特殊含义） [abc] a / b / c () 分组，将括号中字符作为一个整体，可以用来匹配括号中的字符 (abc) abc Tip 反斜杠 \\ 后边跟元字符去除特殊含义，即特殊字符普通化 反斜杠 \\ 后边跟普通字符实现特殊功能，即普通字符特殊化，亦称预定义字符 引用序号对应的字组成所匹配的字符串 ","date":"2024-11-06","objectID":"/posts/regex-in-one/:2:0","tags":["正则表达式","Regular Expression","regex","文本处理","字符串匹配","编程工具","开发技巧","代码优化","编程基础","实用技能"],"title":"正则表达式速成宝典：从零基础到实战高手","uri":"/posts/regex-in-one/"},{"categories":["编程基础","开发工具","编程技巧","文本处理","实用教程"],"content":"III. 预定义字符 预定义字符集是指在正则表达式中具有特殊意义的专用字符集，如 \\d、\\w、\\s 等，可以写在方括号 [] 中，也可以单独使用。 模式 描述 正则表达式 匹配项 \\d 匹配一个数字，等价于 [0-9] a\\dc a1c / a2c / a3c \\D 匹配一个非数字，等价于 [^0-9] a\\Dc a-c / a$c \\s 匹配一个空白字符，包括空格、制表符、换页符和换行符，等价于 [ \\f\\n\\r\\t\\v] a\\sc a c / a\\tc / a\\nc \\S 匹配一个非空白字符，等价于 [^ \\f\\n\\r\\t\\v] / [^\\s] a\\Sc a$c / a-c \\w 匹配一个单字字符（字母、数字或者下划线），等价于 [A-Za-z0-9_] a\\wc a1c / abc / a_c \\W 匹配一个非单字字符，即特殊字符，等价于 [^A-Za-z0-9_] a\\Wc a$c / a-c \\A 仅匹配字符串开头，等价于 ^ \\Aabc abc \\Z 仅匹配字符串结尾，等价于 $ abc\\Z abc \\b 匹配一个单词边界，即字与空格间的位置 \\babc\\b \u003cspace\u003e \\B 匹配非单词边界，等价于 [^\\b] a\\Bbc abc ","date":"2024-11-06","objectID":"/posts/regex-in-one/:3:0","tags":["正则表达式","Regular Expression","regex","文本处理","字符串匹配","编程工具","开发技巧","代码优化","编程基础","实用技能"],"title":"正则表达式速成宝典：从零基础到实战高手","uri":"/posts/regex-in-one/"},{"categories":["编程基础","开发工具","编程技巧","文本处理","实用教程"],"content":"IV. 特殊分组 特殊分组是指在正则表达式中具有特殊意义的专用分组，如 (?P\u003cname\u003e...)、(?P=name)、(?#...)、(?=...)、(?!...)、(?\u003c=...)、(?\u003c!...) 等，可以写在方括号 [] 中，也可以单独使用。 模式 描述 正则表达式 匹配项 (?P\u003cname\u003e...) 为分组起一个别名，匹配的字符串可以通过 \\g\u003cname\u003e 或 \\k\u003cname\u003e 引用 (?P\u003cname\u003eabc) abc (?P=name) 引用别名为 name 的分组匹配的字符串 (?P\u003cid\u003e\\d)abc(?P=id) 1abc1 / 2abc2 \\\u003cnumber\u003e 通过 \\g\u003cnumber\u003e 或 \\k\u003cnumber\u003e 引用编号为 number 的分组匹配的字符串 `(\\d)abc\\1 1abc / 2abc ","date":"2024-11-06","objectID":"/posts/regex-in-one/:4:0","tags":["正则表达式","Regular Expression","regex","文本处理","字符串匹配","编程工具","开发技巧","代码优化","编程基础","实用技能"],"title":"正则表达式速成宝典：从零基础到实战高手","uri":"/posts/regex-in-one/"},{"categories":["编程基础","开发工具","编程技巧","文本处理","实用教程"],"content":"V. match、search与findall ","date":"2024-11-06","objectID":"/posts/regex-in-one/:5:0","tags":["正则表达式","Regular Expression","regex","文本处理","字符串匹配","编程工具","开发技巧","代码优化","编程基础","实用技能"],"title":"正则表达式速成宝典：从零基础到实战高手","uri":"/posts/regex-in-one/"},{"categories":["编程基础","开发工具","编程技巧","文本处理","实用教程"],"content":"1. match match 方法用于查找字符串的头部（也可以指定起始位置），它是一次匹配，只要找到了一个匹配的结果就返回，而不是查找所有匹配的结果。 ","date":"2024-11-06","objectID":"/posts/regex-in-one/:5:1","tags":["正则表达式","Regular Expression","regex","文本处理","字符串匹配","编程工具","开发技巧","代码优化","编程基础","实用技能"],"title":"正则表达式速成宝典：从零基础到实战高手","uri":"/posts/regex-in-one/"},{"categories":["编程基础","开发工具","编程技巧","文本处理","实用教程"],"content":"2. search search 方法用于查找字符串的任何位置，它也是一次匹配，只要找到了一个匹配的结果就返回，而不是查找所有匹配的结果。 ","date":"2024-11-06","objectID":"/posts/regex-in-one/:5:2","tags":["正则表达式","Regular Expression","regex","文本处理","字符串匹配","编程工具","开发技巧","代码优化","编程基础","实用技能"],"title":"正则表达式速成宝典：从零基础到实战高手","uri":"/posts/regex-in-one/"},{"categories":["编程基础","开发工具","编程技巧","文本处理","实用教程"],"content":"3. findall findall 方法用于查找字符串所有（非重复）的匹配子串，返回一个列表，如果没有找到匹配的，则返回空列表。 ","date":"2024-11-06","objectID":"/posts/regex-in-one/:5:3","tags":["正则表达式","Regular Expression","regex","文本处理","字符串匹配","编程工具","开发技巧","代码优化","编程基础","实用技能"],"title":"正则表达式速成宝典：从零基础到实战高手","uri":"/posts/regex-in-one/"},{"categories":["编程基础","开发工具","编程技巧","文本处理","实用教程"],"content":"VI. 贪婪匹配与惰性匹配 ","date":"2024-11-06","objectID":"/posts/regex-in-one/:6:0","tags":["正则表达式","Regular Expression","regex","文本处理","字符串匹配","编程工具","开发技巧","代码优化","编程基础","实用技能"],"title":"正则表达式速成宝典：从零基础到实战高手","uri":"/posts/regex-in-one/"},{"categories":["编程基础","开发工具","编程技巧","文本处理","实用教程"],"content":"1. 贪婪匹配 正则表达式一般趋向于最大长度匹配，即匹配直到下一个字符不满足匹配规则为止，这被称为贪婪匹配。 例如，* 通常意味着匹配零个或多个字符（包括零个），+ 通常意味着匹配一个或多个字符（包括一个），? 通常意味着匹配零个或一个字符，{m,n} 通常意味着匹配 m 到 n 个字符。 ","date":"2024-11-06","objectID":"/posts/regex-in-one/:6:1","tags":["正则表达式","Regular Expression","regex","文本处理","字符串匹配","编程工具","开发技巧","代码优化","编程基础","实用技能"],"title":"正则表达式速成宝典：从零基础到实战高手","uri":"/posts/regex-in-one/"},{"categories":["编程基础","开发工具","编程技巧","文本处理","实用教程"],"content":"2. 惰性匹配 惰性匹配，即匹配尽可能少的字符。在贪婪匹配符号后面加上一个问号 ? 就可以实现惰性匹配。 ","date":"2024-11-06","objectID":"/posts/regex-in-one/:6:2","tags":["正则表达式","Regular Expression","regex","文本处理","字符串匹配","编程工具","开发技巧","代码优化","编程基础","实用技能"],"title":"正则表达式速成宝典：从零基础到实战高手","uri":"/posts/regex-in-one/"},{"categories":["编程基础","开发工具","编程技巧","文本处理","实用教程"],"content":"VII. Reference 正则表达式 wiki ","date":"2024-11-06","objectID":"/posts/regex-in-one/:7:0","tags":["正则表达式","Regular Expression","regex","文本处理","字符串匹配","编程工具","开发技巧","代码优化","编程基础","实用技能"],"title":"正则表达式速成宝典：从零基础到实战高手","uri":"/posts/regex-in-one/"},{"categories":["数据库","后端技术","服务器技术","编程教程","技术架构"],"content":"系统讲解 MySQL 数据库的核心操作和最佳实践，从基础的 CRUD 操作到高级的表结构管理，从数据类型选择到性能优化建议。帮助开发者构建可靠、高效的数据库应用，提供全面的 MySQL 开发指南。","date":"2024-10-31","objectID":"/posts/mysql/","tags":["MySQL","数据库","SQL","Database","数据库优化","数据库管理","后端开发","服务器","企业级应用","性能优化"],"title":"MySQL 核心操作精讲：从基础语法到实战应用","uri":"/posts/mysql/"},{"categories":["数据库","后端技术","服务器技术","编程教程","技术架构"],"content":" 导语 数据库是现代应用程序的核心基础设施，而 MySQL 作为最流行的关系型数据库之一，其重要性不言而喻。本文将带你系统掌握 MySQL 的核心操作，从基础的增删改查到表结构管理，从数据类型选择到性能优化，为你提供一份全面且实用的 MySQL 开发指南。无论你是数据库新手，还是想要提升数据库开发技能的开发者，都能从本文中获得实用的知识和技巧。 ","date":"2024-10-31","objectID":"/posts/mysql/:0:0","tags":["MySQL","数据库","SQL","Database","数据库优化","数据库管理","后端开发","服务器","企业级应用","性能优化"],"title":"MySQL 核心操作精讲：从基础语法到实战应用","uri":"/posts/mysql/"},{"categories":["数据库","后端技术","服务器技术","编程教程","技术架构"],"content":"插入数据 INSERT INSERT INTO TableName [columnName_1, columnName_2, ...] VALUES( \u003ccolumnValue_1\u003e, \u003ccolumnValue_2, ...\u003e, ... ); ","date":"2024-10-31","objectID":"/posts/mysql/:1:0","tags":["MySQL","数据库","SQL","Database","数据库优化","数据库管理","后端开发","服务器","企业级应用","性能优化"],"title":"MySQL 核心操作精讲：从基础语法到实战应用","uri":"/posts/mysql/"},{"categories":["数据库","后端技术","服务器技术","编程教程","技术架构"],"content":"删除数据 DELETE DELETE FROM TableName WHERE Condition; 省略 WHERE 子句 当使用 DELETE 且省略 WHERE 子句时，它将删除所有行 ","date":"2024-10-31","objectID":"/posts/mysql/:2:0","tags":["MySQL","数据库","SQL","Database","数据库优化","数据库管理","后端开发","服务器","企业级应用","性能优化"],"title":"MySQL 核心操作精讲：从基础语法到实战应用","uri":"/posts/mysql/"},{"categories":["数据库","后端技术","服务器技术","编程教程","技术架构"],"content":"更新数据 UPDATE UPDATE TableName SET columnName_1 = columnValue_1, columnName_2 = columnValue_2, ... WHERE Condition; UPDATE 更新多个 column 时，只需要使用一个 SET 命令，且每一个columnName = columnValue之间使用 , 分割（最后一列不需要） 可以嵌套子查询 ","date":"2024-10-31","objectID":"/posts/mysql/:3:0","tags":["MySQL","数据库","SQL","Database","数据库优化","数据库管理","后端开发","服务器","企业级应用","性能优化"],"title":"MySQL 核心操作精讲：从基础语法到实战应用","uri":"/posts/mysql/"},{"categories":["数据库","后端技术","服务器技术","编程教程","技术架构"],"content":"检索数据 SELECT SELECT [DISTINCT] \u003ccolumn1, column2, ...\u003e FROM \u003cTable1 [[AS]\u003caliasName\u003e], table2, ...\u003e WHERE \u003cCondition1 [AND / OR / NOT] Condition2 ...\u003e GROUP BY \u003cColumn1, Column2, ...\u003e HAVING \u003cColumn1, Column2, ...\u003e ORDER BY \u003cColumn1 [ASC / DESC], Column2 [ASC / DESC], ...\u003e LIMIT \u003cA\u003e OFFSET \u003cB\u003e; SELECT DISTINCT 指示数据库只返回不同的值，且必须放在所有列名之前，作用于所有的列 LIMIT 指定返回的行数, OFFSET 指定从哪里开始计算，LIMIT 4 OFFSET 3 \u003c=\u003e LIMIT 3, 4 ORDER BY 根据一个或多个列的名字进行排序，默认升序 ASC，降序 DESC WHERE 指定筛选条件： = / \u003c\u003e / != / \u003c / \u003c= / !\u003c / \u003e / \u003e= / !\u003e / BETWEEN ... AND ... / IS NULL AND / OR / IN / NOT LIKE: % 表示匹配任何字符出现任意次数，_ 表示匹配任意单个字符 GROUP BY 吧数据进行逻辑分组，以便能对每一个组进行聚合计算 HAVING 过滤分组，类似于 WHERE，且支持所有 WHERE 操作: WHERE 过滤行，HAVING 过滤分组 WHERE 在分组前过滤，HAVING 在分组后过滤（WHERE排除掉的行不包括在分组内） HAVING 应与 GROUP BY 结合使用 ","date":"2024-10-31","objectID":"/posts/mysql/:4:0","tags":["MySQL","数据库","SQL","Database","数据库优化","数据库管理","后端开发","服务器","企业级应用","性能优化"],"title":"MySQL 核心操作精讲：从基础语法到实战应用","uri":"/posts/mysql/"},{"categories":["数据库","后端技术","服务器技术","编程教程","技术架构"],"content":"表操作 ","date":"2024-10-31","objectID":"/posts/mysql/:5:0","tags":["MySQL","数据库","SQL","Database","数据库优化","数据库管理","后端开发","服务器","企业级应用","性能优化"],"title":"MySQL 核心操作精讲：从基础语法到实战应用","uri":"/posts/mysql/"},{"categories":["数据库","后端技术","服务器技术","编程教程","技术架构"],"content":"查看表结构 DESC \u003ctbName\u003e; SHOW CREATE TABLE \u003ctbName\u003e ","date":"2024-10-31","objectID":"/posts/mysql/:5:1","tags":["MySQL","数据库","SQL","Database","数据库优化","数据库管理","后端开发","服务器","企业级应用","性能优化"],"title":"MySQL 核心操作精讲：从基础语法到实战应用","uri":"/posts/mysql/"},{"categories":["数据库","后端技术","服务器技术","编程教程","技术架构"],"content":"建表 CREATE TABLE \u003ctbName\u003e ( ... [COMMENTS], ... [COMMENTS], ... ) [COMMENTS]; ","date":"2024-10-31","objectID":"/posts/mysql/:5:2","tags":["MySQL","数据库","SQL","Database","数据库优化","数据库管理","后端开发","服务器","企业级应用","性能优化"],"title":"MySQL 核心操作精讲：从基础语法到实战应用","uri":"/posts/mysql/"},{"categories":["数据库","后端技术","服务器技术","编程教程","技术架构"],"content":"表结构更新 -- 添加字段 ALTER TABLE \u003ctbName\u003e ADD \u003ccolumnName\u003e \u003cdataType\u003e(LENGTH) [\u003cCOMMENT\u003e 'comments'] [CONSTRAINT]; -- 修改字段数据类型 ALTER TABLE \u003ctbName\u003e MODIFY \u003ccolumnName\u003e \u003cnewDataType\u003e(LENGTH); -- 修改字段数据类型和字段名 ALTER TABLE \u003ctbName\u003e CHANGE \u003coldName\u003e \u003cnewName\u003e \u003cdataType\u003e(LENGTH) [COMMENT 'comments'][CONSTRAINT]; -- 删除字段 ALTER TABLE \u003ctbName\u003e DROP \u003ccolumnName\u003e; ","date":"2024-10-31","objectID":"/posts/mysql/:5:3","tags":["MySQL","数据库","SQL","Database","数据库优化","数据库管理","后端开发","服务器","企业级应用","性能优化"],"title":"MySQL 核心操作精讲：从基础语法到实战应用","uri":"/posts/mysql/"},{"categories":["数据库","后端技术","服务器技术","编程教程","技术架构"],"content":"表删除 永久删除表结构 DROP TABLE [IF EXISTS] \u003cTableName\u003e; 删除表格内容，保留表结构 TRUNCATE [TABLE] \u003cTableName\u003e; Tips DELETE: 逐行删除表中记录数据 TRUNCATE: 直接删除原来的表，然后重新建立一个一模一样的表，执行速度比 DELETE 快 ","date":"2024-10-31","objectID":"/posts/mysql/:5:4","tags":["MySQL","数据库","SQL","Database","数据库优化","数据库管理","后端开发","服务器","企业级应用","性能优化"],"title":"MySQL 核心操作精讲：从基础语法到实战应用","uri":"/posts/mysql/"},{"categories":["数据库","后端技术","服务器技术","编程教程","技术架构"],"content":"表重命名 ALTER TABLE oldTable RENAME [TO | AS] newTable; ","date":"2024-10-31","objectID":"/posts/mysql/:5:5","tags":["MySQL","数据库","SQL","Database","数据库优化","数据库管理","后端开发","服务器","企业级应用","性能优化"],"title":"MySQL 核心操作精讲：从基础语法到实战应用","uri":"/posts/mysql/"},{"categories":["数据库","后端技术","服务器技术","编程教程","技术架构"],"content":"MySQL 中的数据类型 Type Size Signed Range TINYINT 1 Byte (-128, 127) SMALLINT 2 Byte (-32768, 32767) MEDIUMINT 3 Byte (-8388608, 8388607) INT / INTEGER 4 Byte $(−232, 232−1)$ BIGINT 8 Byte (−263 , 263−1) FLOAT 4 Byte (-3.402823466E+38, 3.402823466351E+38) DOUBLE 8 Byte (-1.7976931348623157E+308, 1.7976931348623157E+308) DECIMAL Type Size(Byte) DESC CHAR 0 - 255 定长字符串 (需指定长度)，性能较VARCHAR更高些 VARCHAR 0 - 65535 变长字符串 (需指定长度) TINYBLOB 0 - 255 不超过 255 个字符的二进制数据 TINYTEXT 0 - 255 短文本字符串 BLOB 0 - 65535 二进制形式的长文本数据 TEXT 0 - 65535 长文本数据 MEDIUMBLOB 0 - 16777215 二进制形式的中等长度文本数据 MEDIUMTEXT 0 - 16777215 中等长度文本数据 LONGBLOB 0 - 4294967295 二进制形式的极大长度长文本数据 LONGTEXT 0 - 4294967295 极大长度文本数据 Type Size(Byte) Range Format DESC DATE 3 1000-01-01 至 9999-12-31 YYYY-MM-DD 日期值 TIME 3 -838:59:59 至 838:59:59 HH:MM:SS 时间值或持续时间 YEAR 1 1901 至 2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00 至 9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:01 至 2038-01-19 03:14:07 YYYY-MM-DD HH:MM:SS 混合日期和时间值，时间戳 ","date":"2024-10-31","objectID":"/posts/mysql/:6:0","tags":["MySQL","数据库","SQL","Database","数据库优化","数据库管理","后端开发","服务器","企业级应用","性能优化"],"title":"MySQL 核心操作精讲：从基础语法到实战应用","uri":"/posts/mysql/"},{"categories":["数据库","缓存技术","分布式系统","后端技术","性能优化"],"content":"全面解析 Redis 的核心特性和最佳实践，从基础数据类型到高性能设计原理。深入探讨 Redis 单线程架构的优势，帮助开发者构建高性能的缓存系统和实时应用。通过实例讲解 Redis 在现代应用中的实践方案。","date":"2024-10-22","objectID":"/posts/redis/","tags":["Redis","NoSQL","缓存系统","分布式缓存","数据库","高性能","后端开发","分布式系统","性能优化","实时处理"],"title":"Redis 核心精讲：从入门到性能优化","uri":"/posts/redis/"},{"categories":["数据库","缓存技术","分布式系统","后端技术","性能优化"],"content":" 导语 在当今高并发的互联网应用中，Redis 作为内存数据库和缓存系统的标配，以其卓越的性能和灵活的数据结构赢得了开发者的青睐。本文将带你深入了解 Redis 的核心特性，从五大数据类型的实战应用到单线程架构的性能优势，全方位提升你的 Redis 开发技能。无论是构建高性能缓存系统，还是开发实时数据处理应用，这都是一份不可或缺的实战指南。 ","date":"2024-10-22","objectID":"/posts/redis/:0:0","tags":["Redis","NoSQL","缓存系统","分布式缓存","数据库","高性能","后端开发","分布式系统","性能优化","实时处理"],"title":"Redis 核心精讲：从入门到性能优化","uri":"/posts/redis/"},{"categories":["数据库","缓存技术","分布式系统","后端技术","性能优化"],"content":"I. 简介 Redis(Remote Dictionary Service) 全称远程字典服务，一种NoSQL (Not Only SQL). Redis is an in-memory data structure store used as a database,cache, message broker, and streaming engine. ","date":"2024-10-22","objectID":"/posts/redis/:1:0","tags":["Redis","NoSQL","缓存系统","分布式缓存","数据库","高性能","后端开发","分布式系统","性能优化","实时处理"],"title":"Redis 核心精讲：从入门到性能优化","uri":"/posts/redis/"},{"categories":["数据库","缓存技术","分布式系统","后端技术","性能优化"],"content":"II. 基本数据类型 Redis 数据库中的每个键值对（Key-Value pair）都是由对象（Object）组成，其中： 数据库键（Key）：总是一个字符串对象（String Object） 数据库键对应的值（Value）：可以是 字符串对象（String Object）、列表对象（List Object）、 哈希对象（Hash Object）、集合对象（Set Object）、 **有序集合对象（Sorted Set Object）**中的一种 ","date":"2024-10-22","objectID":"/posts/redis/:2:0","tags":["Redis","NoSQL","缓存系统","分布式缓存","数据库","高性能","后端开发","分布式系统","性能优化","实时处理"],"title":"Redis 核心精讲：从入门到性能优化","uri":"/posts/redis/"},{"categories":["数据库","缓存技术","分布式系统","后端技术","性能优化"],"content":"String 字符串类型 Value 可以是字符串、也可以是数字 使用场景：计数（点赞数、粉丝数）、缓存 ","date":"2024-10-22","objectID":"/posts/redis/:2:1","tags":["Redis","NoSQL","缓存系统","分布式缓存","数据库","高性能","后端开发","分布式系统","性能优化","实时处理"],"title":"Redis 核心精讲：从入门到性能优化","uri":"/posts/redis/"},{"categories":["数据库","缓存技术","分布式系统","后端技术","性能优化"],"content":"List 列表类型 在 Redis 中，可以把 List 搞成队列、栈、阻塞队列. List 的 Key 的底层实现就是一个链表，其中链表的每一个节点都保存了一个整数值. Redis 链表实现的特性： 双向：链表节点都有 prev 和 next 指针 -\u003e 获取某个节点的前继节点和后继节点的复杂度都是O(1) 无环：链表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL 表头指针 / 表尾指针：List 结构中存在 head 和 tail 指针 长度计数器：List 结构中存在 len 属性 多态：List 节点使用 void* 指针来保存节点值，并可以通过 List 结构中的 dup、free、match、sane 属性为节点值设置类型特定函数 -\u003e List 可以存储各种不同类型的值 使用场景：列表（关注列表、粉丝列表、消息列表，…） ","date":"2024-10-22","objectID":"/posts/redis/:2:2","tags":["Redis","NoSQL","缓存系统","分布式缓存","数据库","高性能","后端开发","分布式系统","性能优化","实时处理"],"title":"Redis 核心精讲：从入门到性能优化","uri":"/posts/redis/"},{"categories":["数据库","缓存技术","分布式系统","后端技术","性能优化"],"content":"III. 常见问题 Redis 为什么是单线程？ 官方表示：Redis 是基于内存操作的，CPU不是Redis的性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以用单线程实现，就没必要使用多线程了。 Redis 的提供数据为 100000+ (10W+) 的QPS，非常快 Redis 为什么单线程还这么快？ 多线程（CPU上下文切换）不一定比单线程效率高！！！Redis 是将所有的数据全部存放在内存中的，所有说单线程去操作效率就是最高的，多线程（CPU上下文切换，是一个耗时操作）； 对于内存系统来说，如果没有上下文切换效率就是最高的！多次读写都是在一个CPU上完成的，在内存情况下就是最佳方案！ ","date":"2024-10-22","objectID":"/posts/redis/:3:0","tags":["Redis","NoSQL","缓存系统","分布式缓存","数据库","高性能","后端开发","分布式系统","性能优化","实时处理"],"title":"Redis 核心精讲：从入门到性能优化","uri":"/posts/redis/"},{"categories":["数据库","缓存技术","分布式系统","后端技术","性能优化"],"content":"IV. Reference ","date":"2024-10-22","objectID":"/posts/redis/:3:1","tags":["Redis","NoSQL","缓存系统","分布式缓存","数据库","高性能","后端开发","分布式系统","性能优化","实时处理"],"title":"Redis 核心精讲：从入门到性能优化","uri":"/posts/redis/"},{"categories":["Go语言","日志管理","性能优化","应用监控","最佳实践"],"content":"深入探讨 Go 语言高性能日志库 Zap 的实践应用，从基础配置到生产环境的最佳实践。通过实例讲解如何构建一个灵活、高效的日志系统，特别关注容器化环境下的日志处理策略，帮助你打造一个专业的日志解决方案。","date":"2024-10-20","objectID":"/posts/golang-zap/","tags":["Go","Golang","Zap","日志框架","性能优化","日志管理","最佳实践","应用监控","错误追踪","工程实践"],"title":"Go 日志最佳实践：Zap 从入门到实战","uri":"/posts/golang-zap/"},{"categories":["Go语言","日志管理","性能优化","应用监控","最佳实践"],"content":" 导语 在现代微服务架构中，一个优秀的日志系统是保障应用可观测性的关键。Zap 作为 Go 生态中最受欢迎的日志库之一，以其卓越的性能和灵活的配置闻名。本文将带你深入了解 Zap 的实践应用，从基础配置到容器化环境下的最佳实践，帮助你构建一个既高效又易于维护的日志系统。无论是构建新项目还是优化现有系统，这都是一份不可或缺的实战指南。 如果你的应用采用容器化部署，其实更建议将日志输出到标准输出。 容器平台一般都具有采集容器日志的能力。 采集日志时，可以选择从标准输出采集或者容器中的日志文件采集，如果是从日志文件进行采集，通常需要配置日志采集路径，但如果是从标准输出采集，则不用。 所以，如果将日志直接输出到标准输出，则可以不加配置直接复用容器平台已有的能力，做到记录日志和采集日志完全解耦。 定制开发步骤分为以下几步： 创建一个封装了 zap.Logger 的自定义 Logger； 编写创建函数，创建 zapLogger 对象； 创建 *zap.Logger 对象； 实现日志接口。 ","date":"2024-10-20","objectID":"/posts/golang-zap/:0:0","tags":["Go","Golang","Zap","日志框架","性能优化","日志管理","最佳实践","应用监控","错误追踪","工程实践"],"title":"Go 日志最佳实践：Zap 从入门到实战","uri":"/posts/golang-zap/"},{"categories":["开发工具","命令行工具","效率工具","Linux工具","远程开发"],"content":"全面解析 Tmux 的核心功能和实用技巧，从基础命令到高级配置，从简单操作到复杂场景。通过实例讲解帮助你掌握这款强大的终端复用工具，提升命令行操作效率。特别适合需要远程管理服务器的开发者和系统管理员。","date":"2024-10-03","objectID":"/posts/terminal-configure-guide/","tags":["tmux","终端复用","命令行工具","CLI","终端管理","远程开发","效率工具","Linux工具","开发环境","SSH工具"],"title":"终端神器：一篇文章玩转终端神器 Tmux，ZSH，Oh-My-Zsh","uri":"/posts/terminal-configure-guide/"},{"categories":["开发工具","命令行工具","效率工具","Linux工具","远程开发"],"content":" 导语 在现代开发环境中，高效的终端管理是提升工作效率的关键。Tmux 作为一款强大的终端复用工具，不仅能让你在一个终端窗口中同时操作多个会话，还能实现窗口分割、会话保持等高级功能。无论是本地开发还是远程服务器管理，Tmux 都能让你的终端操作更加得心应手。本文将带你全面了解 Tmux 的各项功能，从基础操作到高级配置，让你的终端使用效率得到质的飞跃。 ","date":"2024-10-03","objectID":"/posts/terminal-configure-guide/:0:0","tags":["tmux","终端复用","命令行工具","CLI","终端管理","远程开发","效率工具","Linux工具","开发环境","SSH工具"],"title":"终端神器：一篇文章玩转终端神器 Tmux，ZSH，Oh-My-Zsh","uri":"/posts/terminal-configure-guide/"},{"categories":["开发工具","命令行工具","效率工具","Linux工具","远程开发"],"content":"TMux ","date":"2024-10-03","objectID":"/posts/terminal-configure-guide/:1:0","tags":["tmux","终端复用","命令行工具","CLI","终端管理","远程开发","效率工具","Linux工具","开发环境","SSH工具"],"title":"终端神器：一篇文章玩转终端神器 Tmux，ZSH，Oh-My-Zsh","uri":"/posts/terminal-configure-guide/"},{"categories":["开发工具","命令行工具","效率工具","Linux工具","远程开发"],"content":"Feature 强劲的、易于使用的命令行界面 可以横向、纵向分割窗口 窗格可以自由移动和调整大小，或直接利用四个预设布局之一 支持 UTF-8 编码及 256 色终端 可在多个缓冲区进行复制和粘贴 可通过交互式菜单来选择窗口、会话及客户端 支持跨窗口搜索 支持自动及手动锁定窗口 可以自由配置绑定快捷键 ","date":"2024-10-03","objectID":"/posts/terminal-configure-guide/:1:1","tags":["tmux","终端复用","命令行工具","CLI","终端管理","远程开发","效率工具","Linux工具","开发环境","SSH工具"],"title":"终端神器：一篇文章玩转终端神器 Tmux，ZSH，Oh-My-Zsh","uri":"/posts/terminal-configure-guide/"},{"categories":["开发工具","命令行工具","效率工具","Linux工具","远程开发"],"content":"Tmux 中的 server, session, window 和 Pane 在 Tmux 系统中，存在以下极其重要的大小层级: Server -\u003e Session -\u003e Window -\u003e Pane. Server: 整个 tmux 的后台服务. NOTE: 当配置文件不生效时，就需要使用 tmux kill-server 来重启 Tmux Session: 可以理解为 workplace Window: 相当于 VIM 中的buffer Pane: 窗口中的小分屏，相当于 VIM 中的 split / vsplit ","date":"2024-10-03","objectID":"/posts/terminal-configure-guide/:1:2","tags":["tmux","终端复用","命令行工具","CLI","终端管理","远程开发","效率工具","Linux工具","开发环境","SSH工具"],"title":"终端神器：一篇文章玩转终端神器 Tmux，ZSH，Oh-My-Zsh","uri":"/posts/terminal-configure-guide/"},{"categories":["开发工具","命令行工具","效率工具","Linux工具","远程开发"],"content":"Installation Require: version \u003e= 2.1 Linux yum install -y tmux yay -S tmux apt-get install tmux Mac brew install tmux ","date":"2024-10-03","objectID":"/posts/terminal-configure-guide/:1:3","tags":["tmux","终端复用","命令行工具","CLI","终端管理","远程开发","效率工具","Linux工具","开发环境","SSH工具"],"title":"终端神器：一篇文章玩转终端神器 Tmux，ZSH，Oh-My-Zsh","uri":"/posts/terminal-configure-guide/"},{"categories":["开发工具","命令行工具","效率工具","Linux工具","远程开发"],"content":"常用命令 Tmux 的默认 prefix-key 是 \u003cC-b\u003e 启动新 session $ tmux [new -s sessionName -n windowName] # e.g. tmux new -s kyden -n nvim 恢复 Session tmux at[-t sessionName] Session List tmux ls 关闭 Session tmux kill-session -t sessionName 关闭整个 tmux 服务器 tmux kill-server Session Command prefix-key command description \u003cC-b\u003e ? 显示快捷键帮助文档 \u003cC-b\u003e d 断开当前 Session \u003cC-b\u003e r 强制重载当前 Session \u003cC-b\u003e : 进入命令模式，可直接输入命令 Window Command prefix-key command description \u003cC-b\u003e c 新建窗口 \u003cC-b\u003e \u0026 关闭当前窗口 \u003cC-b\u003e p / n / \u003cnumber\u003e 切换到上一个 / 下一个 / 指定窗口 \u003cC-b\u003e w 打开窗口列表，用于切换窗口 \u003cC-b\u003e , 重命名当前窗口 \u003cC-b\u003e . 修改窗口编号 Pane Command prefix-key command description \u003cC-b\u003e \" / % 新建上下 / 左右 pane \u003cC-b\u003e x 关闭当前 pane \u003cC-b\u003e z 最大化当前 pane(重复取消最大化) \u003cC-b\u003e q 显示面板编号，在编号消失前输入对应的数字可切换到相应的面板 \u003cC-b\u003e \u003cleft\u003e / \u003cright\u003e / up / down 移动光标切换面板 \u003cC-b\u003e o 选择下一 pane \u003cC-b\u003e \u003cspace\u003e 在自带的面板布局中循环切换 ","date":"2024-10-03","objectID":"/posts/terminal-configure-guide/:1:4","tags":["tmux","终端复用","命令行工具","CLI","终端管理","远程开发","效率工具","Linux工具","开发环境","SSH工具"],"title":"终端神器：一篇文章玩转终端神器 Tmux，ZSH，Oh-My-Zsh","uri":"/posts/terminal-configure-guide/"},{"categories":["开发工具","命令行工具","效率工具","Linux工具","远程开发"],"content":"配置文件 配置文件 .tmux.conf 通常位于 ~/.tmux.conf 处，可输入 restart tmux 进行 mtux 重启 # recover colorful terminal set -g default-terminal \"xterm-256color\" # 窗口面板起始序列号 set -g base-index 1 set -g pane-base-index 1 # 从tmux v1.6版起，支持设置第二个指令前缀，使用 ` 作为第二指令前缀 # set-option -g prefix2 ` # (Tmux v2.1) 支持鼠标: 选取文本、调整面板大小、选中并切换面板 set-option -g mouse on # 状态栏窗口名称格式 set -wg window-status-format \" #I #W \" # 状态栏当前窗口名称格式(#I：序号，#w：窗口名称，#F：间隔符) set -wg window-status-current-format \" #I:#W#F \" # 状态栏窗口名称之间的间隔 set -wg window-status-separator \"\" # 开启vi风格后，支持vi的C-d、C-u、hjkl等快捷键 setw -g mode-keys vi # 绑定 Escape 进入 复制 模式 bind Escape copy-mode setw -g automatic-rename off setw -g allow-rename off ","date":"2024-10-03","objectID":"/posts/terminal-configure-guide/:1:5","tags":["tmux","终端复用","命令行工具","CLI","终端管理","远程开发","效率工具","Linux工具","开发环境","SSH工具"],"title":"终端神器：一篇文章玩转终端神器 Tmux，ZSH，Oh-My-Zsh","uri":"/posts/terminal-configure-guide/"},{"categories":["开发工具","命令行工具","效率工具","Linux工具","远程开发"],"content":"zsh ","date":"2024-10-03","objectID":"/posts/terminal-configure-guide/:2:0","tags":["tmux","终端复用","命令行工具","CLI","终端管理","远程开发","效率工具","Linux工具","开发环境","SSH工具"],"title":"终端神器：一篇文章玩转终端神器 Tmux，ZSH，Oh-My-Zsh","uri":"/posts/terminal-configure-guide/"},{"categories":["开发工具","命令行工具","效率工具","Linux工具","远程开发"],"content":"zsh 介绍与安装 ZSH 是一个兼容 bash 的 shell，相较于 bash 具有以下优点： Tab 补全功能强大。命令、命令参数、文件路径均可以补全 插件丰富。快速输入以前使用过的命令、快速跳转文件夹、显示系统负载这些都可以通过插件实现 主题丰富 可定制性高 Installation # macos brew install zsh # Arch Linux pacman -S zsh 设置 zsh 为默认 shell: chsh -s /bin/zsh ","date":"2024-10-03","objectID":"/posts/terminal-configure-guide/:2:1","tags":["tmux","终端复用","命令行工具","CLI","终端管理","远程开发","效率工具","Linux工具","开发环境","SSH工具"],"title":"终端神器：一篇文章玩转终端神器 Tmux，ZSH，Oh-My-Zsh","uri":"/posts/terminal-configure-guide/"},{"categories":["开发工具","命令行工具","效率工具","Linux工具","远程开发"],"content":"oh-my-zsh cURL 下载并安装 oh-my-zsh sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" powerlevel10k theme # 下载 git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k # 设置 in .zshrc ZSH_THEME=\"powerlevel10k/powerlevel10k\" zsh-autosuggestions zsh-autosuggestions 是一个命令提示插件，当你输入命令时，会自动推测你可能需要输入的命令，按下右键可以快速采用建议 # Download git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions # Set in .zshrc plugins=(... zsh-autosuggestions ...) zsh-syntax-highlighting zsh-syntax-highlighting 是一个命令语法校验插件，在输入命令的过程中，若指令不合法，则指令显示为红色，若指令合法就会显示为绿色。 # Download git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting # Set in .zshrc plugins=(... zsh-syntax-highlighting ...) z oh-my-zsh 内置了 z 插件。z 是一个文件夹快捷跳转插件，对于曾经跳转过的目录，只需要输入最终目标文件夹名称，就可以快速跳转，避免再输入长串路径，提高切换文件夹的效率。 # Set in .zshrc plugins=(... z ...) extract oh-my-zsh 内置了 extract 插件。extract 用于解压任何压缩文件，不必根据压缩文件的后缀名来记忆压缩软件 使用 x 命令即可解压文件 # Set in .zshrc plugins=(... extract ...) Supported file extensions Extension Description 7z 7zip file Z Z archive (LZW) apk Android app file aar Android library file bz2 Bzip2 file cab Microsoft cabinet archive cpio Cpio archive deb Debian package ear Enterprise Application aRchive exe Windows executable file gz Gzip file ipa iOS app package ipsw iOS firmware file jar Java Archive lrz LRZ archive lz4 LZ4 archive lzma LZMA archive obscpio cpio archive used on OBS rar WinRAR archive rpm RPM package sublime-package Sublime Text package tar Tarball tar.bz2 Tarball with bzip2 compression tar.gz Tarball with gzip compression tar.lrz Tarball with lrzip compression tar.lz Tarball with lzip compression tar.lz4 Tarball with lz4 compression tar.xz Tarball with lzma2 compression tar.zma Tarball with lzma compression tar.zst Tarball with zstd compression tbz Tarball with bzip compression tbz2 Tarball with bzip2 compression tgz Tarball with gzip compression tlz Tarball with lzma compression txz Tarball with lzma2 compression tzst Tarball with zstd compression vsix VS Code extension zip file war Web Application archive (Java-based) whl Python wheel file xpi Mozilla XPI module file xz LZMA2 archive zip Zip archive zlib zlib archive zst Zstandard file (zstd) zpaq Zpaq file web-search oh-my-zsh 内置了 web-search 插件。web-search 能让我们在命令行中使用搜索引擎进行搜索。使用搜索引擎关键字+搜索内容 即可自动打开浏览器进行搜索 使用 web-search 命令即可搜索 # Set in .zshrc plugins=(... web-search ...) 例如，这两个是等价的: web_search google oh-my-zsh google oh-my-zsh 一些常用的搜索上下文如下： Context URL bing https://www.bing.com/search?q= google https://www.google.com/search?q= github https://github.com/search?q= baidu https://www.baidu.com/s?wd= youtube https://www.youtube.com/results?search_query= chatgpt https://chatgpt.com/?q= Uninstall uninstall_oh_my_zsh ","date":"2024-10-03","objectID":"/posts/terminal-configure-guide/:2:2","tags":["tmux","终端复用","命令行工具","CLI","终端管理","远程开发","效率工具","Linux工具","开发环境","SSH工具"],"title":"终端神器：一篇文章玩转终端神器 Tmux，ZSH，Oh-My-Zsh","uri":"/posts/terminal-configure-guide/"},{"categories":["Go语言","开发工具","配置管理","应用框架","最佳实践"],"content":"深入探讨 Go 应用程序的配置管理最佳实践，从配置文件选型到 Viper 的高级特性，全方位讲解如何实现优雅的配置管理方案。包含热重载、环境变量、配置文件等多种场景的实战指南。","date":"2024-09-22","objectID":"/posts/go-viper/","tags":["Go","Golang","Viper","配置管理","配置工具","开发工具","最佳实践","项目实战","应用开发","工程实践"],"title":"Go 配置管理最佳实践：Viper 从入门到精通","uri":"/posts/go-viper/"},{"categories":["Go语言","开发工具","配置管理","应用框架","最佳实践"],"content":" 导语 配置管理看似简单，但要做好却不容易。如何选择合适的配置方式？如何实现配置热重载？如何优雅地处理多环境配置？本文将带你探索 Go 生态中最受欢迎的配置管理解决方案 Viper，通过实战案例和最佳实践，帮助你构建一个灵活、强大、易维护的配置管理系统。从配置文件格式的选择到 Viper 的高级特性，一文掌握配置管理的精髓。 对于一个 Go 应用程序，同城需要解析以下类别的配置：命令行选项、命令行参数、配置文件，而对于一个非命令行工具的应用程序，不需要考虑读取命令行参数这类场景，其需要的配置内容都可以通过命令行选项或配置文件加载到程序中。 Tips 命令行工具可能会有子命令，例如 kubectr create 中的 create 就是一个命令行参数 ","date":"2024-09-22","objectID":"/posts/go-viper/:0:0","tags":["Go","Golang","Viper","配置管理","配置工具","开发工具","最佳实践","项目实战","应用开发","工程实践"],"title":"Go 配置管理最佳实践：Viper 从入门到精通","uri":"/posts/go-viper/"},{"categories":["Go语言","开发工具","配置管理","应用框架","最佳实践"],"content":"为何选择配置文件作为配置项的读取方式？ 对于一个配置项，既可以通过命令行选项，又能够通过配置文件来读取，而且二者是一个彼此可以取代的，因此，对于非命令行工具的应用程序个人更倾向于通过配置文件完成，原因如下： 配置文件更易部署：可以将应用所需要的所有配置聚合在一个配置文件中。 当需署时，只需要部署、加载这个配置文件即可，不需要配置一大堆命令行选项； 配置文件更易维护：将所有的配置项都保存在配置文件中，加上详细的配置说明，不需要的配置项可以注释掉。 一个具有全量配置项、详细说明的配置文件，更易于理解。并且在修改时，只需要修改配置项的值，而不需要修改配置项名称，更不易出错； 配置文件可以实现热加载功能：应用程序监听配置文件的变更，有变更时，自动重新加载配置文件，实现配置热加载功能； 配置层次表达更清晰：命令行参数无法直接表达\"层次\"，但配置文件可以。层次化的配置表达，更易于理解，也更易于维护。 方便新增配置项：多数情况下，配置项新增只需在配置文件中新增一行即可，不需要修改源码； 总结 命令行工具可能会有子命令，例如 kubectr create 中的 create 就是一个命令行参数 总结：当配置项少的时候（比如 5 个以内），可以从命令行选项中读取。 参数较多的时候，建议使用配置文件，配置文件更易部署、维护、热加载、层次表达更清晰。 ","date":"2024-09-22","objectID":"/posts/go-viper/:1:0","tags":["Go","Golang","Viper","配置管理","配置工具","开发工具","最佳实践","项目实战","应用开发","工程实践"],"title":"Go 配置管理最佳实践：Viper 从入门到精通","uri":"/posts/go-viper/"},{"categories":["Go语言","开发工具","配置管理","应用框架","最佳实践"],"content":"为何选择 YAML 作为配置文件的格式？ 当打算采用配置文件来读取配置项时，那么就存在多种文件格式，例如：JSON、YAML、TOML、INI 等。 个人推荐使用 YAML，理由如下： YAML 语法简单、格式易读、程序易处理； YAML 格式可以表达非常丰富、复杂的配置结构； YAML 格式普适性高，新人零理解成本； 最终配置：使用 YAML 格式的配置文件，并采用 viper 来读取配置 ","date":"2024-09-22","objectID":"/posts/go-viper/:2:0","tags":["Go","Golang","Viper","配置管理","配置工具","开发工具","最佳实践","项目实战","应用开发","工程实践"],"title":"Go 配置管理最佳实践：Viper 从入门到精通","uri":"/posts/go-viper/"},{"categories":["Go语言","开发工具","配置管理","应用框架","最佳实践"],"content":"使用 viper 读取配置文件内容 在 浅析现代化命令行框架 Cobra 中，我们了解到可以通过 cobra-cli init --viper 生成一个通过 viper 来配置应用程序的 Demo 应用，那么就可以知道它的应用加载逻辑如下： /* Copyright 2024 Kyden This file is part of CLI application foo. */ package cmd import ( \"fmt\" \"os\" \"github.com/spf13/cobra\" \"github.com/spf13/viper\" ) var cfgFile string // rootCmd represents the base command when called without any subcommands var rootCmd = \u0026cobra.Command{ Use: \"kydendemo\", Short: \"A brief description of your application\", Long: `A longer description that spans multiple lines and likely contains examples and usage of using your application. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application.`, // Uncomment the following line if your bare application // has an action associated with it: // Run: func(cmd *cobra.Command, args []string) { }, } // Execute adds all child commands to the root command and sets flags appropriately. // This is called by main.main(). It only needs to happen once to the rootCmd. func Execute() { err := rootCmd.Execute() if err != nil { os.Exit(1) } } func init() { cobra.OnInitialize(initConfig) // Here you will define your flags and configuration settings. // Cobra supports persistent flags, which, if defined here, // will be global for your application. rootCmd.PersistentFlags().StringVar( \u0026cfgFile, \"config\", \"\", \"config file (default is $HOME/.kydendemo.yaml)\") // Cobra also supports local flags, which will only run // when this action is called directly. rootCmd.Flags().BoolP(\"toggle\", \"t\", false, \"Help message for toggle\") } // initConfig reads in config file and ENV variables if set. func initConfig() { if cfgFile != \"\" { // Use config file from the flag. viper.SetConfigFile(cfgFile) } else { // Find home directory. home, err := os.UserHomeDir() cobra.CheckErr(err) // Search config in home directory with name \".kydendemo\" (without extension). viper.AddConfigPath(home) viper.SetConfigType(\"yaml\") viper.SetConfigName(\".kydendemo\") } viper.AutomaticEnv() // read in environment variables that match // If a config file is found, read it in. if err := viper.ReadInConfig(); err == nil { fmt.Fprintln(os.Stderr, \"Using config file:\", viper.ConfigFileUsed()) } } 其中，rootCmd 设置了命令行选项 --config，用于指定配置文件路径，默认值是 \"\"； 通过 cobra.OnInitialize(initConfig) 设置了 kydendemo 在运行时的回调函数 initConfig， 它的执行逻辑主要是： 如果指定了 cfgFile，则直接读取该配置文件； 如果没有指定，则读取 $HOME/.kydendemo.yaml，找到则读取； 若 cfgFile == \"\"，且没有找到配置文件，则调用 viper.ReadInConfig() 读取配置文件时报错； ","date":"2024-09-22","objectID":"/posts/go-viper/:3:0","tags":["Go","Golang","Viper","配置管理","配置工具","开发工具","最佳实践","项目实战","应用开发","工程实践"],"title":"Go 配置管理最佳实践：Viper 从入门到精通","uri":"/posts/go-viper/"},{"categories":["Go语言","开发工具","配置管理","应用框架","最佳实践"],"content":"Reference viper ","date":"2024-09-22","objectID":"/posts/go-viper/:4:0","tags":["Go","Golang","Viper","配置管理","配置工具","开发工具","最佳实践","项目实战","应用开发","工程实践"],"title":"Go 配置管理最佳实践：Viper 从入门到精通","uri":"/posts/go-viper/"},{"categories":["Go语言","工具开发","CLI工具","应用框架","最佳实践"],"content":"深入浅出地介绍 Cobra 框架的核心特性和最佳实践，从项目初始化到命令构建，手把手教你打造专业级命令行应用。适合想要开发现代化 CLI 工具的 Go 开发者。","date":"2024-09-21","objectID":"/posts/go-cobra/","tags":["Go","Golang","Cobra","CLI开发","命令行工具","工具开发","应用框架","开发效率","最佳实践","项目实战"],"title":"Cobra 实战指南：10分钟搭建现代化命令行应用","uri":"/posts/go-cobra/"},{"categories":["Go语言","工具开发","CLI工具","应用框架","最佳实践"],"content":" 导语 想要开发一个专业的命令行工具，但又担心开发过程繁琐？Cobra 框架可以帮你轻松实现！本文将带你探索这个被 Kubernetes、Docker 等知名项目广泛采用的命令行框架，通过实例演示和最佳实践，让你快速掌握构建现代化 CLI 应用的核心技巧。从基础概念到高级特性，从项目初始化到功能实现，一文掌握 Cobra 开发精髓。 ","date":"2024-09-21","objectID":"/posts/go-cobra/:0:0","tags":["Go","Golang","Cobra","CLI开发","命令行工具","工具开发","应用框架","开发效率","最佳实践","项目实战"],"title":"Cobra 实战指南：10分钟搭建现代化命令行应用","uri":"/posts/go-cobra/"},{"categories":["Go语言","工具开发","CLI工具","应用框架","最佳实践"],"content":"I. Cobra 简介 Cobra 是一个可以创建强大的现代化 CLI 应用程序库，它还提供了一个可以生成应用和命令文件的程序的命令行工具：cobra-cli。 许多大型项目（e.g. kubernetes, Docker, Etcd, Rkt, Hugo etc.）都采用了 cobra 来构建他们的应用程序。 Cobra 具有很多特性，一些核心特性如下： 可以构建基于子命令的 CLI，并支持嵌套子命令：app server, app fetch 可以通过 cobra-cli init appname \u0026 cobra-cli add cmdname 轻松生成应用和子命令 智能化命令建议：app srver...did you mean app server 自动生成命令和标志的 helpe 文本，并能自动识别 -h, --help 等标志 自动为应用程序生成 bash、zsh、fish、powershell 自动补全脚本 支持命令别名、自定义帮助、自定义用法等 可以与 viper、pflag 紧密集成，用于构建 12-factor 应用程序 Cobra 建立在 commands、arguments 和 flags 结构之上。Commands 代表命令，arguments 代表非选项参数，flags 代表选项参数（标志）。 CLI 模式 一个好的应用程序应该是易懂的，用户可以清晰知道如何去使用这个应用程序，因此通常遵循如下模式： APPNAME VERB NOUN --ADJECTIVE 或者 APPNAME COMMAND ARG --FLAG，例如： # clone 是一个 Commands # URL 是一个非选项参数 # bare 一个选项参数 git clone URL --bare NOTE：VERB 代表动词，NOUN 代表名词，ADJECTIVE 代表形容词 ","date":"2024-09-21","objectID":"/posts/go-cobra/:1:0","tags":["Go","Golang","Cobra","CLI开发","命令行工具","工具开发","应用框架","开发效率","最佳实践","项目实战"],"title":"Cobra 实战指南：10分钟搭建现代化命令行应用","uri":"/posts/go-cobra/"},{"categories":["Go语言","工具开发","CLI工具","应用框架","最佳实践"],"content":"II. cobra-cli 命令安装 Cobra 提供了 cobra-cli 命令，用来初始化一个应用程序并为其添加命令，方便开发基于 Cobra 的应用，可用以下方法进行安装： $ go install github.com/spf13/cobra-cli@latest # ... cobra-cli 提供了 4 个子命令： init: 初始化一个 cobra 应用程序 add: 给通过 cobra init 创建的应用程序添加子命令 completion: 为指定的 shell 生成命令自动补全脚本 help: 打印任意命令的帮助信息 cobra-cli 还提供了一些全局参数： -a, --author: 指定 Copyright 版权声明中的作者 --config: 指定 cobra 配置文件的路径 -l, --license: 指定生成的应用程序所使用的开源协议，内置的有：GPLv2, GPLv3, LGPL, AGPL, MIT, 2-Clause BSD or 3-Clause BSD； --viper: 使用 viper 作为命令行参数解析工具，默认为 true。 ","date":"2024-09-21","objectID":"/posts/go-cobra/:2:0","tags":["Go","Golang","Cobra","CLI开发","命令行工具","工具开发","应用框架","开发效率","最佳实践","项目实战"],"title":"Cobra 实战指南：10分钟搭建现代化命令行应用","uri":"/posts/go-cobra/"},{"categories":["Go语言","工具开发","CLI工具","应用框架","最佳实践"],"content":"III. Cobra 使用 在构建 cobra 应用时，可以自行组织代码目录结构，但 cobra 建议如下目录结构： $ tree app_name app_name ├── cmd │ ├── add.go │ ├── create.go │ └── list.go └── main.go main.go 文件的目的只有一个：初始化 cobra 应用程序并注册子命令 package main import ( \"{pathtToApp}/cmd\" ) func main() { cmd.Execute() } ","date":"2024-09-21","objectID":"/posts/go-cobra/:3:0","tags":["Go","Golang","Cobra","CLI开发","命令行工具","工具开发","应用框架","开发效率","最佳实践","项目实战"],"title":"Cobra 实战指南：10分钟搭建现代化命令行应用","uri":"/posts/go-cobra/"},{"categories":["Go语言","工具开发","CLI工具","应用框架","最佳实践"],"content":"使用 cobra-cli 命令生成应用程序并添加子命令 可以选择使用 cobra-cli 命令行工具快速生成一个应用程序，并添加子命令，然后基于生成的代码进行二次开发，提高开发效率，具体方法如下： 1. 初始化应用程序 使用 cobra-cli init 命令初始化一个应用程序，然后就可以基于这个 Demo 进行二次开发，提高开发效率： $ mkdir -p kyden-demo \u0026\u0026 cd kydne-demo \u0026\u0026 go mod init kyden-demo $ cobra-cli init --license=MIT --viper $ ls cmd go.mod go.sum LICENSE main.go 2. 添加子命令 当一个应用程序初始化完成之后，就可以使用 cobra-cli add 命令添加一些命令： $ cobra-cli add serve $ cobra-cli add config $ cobra-cli add create -p 'configCmd' # 此命令的父命令的变量名（默认为 'rootCmd'） $ tree kyden-demo kyden-demo ├── LICENSE ├── cmd │ ├── config.go │ ├── create.go │ ├── root.go │ └── serve.go ├── go.mod ├── go.sum └── main.go 执行 cobra-cli add 命令之后，会在 cmd 目录下生成命令源码文件。 cobra-cli 不仅可以添加命令，也可以添加子命令，例如 cobra-cli add create -p 'configCmd' 给 config 命令添加了 create 子命令，-p 指定子命令的父命令：\u003c父命令\u003eCmd. 3. 编译运行 在生成命令后，可以直接执行 go build 命令编译应用程序： $ go build -v . $ ./kyden-demo -h A longer description that spans multiple lines and likely contains examples and usage of using your application. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application. Usage: kyden-demo [command] Available Commands: completion Generate the autocompletion script for the specified shell config A brief description of your command help Help about any command serve A brief description of your command Flags: --config string config file (default is $HOME/.kyden-demo.yaml) -h, --help help for kyden-demo -t, --toggle Help message for toggle Use \"kyden-demo [command] --help\" for more information about a command. 4. 配置 cobra cobra 在生成应用程序时，也会在当前目录下生成 LINCENSE 文件，并且会在生成的 Go 源码文件中中，添加 LINCENSE Header。 LINCENSE 和 LINCENSE Header 的内容可以通过 cobra 配置文进行配置，默认配置文件 ~/.cobra.yaml: $ cat ~/.cobra.yaml author: Kyden \u003ckytedance@gmail.com\u003e year: 2024 license: header: This file is part of CLI application foo. text: | {{ .copyright }} This is my license. There are many like it, but this one is mine. My license is my best friend. It is my life. I must master it as I must master my life. $ cobra-cli init Copyright © 2024 Kyden \u003ckytedance@gmail.com\u003e This is my license. There are many like it, but this one is mine. My license is my best friend. It is my life. I must master it as I must master my life. {{ .copyright }} 的具体内容会根据 author 和 year 生成，根据此配置生成的 LICENSE 文件内容. 也可以使用内建的 licenses，内建的 licenses 有：GPLv2, GPLv3, LGPL, AGPL, MIT, 2-Clause BSD or 3-Clause BSD。 ","date":"2024-09-21","objectID":"/posts/go-cobra/:3:1","tags":["Go","Golang","Cobra","CLI开发","命令行工具","工具开发","应用框架","开发效率","最佳实践","项目实战"],"title":"Cobra 实战指南：10分钟搭建现代化命令行应用","uri":"/posts/go-cobra/"},{"categories":["Go语言","工具开发","CLI工具","应用框架","最佳实践"],"content":"使用 cobra 库创建命令 当使用 cobra 库编码实现一个应用程序，需要首选创建一个空的 main.go 文件和一个 rootCmd 文件，然后根据需要添加其他命令。 具体步骤如下： 创建 rootCmd $ mkdir -p cobrademo \u0026\u0026 cobrademo $ go mod init cobrademo go: creating new go.mod: module cobrademo go: to add module requirements and sums: go mod tidy $ cobra-cli init Using config file: /Users/kyden/.cobra.yml Your Cobra application is ready at /tmp/cobrademo 通常情况下，会将 rootCmd 放在 cmd/root.go 文件中 /* Copyright © 2024 Kyden \u003ckytedance@gmail.com\u003e This file is part of CLI application foo. */ package cmd import ( \"os\" \"github.com/spf13/cobra\" ) // rootCmd represents the base command when called without any subcommands var rootCmd = \u0026cobra.Command{ Use: \"cobrademo\", Short: \"A brief description of your application\", Long: `A longer description that spans multiple lines and likely contains examples and usage of using your application. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application.`, Run: func(cmd *cobra.Command, args []string) { // Do stuff here }, } // Execute adds all child commands to the root command and sets flags appropriately. // This is called by main.main(). It only needs to happen once to the rootCmd. func Execute() { err := rootCmd.Execute() if err != nil { os.Exit(1) } } func init() { // Here you will define your flags and configuration settings. // Cobra supports persistent flags, which, if defined here, // will be global for your application. // rootCmd.PersistentFlags().StringVar(\u0026cfgFile, \"config\", \"\", \"config file (default is $HOME/.cobrademo.yaml)\") // Cobra also supports local flags, which will only run // when this action is called directly. rootCmd.Flags().BoolP(\"toggle\", \"t\", false, \"Help message for toggle\") } 还可以在 init() 函数中定义标志和处理配置，例如：cmd/helper.go: 创建 main.go 还需要一个 main 函数来调用 rootCmd，通常会创建一个 main.go 文件，在 main.go 中调用 rootCmd.Execute() 来执行命令： package main import ( \"{pathToApp}/cmd\" ) func main() { cmd.Execute() } 在 main.go 中不建议放太多代码，通常只需要调用 cmd.Execute() 即可 添加命令 除了 rootCmd，还可以调用 AddCommand() 来添加其他命令，通常情况下，会把其他命令的源码文件放在 cmd 目录下，例如添加一个 version 命令（cmd/version.go）： /* Copyright © 2024 Kyden \u003ckytedance@gmail.com\u003e This file is part of CLI application foo. */ package cmd import ( \"fmt\" \"github.com/spf13/cobra\" ) // versionCmd represents the version command var versionCmd = \u0026cobra.Command{ Use: \"version\", Short: \"A brief description of your command\", Long: `A longer description that spans multiple lines and likely contains examples and usage of using your command. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application.`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"version called\") }, } func init() { rootCmd.AddCommand(versionCmd) // Here you will define your flags and configuration settings. // Cobra supports Persistent Flags which will work for this command // and all subcommands, e.g.: // versionCmd.PersistentFlags().String(\"foo\", \"\", \"A help for foo\") // Cobra supports local flags which will only run when this command // is called directly, e.g.: // versionCmd.Flags().BoolP(\"toggle\", \"t\", false, \"Help message for toggle\") } 编译运行 $ go build -v . $ ./cobrademo -h A longer description that spans multiple lines and likely contains examples and usage of using your application. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application. Usage: cobrademo [flags] cobrademo [command] Available Commands: completion Generate the autocompletion script for the specified shell help Help about any command helper A brief description of your command version A brief description of your command Flags: -h, --help help for cobrademo -t, --toggle Help message for toggle Use \"cobrademo [command] --help\" for more information about a command. ","date":"2024-09-21","objectID":"/posts/go-cobra/:3:2","tags":["Go","Golang","Cobra","CLI开发","命令行工具","工具开发","应用框架","开发效率","最佳实践","项目实战"],"title":"Cobra 实战指南：10分钟搭建现代化命令行应用","uri":"/posts/go-cobra/"},{"categories":["Go语言","工具开发","CLI工具","应用框架","最佳实践"],"content":"使用标志 cobra 可以跟 pflag 结合使用，实现强大的标志功能。 具体步骤如下： 使用持久化的标志 标志是可以\"持久化\"的，即该标志可用于它所分配的命令以及该命令下的每个子命令。 例如，在 rootCmd 中定义持久化标志： rootCmd.PersistentFlags().BoolVarP(\u0026Verbose, \"verbose\", \"v\", false, \"verbose output\") 使用本地标志 本地标志，只能在其所绑定的命令上使用： rootCmd.Flags().StringVarP(\u0026Source, \"source\", \"s\", \"\", \"Source directory to read from\") 上面的 --source 标志智能在 rootCmd 命令上引用，而不能在 rootCmd 的子命令上引用。 将标志绑定到 viper 可以讲标志绑定到 viper，这样就可以使用 viper.Get() 获取标志的值。 var auther string func init() { rootCmd.PersistentFlags().StringVar( \u0026auther, \"author\", \"Your Name\", \"Author name for copyright attribution\") viper.BindPFlag(\"author\", rootCmd.PersistentFlags().Lookup(\"auther\")) } 设置标志为必选 默认情况下，标志是可选的，也可以设置标志为必选。 当设置标志为必选时，若不提供标志时，cobra 会报错： rootCmd.Flags().StringVarP(\u0026Region, \"region\", \"r\", \"\", \"AWS region (required)\") rootCmd.MarkFlagRequired(\"region\") ","date":"2024-09-21","objectID":"/posts/go-cobra/:3:3","tags":["Go","Golang","Cobra","CLI开发","命令行工具","工具开发","应用框架","开发效率","最佳实践","项目实战"],"title":"Cobra 实战指南：10分钟搭建现代化命令行应用","uri":"/posts/go-cobra/"},{"categories":["Go语言","工具开发","CLI工具","应用框架","最佳实践"],"content":"IV. Reference cobra ","date":"2024-09-21","objectID":"/posts/go-cobra/:4:0","tags":["Go","Golang","Cobra","CLI开发","命令行工具","工具开发","应用框架","开发效率","最佳实践","项目实战"],"title":"Cobra 实战指南：10分钟搭建现代化命令行应用","uri":"/posts/go-cobra/"},{"categories":["构建工具","开发工具","自动化构建","项目管理","最佳实践"],"content":"深入剖析 Make 构建系统的核心概念和实践技巧。从基础语法到高级特性，从简单项目到复杂工程，全面讲解如何使用 Make 提升开发效率，打造专业的构建流程。","date":"2024-09-11","objectID":"/posts/make/","tags":["Make","Makefile","构建工具","自动化构建","项目管理","开发工具","最佳实践","CI/CD","工程实践","构建系统"],"title":"Make 构建系统详解：从基础到实战","uri":"/posts/make/"},{"categories":["构建工具","开发工具","自动化构建","项目管理","最佳实践"],"content":" 导语 在现代软件开发中，高效的构建系统是项目成功的关键要素。Make 作为经典的构建工具，以其简洁的语法和强大的功能闻名；本文将带你深入了解这个强大工具的使用方法，从基础概念到高级技巧，帮助你构建更加专业和高效的开发工作流。 ","date":"2024-09-11","objectID":"/posts/make/:0:0","tags":["Make","Makefile","构建工具","自动化构建","项目管理","开发工具","最佳实践","CI/CD","工程实践","构建系统"],"title":"Make 构建系统详解：从基础到实战","uri":"/posts/make/"},{"categories":["构建工具","开发工具","自动化构建","项目管理","最佳实践"],"content":"Makefile 特殊字符说明 $: 主要用于变量引用，$(CC) 引用名为 CC 的变量 #: 注释 :: 分隔目标和依赖，target: dependencies ;: 分隔命令，target: dependencies; command1; command2 =: 变量赋值(递归展开赋值)，CC = gcc :=: 立即赋值，VERSION := $(shell git describe) +=: 追加赋值，CFLAGS += -O3 -Wall ?=: 条件赋值（如果变量未定义），CC ?= gcc \\: 行继续符 OBJS = main.o \\ helper.o \\ utils.o %: 通配符，用于模式规则，%.o, %.c @: 禁止命令回显，@echo \"Building... $\u003c: 第一个依赖项 $@: 目标 $^: 所有依赖项 target: dep1 dep2 command $\u003c $@ $^ -: 忽略命令错误，rm temp.txt *: 通配符，匹配任意字符串，*.o wildcard、patsubst 等: 函数调用，$(wildcard *.c) ","date":"2024-09-11","objectID":"/posts/make/:1:0","tags":["Make","Makefile","构建工具","自动化构建","项目管理","开发工具","最佳实践","CI/CD","工程实践","构建系统"],"title":"Make 构建系统详解：从基础到实战","uri":"/posts/make/"},{"categories":["JSON","Encoder","Decoder"],"content":"全面解析 JSON 数据格式的核心概念、使用场景和最佳实践。从基础数据类型到高级特性，从编码规范到解码技巧，帮助你掌握这一主流数据交换格式的精髓，提升 Web 开发和 API 设计能力。","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/","tags":["JSON","Encoder","Decoder"],"title":"JSON 完全指南：从基础概念到编解码实战","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":" 导语 在现代 Web 开发中，JSON 已成为最受欢迎的数据交换格式。它不仅轻量级、易读易写，更因其语言无关性而被广泛应用于 API 设计和前后端通信。本文将带你全面了解 JSON，从其设计理念到实际应用，从基础语法到编码最佳实践。无论你是前端开发者还是后端工程师，掌握 JSON 都是提升开发效率的必备技能。 ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:0:0","tags":["JSON","Encoder","Decoder"],"title":"JSON 完全指南：从基础概念到编解码实战","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"I. 何为 JSON ? JSON 源于对实时服务器到浏览器会话通信协议的需求，无需使用 Flash 或 Java 小程序等浏览器插件，这是 2000 年代初期使用的主要方法。 JSON(JavsScript Object Notation，JavsScript 对象表示法)，由美国程序员道格拉斯·克罗克福特构想和设计的一种轻量级资料交换格式。 其内容由属性和值所组成，具有易于阅读和处理的优势。 JSON是独立于编程语言的资料格式，其不仅是JavaScript的子集，也采用了C语言家族的习惯用法，目前也有许多编程语言都能够将其解析和字符串化，其广泛使用的程度也使其成为通用的资料格式。 JSON 扩展名：.json 互联网媒体类型: application/json 类型代码: TEXT 统一类型标识: public.json 格式类型: 数据交换 扩展自: JavaScript 标准: RFC 7159, ECMA-404 网站: json.org ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:1:0","tags":["JSON","Encoder","Decoder"],"title":"JSON 完全指南：从基础概念到编解码实战","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"II. JSON 基本数据类型 ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:2:0","tags":["JSON","Encoder","Decoder"],"title":"JSON 完全指南：从基础概念到编解码实战","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"数值 十进制数值，不能有前导0，可以为负数，可以有小数部分，不区分整数与浮点数。 也可以用 e/E 表示指数部分，不能包含非数（如 NaN）。 JSON JavaScript 用双精度浮点数表示所有数值（后来也支持 BigInt） ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:2:1","tags":["JSON","Encoder","Decoder"],"title":"JSON 完全指南：从基础概念到编解码实战","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"字符串 以双引号 \"\" 括起来的零个或多个 Unicode 码位，支持反斜杠开始的转义字符序列。 ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:2:2","tags":["JSON","Encoder","Decoder"],"title":"JSON 完全指南：从基础概念到编解码实战","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"布尔值 表示为 true 或 false ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:2:3","tags":["JSON","Encoder","Decoder"],"title":"JSON 完全指南：从基础概念到编解码实战","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"数组 有序的零个或多个值 每个值可以为任意类型，并使用方括号[]包裹，元素之间使用逗号,分隔，例如[val, val]. ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:2:4","tags":["JSON","Encoder","Decoder"],"title":"JSON 完全指南：从基础概念到编解码实战","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"对象 若干无序的\"key-value\"对（key-value pairs），其中 key 只能是字符串，并以花括号{}包裹，多个\"key-value\"之间使用逗号,分隔，key 与 value 之间使用冒号:分隔 建议但不强制要求对象中的键是独一无二的。 ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:2:5","tags":["JSON","Encoder","Decoder"],"title":"JSON 完全指南：从基础概念到编解码实战","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"空值 表示为 null JSON JSON 交换时必须编码为UTF-8。 转义序列可以为: \\\\, \\\", \\/, \\b, \\f, \\n, \\r, \\t 或 Unicode16 进制转义字符序列（\\u后面跟随 4 位 16 进制数字）。 ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:2:6","tags":["JSON","Encoder","Decoder"],"title":"JSON 完全指南：从基础概念到编解码实战","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"III. Example { \"firstName\": \"John\", \"lastName\": \"Smith\", \"sex\": \"male\", \"age\": 25, \"address\": { \"streetAddress\": \"21 2nd Street\", \"city\": \"New York\", \"state\": \"NY\", \"postalCode\": \"10021\" }, \"phoneNumber\": [ { \"type\": \"home\", \"number\": \"212 555-1234\" }, { \"type\": \"fax\", \"number\": \"646 555-4567\" } ] } ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:3:0","tags":["JSON","Encoder","Decoder"],"title":"JSON 完全指南：从基础概念到编解码实战","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"IV. 与其他格式的比较 ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:4:0","tags":["JSON","Encoder","Decoder"],"title":"JSON 完全指南：从基础概念到编解码实战","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"XML JSON与XML最大的不同，在于XML是一个完整的标记语言，而JSON不是. 这使得XML在程序判读上需要比较多的功夫。主要的原因在于XML的设计理念与JSON不同。XML利用标记语言的特性提供了绝佳的延展性（如XPath），在数据存储，扩展及高级检索方面具备对JSON的优势，而JSON则由于比XML更加小巧，以及浏览器的内置快速解析支持，使得其更适用于网络数据传输领域。 ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:4:1","tags":["JSON","Encoder","Decoder"],"title":"JSON 完全指南：从基础概念到编解码实战","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"YAML 在功能和语法上，JSON 都是 YAML 语言的一个子集 特别是，YAML 1.2规范指定\"任何JSON格式的文件都是YAML格式的有效文件\"。最常见的 YAML 解析器也能够处理 JSON。 版本 1.2 之前的 YAML 规范没有完全涵盖 JSON，主要是由于 YAML 中缺乏本机 UTF-32 支持，以及对逗号分隔空格的要求；此外，JSON 规范还包括 /* */ 样式的注释。 YAML 最重要的区别是语法扩展集，它们在 JSON 中没有类似物： 关系数据支持：在 YAML 文档中，可以引用以前在文件/流中找到的锚点；通过这种方式，您可以表达递归结构。 支持除基元之外的可扩展数据类型，如字符串、数字、布尔值等。 支持带缩进的块语法； 它允许您在不使用不必要的符号的情况下描述结构化数据：各种括号、引号等。 ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:4:2","tags":["JSON","Encoder","Decoder"],"title":"JSON 完全指南：从基础概念到编解码实战","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"V. Reference JSON JavaScript RFC 7159 ECMA-404 json.org Unicode UTF-8 ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:5:0","tags":["JSON","Encoder","Decoder"],"title":"JSON 完全指南：从基础概念到编解码实战","uri":"/posts/json-encoder-decoder/"},{"categories":["check.rule","Linux","微服务","设计与实现"],"content":"深入剖析资格校验微服务的三层架构设计、工厂模式实现、服务发现机制，以及流量镜像与回放等高级特性的完整实践指南。","date":"2024-09-07","objectID":"/posts/check-rule/","tags":["check.rule","Linux","微服务","设计与实现"],"title":"微服务架构实战：打造高可用的资格校验服务","uri":"/posts/check-rule/"},{"categories":["check.rule","Linux","微服务","设计与实现"],"content":" 导语 如何设计一个既满足业务需求，又具备良好扩展性和可维护性的微服务？本文将以资格校验服务为例，深入探讨微服务架构设计的精髓。从三层架构的实现、依赖注入原则的应用，到服务发现、流量镜像等高级特性的落地，带你掌握企业级微服务开发的核心技巧。 ","date":"2024-09-07","objectID":"/posts/check-rule/:0:0","tags":["check.rule","Linux","微服务","设计与实现"],"title":"微服务架构实战：打造高可用的资格校验服务","uri":"/posts/check-rule/"},{"categories":["check.rule","Linux","微服务","设计与实现"],"content":"资格服务的三层架构设计 在实现本接口的过程中，为了应对多种规则校验需求，我们设计了一个基于三层架构的系统。 该设计遵循简洁架构的原则，以确保系统的高内聚和低耦合。 具体划分为以下三层：控制层（Controller）、业务层（Service / Biz）、存储层（Store）。 其中，控制层负责处理外部请求和响应，业务层负责规则的具体逻辑校验， 另外，由于本接口不会存储用户数据，因此存储层的职责由负责数据的持久化存储 转变为了负责外部数据进行交互。 从架构上看，层与层之间的依赖关系自上而下递进，即控制层依赖业务层，业务层依赖存储层，具体代码架构如下图所示： 在各层之间的代码设计上，遵循了严格的依赖倒置原则（DIP）。 具体来说， 控制层（Controller）可以导入业务层（Service）和存储层（Store） 的包，而非直接与存储层交互。 这样设计的好处是确保业务逻辑独立于数据存储，实现更强的扩展性和维护性。 需要特别注意的是，控制层不应直接导入存储层，除非有非常特殊的需求。 所有涉及存储的操作应通过业务层来完成，从而确保系统设计的层次清晰，职责明确。 ","date":"2024-09-07","objectID":"/posts/check-rule/:1:0","tags":["check.rule","Linux","微服务","设计与实现"],"title":"微服务架构实战：打造高可用的资格校验服务","uri":"/posts/check-rule/"},{"categories":["check.rule","Linux","微服务","设计与实现"],"content":"控制层（Controller） 控制层负责接收并处理来自客户端的请求， 具体操作包括：解析请求参数、进行参数校验、分发业务逻辑、整合处理结果并返回响应。 它的主要职责是将请求路由到业务层进行处理，而不直接涉及业务逻辑的实现。 在控制层中，我们通过 services.Servicer 接口将请求分发给业务层（Service）。 业务逻辑处理完成后，控制层将结果整合并返回给客户端，从而实现业务路由的功能。 FIXME 框图需要修改，应该严格按照具体操作来画 控制层结构示意图 ","date":"2024-09-07","objectID":"/posts/check-rule/:1:1","tags":["check.rule","Linux","微服务","设计与实现"],"title":"微服务架构实战：打造高可用的资格校验服务","uri":"/posts/check-rule/"},{"categories":["check.rule","Linux","微服务","设计与实现"],"content":"业务层（Biz/Service） 业务层是整个系统的核心，负责处理所有的业务逻辑。 当控制层接收到请求并将其转发至业务层时，业务层将根据具体的业务规则，调用存储层（Store）进行数据的 CURD。 在此层级中，所有的业务逻辑代码应集中于此，确保业务逻辑与其他逻辑（如存储和控制）解耦。 业务层的设计目标是让代码更具扩展性和可维护性。 业务层与存储层的交互 ","date":"2024-09-07","objectID":"/posts/check-rule/:1:2","tags":["check.rule","Linux","微服务","设计与实现"],"title":"微服务架构实战：打造高可用的资格校验服务","uri":"/posts/check-rule/"},{"categories":["check.rule","Linux","微服务","设计与实现"],"content":"存储层（Store） 存储层是数据交互的入口，它负责与数据库 / 第三方服务进行 CURD 操作。 由于本接口不会存储用户数据，因此存储层的职责由负责数据的持久化存储 转变为了负责外部数据进行交互，并为上层提供所需的数据。 该层不会涉及任何业务逻辑，而仅专注于数据的存储与转换。 同时，存储层也负责数据的格式转换，例如： 将数据库或第三方服务返回的数据格式转换为业务层和控制层能处理的数据格式； 将业务层和控制层的数据转换为存储系统或外部服务能够识别的格式。 ","date":"2024-09-07","objectID":"/posts/check-rule/:1:3","tags":["check.rule","Linux","微服务","设计与实现"],"title":"微服务架构实战：打造高可用的资格校验服务","uri":"/posts/check-rule/"},{"categories":["check.rule","Linux","微服务","设计与实现"],"content":"层间交互 在整个系统中，各层之间通过接口进行交互，确保功能的独立性和可扩展性。 层与层之间的通信遵循依赖倒置原则，以便实现模块化和插件化的设计目标，同时大大提高了系统的测试性。 Controller 依赖于 Service 层：Controller 通过调用 Service 层接口处理业务逻辑，可利用 golang/mock 模拟 Service 层进行单元测试。 Service 依赖于 Store 层：Service 层通过 Store 层接口与存储系统/第三方服务交互，可通过 golang/mock 模拟操作。 Store 依赖于数据库和外部服务：Store 层与数据库或微服务进行直接交互，可以使用 sqlmock 模拟数据库操作，使用 httpmock 模拟外部 HTTP 请求。 ","date":"2024-09-07","objectID":"/posts/check-rule/:1:4","tags":["check.rule","Linux","微服务","设计与实现"],"title":"微服务架构实战：打造高可用的资格校验服务","uri":"/posts/check-rule/"},{"categories":["check.rule","Linux","微服务","设计与实现"],"content":"资格服务代码设计 在了解了三层架构的基础后，资格服务的代码设计也基于此结构实现。 在具体实现中，我们遵循面向接口编程的原则，以提高代码的扩展性和可测试性。 Controller 在 Controller 层中，我们定义了如下的代码结构： 它持有 services.Servicer 接口，并且实现了 POST/HEAD/GET 等 HTTP 方法， 用于处理 HTTP 请求的响应、请求参数的解析与合法性校验、Service 层业务逻辑的调用执行等操作。 Service 在 Service 层中，我们定义了如下的代码结构： Server 接口定义了该服务所支持的功能，实现了接口就是规范的功能。 与此同时，在 Server 的实现类（例如，DjcRuleService） 中持有 rule.Ruler 接口的引用，用于执行资格校验规则。 Store 在存储层中，我们采用了工厂方法设计模式，以实现不同规则的动态校验。 rule.Ruler 接口定义了核心的 Check 方法，具体的校验规则类（如 DJCFFriendsRule, DJCfmVipRule 等）通过工厂方法创建，并在 service.createRuler 中创建具体规则校验实现类，用以实现具体校验逻辑。 代码结构定义如下： ","date":"2024-09-07","objectID":"/posts/check-rule/:1:5","tags":["check.rule","Linux","微服务","设计与实现"],"title":"微服务架构实战：打造高可用的资格校验服务","uri":"/posts/check-rule/"},{"categories":["check.rule","Linux","微服务","设计与实现"],"content":"微服务部署 ","date":"2024-09-07","objectID":"/posts/check-rule/:2:0","tags":["check.rule","Linux","微服务","设计与实现"],"title":"微服务架构实战：打造高可用的资格校验服务","uri":"/posts/check-rule/"},{"categories":["check.rule","Linux","微服务","设计与实现"],"content":"服务发现 在上游客户端向某个服务发送请求时，它首先会根据所请求的服务名称（例如check.rule）在配置管理中心（例如etcd）查找该服务对应的配置文件： 服务配置文件: /cfg/daoju/.../info/check/rule/check.rule.cfg 环境配置文件: /cfg/daoju/.../info/check/rule/check.rule.1_1.cfg 部署配置文件: /cfg/daoju/.../deployment/djc_rule_test.cfg 需要注意的是，部署配置文件的文件名是由环境部署文件中的 deployment[_number].name 配置项所确定. 服务配置 服务配置文件中通常包含以下关键消息： # /cfg/daoju/.../info/check/rule/check.rule.cfg [api] name=check.rule api=/cgi-bin/daoju/.../rule_check.cgi timeout=5000 proto=http method=post [verify] key=xxxxxxxxxxxxxxxxxxxx ... 其中: api.name 描述了该服务的名称 api.api 描述了该服务的 URL 路径 api.timeout 描述了该服务的请求超时时间 api.proto 描述了该服务采用的协议格式 api.method 描述了该服务具体采用哪种请求方法 verify.key 描述了请求数据进行校验的密钥 环境配置 环境配置文件中通常包含以下关键消息： # /cfg/daoju/.../info/check/rule/check.rule.1_1.cfg [weight] total=100 depcnt=2 weight_0=40 weight_1=60 [maintenance] status=0 [limit] qps=1000 [deployment] name=djc_rule_test [deployment_1] name=djc_check_rule_go_test ... 其中: weight.total 描述了所有部署环境的权重总和，通常是 100 weight.depcnt 描述了该服务部署在本环境下（测试环境或生产环境）的服务数量 weight.weight_\u003cnumber\u003e 描述了第 \u003cnumber\u003e 服务的获取请求数据的占比（weight_\u003cnumber\u003e / weight.total） maintenance.status 描述了当前环境是否已发布 / 正常 limit.qps 描述了该服务所支持的最大 QPS deployment[_number].name 描述了该服务的环境部署名称 部署配置 部署配置文件中通常包含以下关键消息： # /cfg/daoju/.../deployment/djc_rule_test.cfg [djc_check_rule_go_test] modid=xxxxxxx:yyyyyyy mod=xxxx cmd=xxxxx domain= ip_num=1 defaultip_0=\u003cip\u003e defaultport_0=\u003cport\u003e [polaris] namespace=Development service=gdp.aaa.bbb.ccc ... 其中: djc_check_rule_go_test 主要用于指向该部署 polaris.namespace 描述了该部署处于何种环境下，例如 Development / Production / Test polaris.service 描述了该部署所指向的北极星服务地址 一旦通过上面的流程确定了 polaris.service 就可以确定 GDP 中的具体代码，大致流程如下： ","date":"2024-09-07","objectID":"/posts/check-rule/:2:1","tags":["check.rule","Linux","微服务","设计与实现"],"title":"微服务架构实战：打造高可用的资格校验服务","uri":"/posts/check-rule/"},{"categories":["check.rule","Linux","微服务","设计与实现"],"content":"【接口测试】流量回放与镜像 ","date":"2024-09-07","objectID":"/posts/check-rule/:3:0","tags":["check.rule","Linux","微服务","设计与实现"],"title":"微服务架构实战：打造高可用的资格校验服务","uri":"/posts/check-rule/"},{"categories":["check.rule","Linux","微服务","设计与实现"],"content":"流量回放 (Traffic Replay) 流量回放，顾名思义，指的是通过复制线上真实流量（录制），然后在测试环境（或生产环境）进行模拟请求（回放）验证代码逻辑正确性的一种技术方法。 它通过采集线上流量在测试环境（或生产环境）回放逐一对比每个子调用差异和入口调用结果来发现接口代码是否存在问题。 通俗理解，流量回放和使用其他工具（比如 JMeter / postman）构造请求，然后根据返回的响应数据判断测试是否通过的本质相同。 两者的区别在于：流量回放是线上真实流量，而在传统的利用测试工具来发送请求的手段中，人工介入较多。 ","date":"2024-09-07","objectID":"/posts/check-rule/:3:1","tags":["check.rule","Linux","微服务","设计与实现"],"title":"微服务架构实战：打造高可用的资格校验服务","uri":"/posts/check-rule/"},{"categories":["check.rule","Linux","微服务","设计与实现"],"content":"流量镜像 (Traffic Mirror) 流量镜像（Traffic Mirror） ，也称流量影子（Traffic Shadow）, 是一种强大的、无风险的测试应用版本的方法，它将实时流量的副本发送给被镜像的服务。 采用这种方法，可以轻松地测试新版本，而无需在生产环境中部署新版本。 ","date":"2024-09-07","objectID":"/posts/check-rule/:3:2","tags":["check.rule","Linux","微服务","设计与实现"],"title":"微服务架构实战：打造高可用的资格校验服务","uri":"/posts/check-rule/"},{"categories":["check.rule","Linux","微服务","设计与实现"],"content":"验证资格服务的稳定性与准确性 稳定性 由于本次资格服务接口项目属于重构项目，因此在代码重构结束之后，借助了流量回放与镜像技术，验证重构后的代码逻辑是否正确，保证重构后的代码逻辑与重构前的代码逻辑一致。 另外，为了充分验证代码的正确性，我们采用了两种逐层递进的验证方式， 即首先在 CLS 日志系统中抓取线上流量，然后通过流量回放技术手段，在测试环境（或生产环境）进行模拟请求，确保代码逻辑的稳定性，如下图所示； 在进行代码稳定性验证阶段，主要关注以下几个指标： 响应时间 吞吐量 并发用户数 CPU 使用率 内存占用 磁盘 I/O 网络带宽使用情况 出现异常或错误的请求比例 准确性 在充分验证重构代码的稳定性之后，接下来就需要验证代码的准确性。 这里采用了流量镜像的强大验证技术手段，也就是说，在测试环境（或生产环境）中，直接对线上流量进行镜像，并持续监控镜像流量，确保代码逻辑的准确性。 在进行代码准确性性验证阶段，主要关注以下几个指标： 功能正确性： 输入、输出是否符合预期 边界条件 异常情况处理 Online 与 Local 数据是否一致 ","date":"2024-09-07","objectID":"/posts/check-rule/:3:3","tags":["check.rule","Linux","微服务","设计与实现"],"title":"微服务架构实战：打造高可用的资格校验服务","uri":"/posts/check-rule/"},{"categories":["check.rule","Linux","微服务","设计与实现"],"content":"Reference beego sqlmock httpmock 【道聚城】微服务建设实践总结 ","date":"2024-09-07","objectID":"/posts/check-rule/:4:0","tags":["check.rule","Linux","微服务","设计与实现"],"title":"微服务架构实战：打造高可用的资格校验服务","uri":"/posts/check-rule/"},{"categories":["开发工具","编辑器","效率工具","软件教程","最佳实践"],"content":"深入解析 VSCode 与 Vim 的完美结合之道，从插件配置到快捷键定制，从基础操作到高级技巧。通过 VSCodeVim 插件，让你在现代编辑器中享受 Vim 的强大功能，打造最适合自己的编码环境。","date":"2024-08-25","objectID":"/posts/vscode-vim/","tags":["VSCode","Visual Studio Code","Vim","VSCodeVim","编辑器配置","开发工具","效率提升","快捷键设置","全键盘操作","开发环境"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["开发工具","编辑器","效率工具","软件教程","最佳实践"],"content":" 导语 想要在现代编辑器中获得极致的编码体验？VSCode 与 Vim 的强强联合将带给你意想不到的效率提升。本文将详细介绍如何通过 VSCodeVim 插件，在 VSCode 中完美复刻 Vim 的操作方式，让你既能享受 VSCode 强大的功能生态，又能保持 Vim 快速高效的编辑体验。无论你是 Vim 老手还是新手，这份完整指南都能帮你打造一个更高效的编码环境。 ","date":"2024-08-25","objectID":"/posts/vscode-vim/:0:0","tags":["VSCode","Visual Studio Code","Vim","VSCodeVim","编辑器配置","开发工具","效率提升","快捷键设置","全键盘操作","开发环境"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["开发工具","编辑器","效率工具","软件教程","最佳实践"],"content":"I. VSCodeVim VSCodeVim 是一款 vim 模拟器，它将 vim 的大部分功能都集成在了 VSCode 中，即一个嵌入在 VSCode 中的 vim。 正是由于 VSCodeVim 本质上只是一个 Vim 模拟器，而非真正的 Vim，导致原生 Vim 中的有些功能并不支持，具体支持情况见 roadmap。 尽管它现在还无法完全模拟 Vim，但这依然不妨碍它的优秀。 Status Command ✅ Normal Mode ✅ Insert Mode ✅ Visual Mode ✅ Visual Line Mode ✅ Number Prefixes ✅ . Operator ✅ Searching with / and ? ✅ Correct Undo/Redo ⚠ Command Remapping ⚠️ Marks ✅ Text Objects ✅ Visual Block Mode ✅ Replace Mode ✅ Multiple Select Mode ⚠ Macros ⚠ Buffer/Window/Tab ✅ - command done ⚠️ - some variations of the command are not supported ","date":"2024-08-25","objectID":"/posts/vscode-vim/:1:0","tags":["VSCode","Visual Studio Code","Vim","VSCodeVim","编辑器配置","开发工具","效率提升","快捷键设置","全键盘操作","开发环境"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["开发工具","编辑器","效率工具","软件教程","最佳实践"],"content":"II. 安装 只需在 VSCode 的插件商店搜索 vim 就能找到该插件. 关闭 Mac 的重复键 当使用 Mac 时，需要输入以下代码，用以关闭 Mac 的重复键 # For VS Code $ defaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool false # For VS Codium $ defaults write com.vscodium ApplePressAndHoldEnabled -bool false # If necessary, reset global default $ defaults delete -g ApplePressAndHoldEnabled ","date":"2024-08-25","objectID":"/posts/vscode-vim/:2:0","tags":["VSCode","Visual Studio Code","Vim","VSCodeVim","编辑器配置","开发工具","效率提升","快捷键设置","全键盘操作","开发环境"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["开发工具","编辑器","效率工具","软件教程","最佳实践"],"content":"III. 文件配置详解 VSCodeVim 的相关配置文件是放在 settings.json 中，而不是 vimrc 文件. 对于非代码编辑区的热键将其定义在 keybindings.json 中 对于代码编辑区且属于 vim 的热键将其定义在 settings.json 文件中 个人配置参考 个人 vscode 配置文件参考：https://github.com/kydance/dotfiles ","date":"2024-08-25","objectID":"/posts/vscode-vim/:3:0","tags":["VSCode","Visual Studio Code","Vim","VSCodeVim","编辑器配置","开发工具","效率提升","快捷键设置","全键盘操作","开发环境"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["开发工具","编辑器","效率工具","软件教程","最佳实践"],"content":"1. 基础配置 // leader - prefix key \"vim.leader\": \"\u003cspace\u003e\", // To improve performance \"extensions.experimental.affinity\": { \"vscodevim.vim\": 1 }, // Easy motion \"vim.easymotion\": true, // Use system clipboard \"vim.useSystemClipboard\": true, // 由vim接管ctrl+any的按键，而不是vscode \"vim.useCtrlKeys\": true, \"vim.replaceWithRegister\": true, // 忽略大小写 \"vim.ignorecase\": true, \"vim.smartcase\": true, // 智能行号 \"vim.smartRelativeLine\": true, \"vim.foldfix\": true, // Highlight search \"vim.hlsearch\": true, \"vim.highlightedyank.enable\": true, \"vim.highlightedyank.duration\": 500, // 由vscode进行处理，而不是vscode-vim插件 \"vim.handleKeys\": { \"\u003cC-d\u003e\": true, // 向下滚动半页 \"\u003cC-f\u003e\": true, // 向下滚动一页 \"\u003cC-e\u003e\": true, // 向下滚动一行 \"\u003cC-s\u003e\": true, \"\u003cC-z\u003e\": false, \"\u003cC-a\u003e\": true, \"\u003cC-c\u003e\": true, \"\u003cC-v\u003e\": true, \"\u003cC-x\u003e\": true, }, ","date":"2024-08-25","objectID":"/posts/vscode-vim/:3:1","tags":["VSCode","Visual Studio Code","Vim","VSCodeVim","编辑器配置","开发工具","效率提升","快捷键设置","全键盘操作","开发环境"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["开发工具","编辑器","效率工具","软件教程","最佳实践"],"content":"2. 快捷键配置 NORMAL Mode \"vim.normalModeKeyBindingsNonRecursive\": [ { // 聚集 terminal \"before\": [\"\u003cC-j\u003e\"], \"commands\": [\"workbench.action.terminal.focus\"] }, { // 语义级 重命名 \"before\": [\"leader\", \"r\"], \"commands\": [ \"editor.action.rename\"] }, { // \"before\": [\"g\", \"h\"], \"commands\": [ \"editor.action.showHover\"] }, { \"before\": [\"g\", \"d\"], \"commands\": [\"editor.action.revealDefinition\"] }, { \"before\": [\"g\", \"r\"], \"commands\": [\"editor.action.goToReferences\"], }, { \"before\": [\"g\", \"i\"], \"commands\": [\"editor.action.goToImplementation\"], }, { \"before\": [\"g\", \"b\"], \"commands\": [\"workbench.action.navigateBack\"], }, { \"before\": [\"leader\", \"e\", \"f\"], \"commands\": [\"workbench.explorer.fileView.focus\"], }, { \"before\": [ \"leader\", \"leader\", \"e\", \"f\"], \"commands\": [\"workbench.action.toggleActivityBarVisibility\"] }, { \"before\": [\"leader\", \"g\", \"g\"], \"commands\": [\"workbench.action.quickOpen\"], }, { // Global find \"before\": [\"leader\", \"g\", \"f\"], \"commands\": [\"workbench.view.search\"], }, { \"before\": [\"g\", \"[\",], \"commands\": [\"editor.action.marker.prevInFiles\"], }, { \"before\": [\"g\", \"]\",], \"commands\": [\"editor.action.marker.nextInFiles\"], }, { // Source Control Git \"before\": [ \"leader\", \"g\", \"i\", \"t\" ], \"commands\": [\"workbench.scm.focus\"] }, { // Start to debug \"before\": [ \"leader\", \"d\" ], \"commands\": [\"workbench.action.debug.start\"] }, { \"before\": [\"leader\",\"w\"], \"commands\": [\":w!\" ] }, { \"before\": [\"leader\",\"q\"], \"commands\": [\":q\" ] }, { // No highlight \"before\": [\"leader\", \"n\", \"h\"], \"commands\": [\":nohl\"] }, { \"before\": [\"H\"], \"after\": [\"^\"] }, { \"before\": [\"L\"], \"after\": [\"$\"] }, { // Blockwise visual mode \"before\": [\"\\\\\"], \"commands\": [\"extension.vim_ctrl+v\"] }, { \"before\": [\"leader\", \"t\"], \"commands\": [\":terminal\"] }, { \"before\": [\"g\", \"t\"], \"commands\": [\":tabnext\"] }, { \"before\": [\"g\", \"T\"], \"commands\": [\":tabprev\"] }, { // project-manager \"before\": [\"leader\", \"p\", \"m\"], \"commands\": [{ \"command\":\"workbench.view.extension.project-manager\", \"when\":\"viewContainer.workbench.view.extension.project-manager.enabled\" }] }, ], INSERT Mode \"vim.insertModeKeyBindings\": [ { \"before\": [\"j\", \"k\"], \"after\": [\"\u003cEsc\u003e\"] }, ], VISUAL Mode \"vim.visualModeKeyBindings\": [ { \"before\": [\"H\"], \"after\": [\"^\"] }, { \"before\": [\"L\"], \"after\": [\"$\"] }, { \"before\": [\"\u003e\"], \"commands\": [ \"editor.action.indentLines\"] }, { \"before\": [\"\u003c\"], \"commands\": [ \"editor.action.outdentLines\"] }, ], COMMAND LINE Mode \"vim.commandLineModeKeyBindingsNonRecursive\": [ ], leader 键注意事项 leader 键只在代码编辑区域生效，它无法做到全 VSCode 生效 ","date":"2024-08-25","objectID":"/posts/vscode-vim/:3:2","tags":["VSCode","Visual Studio Code","Vim","VSCodeVim","编辑器配置","开发工具","效率提升","快捷键设置","全键盘操作","开发环境"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["开发工具","编辑器","效率工具","软件教程","最佳实践"],"content":"3. 资源管理配置 keybindings.json 定义对于非代码编辑区的热键. [ { \"key\": \"cmd+h\", \"command\": \"workbench.action.focusLeftGroup\" }, { \"key\": \"cmd+l\", \"command\": \"workbench.action.focusRightGroup\" }, { // Rename file \"key\": \"r\", \"command\": \"renameFile\", \"when\": \"explorerViewletVisible \u0026\u0026 filesExplorerFocus \u0026\u0026 !explorerResourceIsRoot \u0026\u0026 !explorerResourceReadonly \u0026\u0026 !inputFocus\" }, { // New file \"key\": \"a\", \"command\": \"explorer.newFile\", \"when\": \"explorerViewletVisible \u0026\u0026 filesExplorerFocus \u0026\u0026 !explorerResourceIsRoot \u0026\u0026 !explorerResourceReadonly \u0026\u0026 !inputFocus\" }, { // New folder \"key\": \"shift+a\", \"command\": \"explorer.newFolder\", \"when\": \"explorerViewletVisible \u0026\u0026 filesExplorerFocus \u0026\u0026 !explorerResourceIsRoot \u0026\u0026 !explorerResourceReadonly \u0026\u0026 !inputFocus\" }, { // Delete file \"key\": \"d\", \"command\": \"deleteFile\", \"when\": \"explorerViewletVisible \u0026\u0026 filesExplorerFocus \u0026\u0026 !explorerResourceIsRoot \u0026\u0026 !explorerResourceReadonly \u0026\u0026 !inputFocus\" }, { // Copy \"key\": \"y\", \"command\": \"filesExplorer.copy\", \"when\": \"explorerViewletVisible \u0026\u0026 filesExplorerFocus \u0026\u0026 !explorerResourceIsRoot \u0026\u0026 !explorerResourceReadonly \u0026\u0026 !inputFocus\" }, { // Cut \"key\": \"x\", \"command\": \"filesExplorer.cut\", \"when\": \"explorerViewletVisible \u0026\u0026 filesExplorerFocus \u0026\u0026 !explorerResourceIsRoot \u0026\u0026 !explorerResourceReadonly \u0026\u0026 !inputFocus\" }, { // Paste \"key\": \"p\", \"command\": \"filesExplorer.paste\", \"when\": \"explorerViewletVisible \u0026\u0026 filesExplorerFocus \u0026\u0026 !explorerResourceIsRoot \u0026\u0026 !explorerResourceReadonly \u0026\u0026 !inputFocus\" }, { // 全局搜索后，在输入框按回车，即可聚焦到搜索结果列表 \"key\": \"enter\", \"command\": \"search.action.focusSearchList\", \"when\": \"inSearchEditor \u0026\u0026 inputBoxFocus \u0026\u0026 hasSearchResult || inputBoxFocus \u0026\u0026 searchViewletVisible \u0026\u0026 hasSearchResult\" }, { // 在搜索结果列表，只需按 esc，就可回到搜索输入框 \"key\": \"escape\", \"command\": \"workbench.action.findInFiles\", \"when\": \"searchViewletVisible \u0026\u0026 hasSearchResult \u0026\u0026 searchViewletFocus\" }, { // 在搜索输入框，只需按 esc，就可回到编辑器 \"key\": \"escape\", \"command\": \"workbench.action.focusFirstEditorGroup\", \"when\": \"inSearchEditor \u0026\u0026 inputBoxFocus|| inputBoxFocus \u0026\u0026 searchViewletVisible\" }, { // 在文件浏览界面，只需按 esc，就可回到编辑器 \"key\": \"escape\", \"command\": \"workbench.action.focusFirstEditorGroup\", \"when\": \"explorerViewletVisible \u0026\u0026 filesExplorerFocus \u0026\u0026 !inputFocus\" }, { \"key\": \"tab\", \"command\": \"acceptSelectedSuggestion\", \"when\": \"suggestWidgetVisible \u0026\u0026 textInputFocus\" }, { // Next Suggestion \"key\": \"tab\", \"command\": \"selectNextSuggestion\", \"when\": \"editorTextFocus \u0026\u0026 suggestWidgetMultipleSuggestions \u0026\u0026 suggestWidgetVisible\" }, { // Prev Suggestion \"key\": \"shift+tab\", \"command\": \"selectPrevSuggestion\", \"when\": \"editorTextFocus \u0026\u0026 suggestWidgetMultipleSuggestions \u0026\u0026 suggestWidgetVisible\" }, { \"key\": \"cmd+k\", \"command\": \"workbench.action.focusActiveEditorGroup\", \"when\": \"terminalFocus\" } ] ","date":"2024-08-25","objectID":"/posts/vscode-vim/:3:3","tags":["VSCode","Visual Studio Code","Vim","VSCodeVim","编辑器配置","开发工具","效率提升","快捷键设置","全键盘操作","开发环境"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["开发工具","编辑器","效率工具","软件教程","最佳实践"],"content":"Gitlens.pro gitlens-pro ","date":"2024-08-25","objectID":"/posts/vscode-vim/:4:0","tags":["VSCode","Visual Studio Code","Vim","VSCodeVim","编辑器配置","开发工具","效率提升","快捷键设置","全键盘操作","开发环境"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["开发工具","编辑器","效率工具","软件教程","最佳实践"],"content":"Monokai Pro License Email: id@chinapyg.com Password: d055c-36b72-151ce-350f4-a8f69 ","date":"2024-08-25","objectID":"/posts/vscode-vim/:5:0","tags":["VSCode","Visual Studio Code","Vim","VSCodeVim","编辑器配置","开发工具","效率提升","快捷键设置","全键盘操作","开发环境"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["开发工具","编辑器","效率工具","软件教程","最佳实践"],"content":"Reference Visual Studio Code VSCodeVim gitlens-pro ","date":"2024-08-25","objectID":"/posts/vscode-vim/:6:0","tags":["VSCode","Visual Studio Code","Vim","VSCodeVim","编辑器配置","开发工具","效率提升","快捷键设置","全键盘操作","开发环境"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["Go语言","编程规范","最佳实践","代码质量","工程实践"],"content":"从命名规范到代码组织，从语法特性到工程实践，全方位讲解如何编写符合 Go 语言哲学的高质量代码。适合想要提升 Go 编程水平的开发者阅读。","date":"2024-08-15","objectID":"/posts/effective-go/","tags":["Go","Golang","编程规范","最佳实践","代码风格","编程技巧","性能优化","设计模式","工程实践","开发指南"],"title":"Go 语言编程之道：编写优雅高效的 Golang 代码","uri":"/posts/effective-go/"},{"categories":["Go语言","编程规范","最佳实践","代码质量","工程实践"],"content":" 导语 想要写出优雅且高效的 Go 代码，仅仅了解语法是远远不够的。本文将带你深入探索 Go 语言的设计哲学和最佳实践，从代码格式化、命名规范到控制结构的巧妙运用，帮助你掌握编写地道 Go 代码的精髓。无论你是 Go 新手还是有经验的开发者，都能从中获得实用的编程技巧和深刻的设计思想。 ","date":"2024-08-15","objectID":"/posts/effective-go/:0:0","tags":["Go","Golang","编程规范","最佳实践","代码风格","编程技巧","性能优化","设计模式","工程实践","开发指南"],"title":"Go 语言编程之道：编写优雅高效的 Golang 代码","uri":"/posts/effective-go/"},{"categories":["Go语言","编程规范","最佳实践","代码质量","工程实践"],"content":"Formatting 格式化 在 Golang 中，gofmt 以包未处理对象而非源文件，它将 Go 程序按照标准风格缩进、对齐，保留注释并在需要时重新格式化。 Indentation 缩进：使用 制表符 Tab 缩进，gofmt 默认使用 Line length 行长度：Go 对行的长度没有限制 Parentheses 括号：控制结构（if, for, switch）在语法上并不需要圆括号 ","date":"2024-08-15","objectID":"/posts/effective-go/:1:0","tags":["Go","Golang","编程规范","最佳实践","代码风格","编程技巧","性能优化","设计模式","工程实践","开发指南"],"title":"Go 语言编程之道：编写优雅高效的 Golang 代码","uri":"/posts/effective-go/"},{"categories":["Go语言","编程规范","最佳实践","代码质量","工程实践"],"content":"Commentary 注释 Go 支持 C 风格的块注释 /* */ 和 C++ 风格的单行注释 //，其中，// 注释更常用，而 /* */ 则主要用于包的注释 godoc 即使一个程序，又是一个 Web 服务器，它对 Go 的源码进行处理，并提取包中的文档内容： 出现在顶级声明之前，且与该声明之间没有空行的注释，将与该声明一起被提出来，作为该条目的说明文档。 每个包都应包含一段包注释，即放置在包子句前的一个块注释。 对于包含多个文件的包，包注释只需出现在其中的任一文件中即可。 包注释应在整体上对该包进行介绍，并提供包的相关信息。 它将出现在 godoc 页面中的最上面，并为紧随其后的内容建立详细的文档。 /* Package regex implements a simple library for regular expressions. The syntax of the regular expressions accepted is: regexp: concatenation { '|' concatenation } concatenation: { closure } closure: term [ '*' | '+' | '?' ] term: '^' '$' '.' character '[' [ '^' ] character-range ']' '(' regexp ')' */ package regex ","date":"2024-08-15","objectID":"/posts/effective-go/:2:0","tags":["Go","Golang","编程规范","最佳实践","代码风格","编程技巧","性能优化","设计模式","工程实践","开发指南"],"title":"Go 语言编程之道：编写优雅高效的 Golang 代码","uri":"/posts/effective-go/"},{"categories":["Go语言","编程规范","最佳实践","代码质量","工程实践"],"content":"Names 命名 ","date":"2024-08-15","objectID":"/posts/effective-go/:3:0","tags":["Go","Golang","编程规范","最佳实践","代码风格","编程技巧","性能优化","设计模式","工程实践","开发指南"],"title":"Go 语言编程之道：编写优雅高效的 Golang 代码","uri":"/posts/effective-go/"},{"categories":["Go语言","编程规范","最佳实践","代码质量","工程实践"],"content":"Package names 包名 当一个包被导入后，包名就会成为内容的访问器 import \"bytes\"，按照惯例，包应当以某个小写的单个单词命名，且不应使用下划线或驼峰记法。 例如，err 的命名就是出于简短考虑。 包名是导入时所需的唯一默认名称，它并不需要在所有源码中保持唯一，即便在少数发生冲突的情况下，也可为导入的包选择一个别名来局部使用。 另一个约定：包名应为其源码目录的基本名称。例如，src/pkg/encoding/base64 中的包应作为 encoding/basee64 导入，其包名应为 base64 而不是 encoding_base64 / encodingBase64. 长命名并不会使包更具有可读性，反而一份有用的说明文档通常比额外的长名更具价值。 ","date":"2024-08-15","objectID":"/posts/effective-go/:3:1","tags":["Go","Golang","编程规范","最佳实践","代码风格","编程技巧","性能优化","设计模式","工程实践","开发指南"],"title":"Go 语言编程之道：编写优雅高效的 Golang 代码","uri":"/posts/effective-go/"},{"categories":["Go语言","编程规范","最佳实践","代码质量","工程实践"],"content":"Getter / Setter Go 并不对 getter 和 setter 提供自动支持。 如将 Get 放入 getter 的名字中，既不符合习惯，也没有必要，但大写字母作为字段导出的 getter 是一个不错的选择，另外 Set 放入 setter 是个不错的选择。 type Object struct { ower string } func (o *Object) Ower() string { return o.ower } func (o *Object) SetOwer(s string) { o.ower = s } ","date":"2024-08-15","objectID":"/posts/effective-go/:3:2","tags":["Go","Golang","编程规范","最佳实践","代码风格","编程技巧","性能优化","设计模式","工程实践","开发指南"],"title":"Go 语言编程之道：编写优雅高效的 Golang 代码","uri":"/posts/effective-go/"},{"categories":["Go语言","编程规范","最佳实践","代码质量","工程实践"],"content":"Interface names 接口名 按照规定，只包含一个方法的接口应当以该方法的名称加上 er 后缀来命名，如 Reader / Writer / Formater 等。 字符串转换方法命名应为 String 而非 ToString ","date":"2024-08-15","objectID":"/posts/effective-go/:3:3","tags":["Go","Golang","编程规范","最佳实践","代码风格","编程技巧","性能优化","设计模式","工程实践","开发指南"],"title":"Go 语言编程之道：编写优雅高效的 Golang 代码","uri":"/posts/effective-go/"},{"categories":["Go语言","编程规范","最佳实践","代码质量","工程实践"],"content":"MixedCaps 驼峰记法 Go 中约定使用驼峰记法 ","date":"2024-08-15","objectID":"/posts/effective-go/:3:4","tags":["Go","Golang","编程规范","最佳实践","代码风格","编程技巧","性能优化","设计模式","工程实践","开发指南"],"title":"Go 语言编程之道：编写优雅高效的 Golang 代码","uri":"/posts/effective-go/"},{"categories":["Go语言","编程规范","最佳实践","代码质量","工程实践"],"content":"分号 和 C 一样，Go 的正式语法使用分号 ; 来结束语句，但 Go 的分号不一定出现在源码中，而是词法分析器会使用一条简单的规则来自动插入分号 规则：如在新行前的最后一个标记为标识符（int/float64等）、数值或字符串常量之类的基本字面或break、continue、fallthrough、return、++、--、)、} 之一，则词法分析器将始终在该标记后面插入分号，即如果新行前的标记为语句的末尾，则插入分号;。 通常，Go 程序只在诸如 for 循环子句这样的地方使用分号，来以此将初始化器、条件及增量元素分开； ","date":"2024-08-15","objectID":"/posts/effective-go/:4:0","tags":["Go","Golang","编程规范","最佳实践","代码风格","编程技巧","性能优化","设计模式","工程实践","开发指南"],"title":"Go 语言编程之道：编写优雅高效的 Golang 代码","uri":"/posts/effective-go/"},{"categories":["Go语言","编程规范","最佳实践","代码质量","工程实践"],"content":"Control structures 控制结构 Go 不再使用 do / while 循环，只有一个更为通用的 for， // C: for for init; condition; post { } // C: while for condition { } // C: for(;;) for { } // [12]aT, []vT, map[sting]any mT for key, value := range aT/vT/mT { } for key := range aT/vT/mT { } for _, value := range aT/vT/mT { } Go 没有逗号操作符，且 ++/-- 是语句而非表达式 for i, j := 0, len(aT) - 1; i \u003c j; i, j = i + 1, j - 1 { // Not: i++, j-- a[i], a[j] = a[j], a[i] } switch 更加灵活，其表达式无需为常量或整数，case 语句会自上而下逐一进行求值直至匹配为止，它不会自动下溯，但 case 可通过逗号分隔来列举相同的处理条件 break 语句会使 switch 提前终止 func unhex(c byte) byte { switch { case '0' \u003c= c \u0026\u0026 c \u003c= '9': return c - '0' case 'a' \u003c= c \u0026\u0026 c \u003c= 'f': return c - 'a' + 10 case 'A' \u003c= c \u0026\u0026 c \u003c= 'F': return c - 'A' + 10 } return 0 } func shouldEscape(c byte) bool { switch c { case ' ', '?', '\u0026', '=', '#', '+', '%': return true } return false } if 强制使用大括号，并且接受初始化语句 if err := file.Chmod(0664); err != nil { return err } ","date":"2024-08-15","objectID":"/posts/effective-go/:5:0","tags":["Go","Golang","编程规范","最佳实践","代码风格","编程技巧","性能优化","设计模式","工程实践","开发指南"],"title":"Go 语言编程之道：编写优雅高效的 Golang 代码","uri":"/posts/effective-go/"},{"categories":["Go语言","编程规范","最佳实践","代码质量","工程实践"],"content":"Function 函数 Go 与众不同的特性之一，就是函数和方法可以返回多个值，返回值或结果“形参”可被命名，并作常规变量使用。 Go 的 defer 语句用于预设一个函数调用（即延迟执行函数），该函数会在执行 defer 的函数返回之前立即执行。 被推迟的多个函数，会按照后进先出（LIFO）的顺序执行。 func Contents(filename string) (string, error) { f, err := os.Open(filename) if err != nil { return \"\", err } defer f.Close() var result []byte buf := make([]byte, 100) for { n, err := f.Read(buf[0:]) result = append(result, buf[0:n]...) if err != nil { if err == io.EOF { break } return \"\", err } } return string(result), nil } ","date":"2024-08-15","objectID":"/posts/effective-go/:6:0","tags":["Go","Golang","编程规范","最佳实践","代码风格","编程技巧","性能优化","设计模式","工程实践","开发指南"],"title":"Go 语言编程之道：编写优雅高效的 Golang 代码","uri":"/posts/effective-go/"},{"categories":["Go语言","编程规范","最佳实践","代码质量","工程实践"],"content":"Data 数据 new(T) 会为类型为 T 的新项分配已置零的内存空间， 并返回它的地址，也就是一个类型为 *T 的值(返回一个指针， 该指针指向新分配的，类型为 T 的零值)。 内建函数 make(T, args) 的目的不同于 new(T)。它只用于创建切片、映射和信道，并返回类型为 T（而非 *T ）的一个已初始化 （而非置零）的值。 出现这种用差异的原因在于，这三种类型本质上为引用数据类型，它们在使用前必须初始化。 // Allocates slice structure; *p == nil; rarely useful var p *[]int = new([]int) // The slice v now refers to a new array of 100 ints var v []int = make([]int, 100) // 惯用法 v := make([]int, 100) ","date":"2024-08-15","objectID":"/posts/effective-go/:7:0","tags":["Go","Golang","编程规范","最佳实践","代码风格","编程技巧","性能优化","设计模式","工程实践","开发指南"],"title":"Go 语言编程之道：编写优雅高效的 Golang 代码","uri":"/posts/effective-go/"},{"categories":["Go语言","编程规范","最佳实践","代码质量","工程实践"],"content":"Array 数组 数组主要用作切片的构件，主要特点： 数组是值，讲一个数组赋值给另一个数组会复制其所有元素 如将数组作为参数传入某个函数，则会收到该数组的一份副本而非指针 数组的大小是其类型的一部分 func Sum(a *[3]float64) (sum float64) { for _, v := range *a { sum += v } return } aV := [...]float64{1, 2, 0.7} fmt.Println(Sum(\u0026aV)) Go array 在 C 语言中，数组变量是指向第一个元素的指针，但 Go 语言中并不是。 Go 语言中，数组变量属于值类型（value type），因此当一个数组变量呗赋值或传递时，实际上会复制整个数组 -\u003e 为了避免复制数组，一般传递指向数组的指针: func f(pa *[3]uint8) { ... } Go array Go 中的数组类型定义了长度和元素类型。 例如，[2]int 类型表示由 2 个 int 整型组成的数组。 数组以索引方式访问（a[i] 访问数组 a 的第 i 个元素）。 数组的长度固定，且是数组类型的一部分 -\u003e 长度不同的 2 个数组不可以相互赋值，因为它们属于不同的类型。 ","date":"2024-08-15","objectID":"/posts/effective-go/:7:1","tags":["Go","Golang","编程规范","最佳实践","代码风格","编程技巧","性能优化","设计模式","工程实践","开发指南"],"title":"Go 语言编程之道：编写优雅高效的 Golang 代码","uri":"/posts/effective-go/"},{"categories":["Go语言","编程规范","最佳实践","代码质量","工程实践"],"content":"Slice 切片 切片通过对数组进行封装，为数据序列提供了更通用、强大而方便的接口，其本质是是在数组 Array 之上的抽象数据类型。 struct { ptr *[]T len int cap int } slice 保存了对底层数组的引用，如将某个 slice 赋值给另一个 slice，则他们会引用同一个数组。 若某个函数将一个切片作为参数传入，则它对该切片元素的修改对调用者而言同样可见， 这可以理解为传递了底层数组的指针 只要切片不超出底层数组的限制，它的长度就是可变的，只需将它赋予其自身的切片即可。 切片的容量可通过内建函数 cap 获得，它将给出该切片可取得的最大长度。 尽管 Append 可修改 slice 的元素，但切片自身（其运行时数据结构包含指针、长度和容量）是通过值传递的. Go slice Go 中 slice 容量指的是当前切片以及预分配的内存能够容纳的元素个数. 若数据超出其容量，则会重新分配该切片，返回值即为所得的切片。 为了减少内存分配、拷贝的次数，在容量较小时，一般是以 2 的倍数进行扩大（2 -\u003e 4 -\u003e 8 -\u003e 16）， 当达到 2048 时，为避免申请的内存过大，从而浪费空间 =\u003e Go 语言 1.20 实现如下： // growslice allocates new backing store for a slice. // // arguments: // // oldPtr = pointer to the slice's backing array // newLen = new length (= oldLen + num) // oldCap = original slice's capacity. // num = number of elements being added // et = element type // // return values: // // newPtr = pointer to the new backing store // newLen = same value as the argument // newCap = capacity of the new backing store // // Requires that uint(newLen) \u003e uint(oldCap). // Assumes the original slice length is newLen - num // // A new backing store is allocated with space for at least newLen elements. // Existing entries [0, oldLen) are copied over to the new backing store. // Added entries [oldLen, newLen) are not initialized by growslice // (although for pointer-containing element types, they are zeroed). They // must be initialized by the caller. // Trailing entries [newLen, newCap) are zeroed. // // growslice's odd calling convention makes the generated code that calls // this function simpler. In particular, it accepts and returns the // new length so that the old length is not live (does not need to be // spilled/restored) and the new length is returned (also does not need // to be spilled/restored). func growslice(oldPtr unsafe.Pointer, newLen, oldCap, num int, et *_type) slice { oldLen := newLen - num // ... newcap := oldCap doublecap := newcap + newcap if newLen \u003e doublecap { newcap = newLen } else { const threshold = 256 if oldCap \u003c threshold { newcap = doublecap } else { // Check 0 \u003c newcap to detect overflow // and prevent an infinite loop. for 0 \u003c newcap \u0026\u0026 newcap \u003c newLen { // Transition from growing 2x for small slices // to growing 1.25x for large slices. This formula // gives a smooth-ish transition between the two. newcap += (newcap + 3*threshold) / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u003c= 0 { newcap = newLen } } } // ... return slice{p, newLen, newcap} } 二维数组 一种是独立地分配每一个切片；而另一种就是只分配一个数组， 将各个切片都指向它 // 独立地分配每一个切片 pic := make([][]uint8, YSize) for i := range pic { // 一次一行 pic[i] = make([]uint8, XSize) } // 顶层 slice pic := make([][]uint8, YSize) // 分配一个大的切片来保存所有像素 pixels := make([]uint8, XSize*YSize) // 遍历行，从剩余像素切片的前面切出每一行 for i := range pic { pic[i], pixels = picxels[:XSize], pixels[XSize:] } 切片操作及性能 Go 语言在 Github 上的官方 wiki - SliceTricks 介绍了切片常见的操作技巧。 另一个项目 Go Slice Tricks Cheat Sheet 将这些操作以图片的形式呈现了出来，非常直观。 slice 有 3 个属性，指针（ptr）、长度（len）和容量（cap），因此当 append 时存在两种场景： append 后的长度小于等于 cap，将会直接使用原底层数组剩余的空间 append 后的长度大于 cap，将会分配一块更大的区域来容纳新的底层数组 为了避免内存发生拷贝，若能够知道最终的切片的大小，预先设置 cap 的值能够获得最好的性能 slice 的底层是数组，所以 delete 意味着后面的元素需要逐个向前移位 =\u003e delete 的复杂度为O(N) =\u003e slice 不适合大量随机删除的场景（链表 list 更适合） 删除后，将空余位置置空，有助于垃圾回收。 insert 和 append 类似，即在某个位置添加一个元素后，将该位置后面的元素再 append 回去，复杂度为 O(N) =\u003e 不适合大量随机插入的场景。 当原切片不会再被使用时，就地 filter 方式是比较推荐的，可以节省内存空间。 在末尾追加元素，不考虑内存拷贝的情况，复杂度为 O(1)。 在头部追加元素，时间和空间复杂度均为 O(N)，不推荐。 尾部删除元素，复杂度 O(1) 头部删除元素，如果使用切片方式，复杂度为 O(1)。 需要注意的是，底层数组没有发生改变，第 0 个位置的内存仍旧没有释放。 如果有大量这样的操作，头部的内存会一直被占用。 ","date":"2024-08-15","objectID":"/posts/effective-go/:7:2","tags":["Go","Golang","编程规范","最佳实践","代码风格","编程技巧","性能优化","设计模式","工程实践","开发指南"],"title":"Go 语言编程之道：编写优雅高效的 Golang 代码","uri":"/posts/effective-go/"},{"categories":["Go语言","编程规范","最佳实践","代码质量","工程实践"],"content":"Map 可以关联不同类型的值。其键可以是任何相等性操作符支持的类型， 如整数、浮点数、复数、字符串、指针、接口（只要其动态类型支持相等性判断）、结构以及数组。 切片不能用作映射键，因为它们的相等性还未定义。与切片一样， 映射也是引用类型。 若将映射传入函数中，并更改了该映射的内容，则此修改对调用者同样可见。 若试图通过映射中不存在的键来取值，就会返回与该映射中项的类型对应的零值 要删除 map 中的某项，可使用内建函数 delete，它以映射及要被删除的键为实参。 即便对应的键不在该 map 中，此操作也是安全的。 ","date":"2024-08-15","objectID":"/posts/effective-go/:7:3","tags":["Go","Golang","编程规范","最佳实践","代码风格","编程技巧","性能优化","设计模式","工程实践","开发指南"],"title":"Go 语言编程之道：编写优雅高效的 Golang 代码","uri":"/posts/effective-go/"},{"categories":["Go语言","编程规范","最佳实践","代码质量","工程实践"],"content":"Reference Effective Go ","date":"2024-08-15","objectID":"/posts/effective-go/:8:0","tags":["Go","Golang","编程规范","最佳实践","代码风格","编程技巧","性能优化","设计模式","工程实践","开发指南"],"title":"Go 语言编程之道：编写优雅高效的 Golang 代码","uri":"/posts/effective-go/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"深入浅出地讲解软件设计模式的核心概念、实现原理和最佳实践。通过 Go 和 C++ 的实际代码示例，帮助你掌握创建型、结构型和行为型等各类设计模式的精髓。","date":"2024-07-28","objectID":"/posts/design-pattern/","tags":["Design Patten","Golang","C++","最佳实践"],"title":"设计模式精讲：从理论到实战的最佳实践指南","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":" 导语 设计模式是每个程序员的必修课，但如何正确理解和灵活运用却是一门艺术。本文将带你深入浅出地探索 Golang 项目中常用的 8 种经典设计模式，通过 Go 和 C++ 的实际代码示例，让你真正理解每种模式的精髓。从面向对象设计原则到具体实现，从模式分类到实战应用，助你构建更优雅、更可维护的代码架构。 ","date":"2024-07-28","objectID":"/posts/design-pattern/:0:0","tags":["Design Patten","Golang","C++","最佳实践"],"title":"设计模式精讲：从理论到实战的最佳实践指南","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"I. 前言 软件设计模式（Design Pattern），是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。 简单来说，设计模式就是在一定环境下，用固定套路解决问题。 设计模式的基础：多态 ","date":"2024-07-28","objectID":"/posts/design-pattern/:1:0","tags":["Design Patten","Golang","C++","最佳实践"],"title":"设计模式精讲：从理论到实战的最佳实践指南","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"面向对象设计原则 \u003e 目的：高内聚、低耦合 如何同时提⾼⼀个软件系统的可维护性和可复⽤性是⾯向对象设计需要解决的核⼼问题之⼀。 ⾯向对象设计原则为⽀持可维护性复⽤⽽诞⽣，这些原则蕴含在很多设计模式中，它们是从许多设计⽅案中总结出的指导性原则。 单一职责原则: 类的职责单⼀，对外只提供⼀种功能，⽽引起类变化的原因都应该只有⼀个 开闭原则: 类的改动是通过增加代码进⾏的，⽽不是修改源代码 里式代换原则: 任何抽象类出现的地⽅都可以⽤他的实现类进⾏替换，实际就是虚拟机制，语⾔级别实现⾯向对象功能 依赖倒转原则: 依赖于抽象(接⼝)，不要依赖具体的实现(类)，也就是针对接⼝编程 接口隔离原则: 不应该强迫⽤户的程序依赖他们不需要的接⼝⽅法。⼀个接⼝应该只提供⼀种对外功能，不应该把所有操作都封装到⼀个接⼝中去 合成复用原则: 如果使⽤继承，会导致⽗类的任何变换都可能影响到⼦类的⾏为。如果使⽤对象组合，就降低了这种依赖关系。对于继承和组合，优先使⽤组合 迪米特法则: ⼀个对象应当对其他对象尽可能少的了解，从⽽降低各个对象之间的耦合，提⾼系统的可维护性 ","date":"2024-07-28","objectID":"/posts/design-pattern/:1:1","tags":["Design Patten","Golang","C++","最佳实践"],"title":"设计模式精讲：从理论到实战的最佳实践指南","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"II. 分类 创建型（Creational）模式：如何创建对象 模式名称 用途 单例模式 🌟🌟🌟🌟 保证一个类仅有一个实例，并提供一个访问它的全局访问点 简单工厂方法 🌟🌟🌟 通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的基类 抽象工厂方法 🌟🌟🌟🌟🌟 提供一个创建一系列相关或相互依赖的接口，而无需指定它们具体的类 原型模式 ⽤原型实例指定创建对象的种类，并且通过拷⻉这些原型创建新的对象 建造者模式 将⼀个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示 结构型（Structural）模式：如何实现类或对象的组合 模式名称 用途 适配器模式 🌟🌟🌟🌟 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 桥接模式 将抽象部分与实际部分分离，使它们可以独立的变化 组合模式 🌟🌟🌟🌟 将对象组合成树形结构以表示 “部分 - 整体” 的层次结构，使得用户对单个对象和组合对象的使用具有一致性 装饰模式 🌟🌟🌟 动态地给一个对象添加一些额外的职责：就增加功能来说，此模式比生成子类更加灵活 外观模式 🌟🌟🌟🌟🌟 为子系统的一组接口提供一个一致的界面，此模式定义了一个高层次接口，使得这一子系统更容易使用 享元模式 以共享的方式高效的支持大量的细粒度的对象 代理模式 为其他对象提供一种代理以控制这个对象的访问 行为型（Behavioral）模式：类或对象如何交互以及如何分配指责 ","date":"2024-07-28","objectID":"/posts/design-pattern/:2:0","tags":["Design Patten","Golang","C++","最佳实践"],"title":"设计模式精讲：从理论到实战的最佳实践指南","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"III. 创建型设计模式 ","date":"2024-07-28","objectID":"/posts/design-pattern/:3:0","tags":["Design Patten","Golang","C++","最佳实践"],"title":"设计模式精讲：从理论到实战的最佳实践指南","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"1. 单例模式（Singleton Pattern） 意图：它是一种创建型设计模式，限制了实例化类的对象个数，确保一个类只有一个实例，并且提供一个全局访问点。 warning Singleton Pattern 同时解决了两个问题，因此违法了单一职责原则: 保证一个类只用一个实例。 为该实例提供一个全局访问节点。 应用场景 配置管理器：在应用程序中，配置信息通常需要一个实例来管理，如此可以保证配置信息的一致性 连接池：数据库连接池需要限制数据库连接的数量，以避免过多的连接消耗资源 日志记录器：日志系统通常只需要一个实例来记录应用程序的日志信息，以避免日志信息的冗余和混乱 硬件管理器：对于某些硬件设备，如打印机 / 扫描仪等，可能只需要一个管理器来控制对它们的访问 应用状态管理：在某些应用中，需要全局的管理状态，如用户会话管理或权限验证状态 解决方案 将默认构造函数设为私有，防止其他对象使用单例类的 new 运算符 新建一个静态构建方法作为构造函数：该函数会“偷偷”调用私有构造函数来创建对象，并将其保存到一个静态成员变量中，之后所有对于该函数的调用都将返回这一缓存对象。 单例模式结构 与其他模式的关系 外观模式类通常可以转化为单例模式类，因为在大部分情况下一个外观对象就足够啦 如果能将对象的所有共享状态简化为一个享元对象，那么享元模式就和单例类似，但二者有两个根本性的不同： 单例只有一个单例实体，但享元类可以有多个实体，各实体的内在状态也可以不同 单例对象可以是可变的，享元对象不可变 抽象工厂模式、生成器模式和原型模式都可以用单例来实现 应用示例 ```Go // Singleton.go package singleton import \"sync\" var instance *Singleton var once sync.Once type Singleton struct { str string } func GetInstance() *Singleton { if instance != nil { return instance } once.Do(func() { instance = \u0026Singleton{} }) return instance } ``` ","date":"2024-07-28","objectID":"/posts/design-pattern/:3:1","tags":["Design Patten","Golang","C++","最佳实践"],"title":"设计模式精讲：从理论到实战的最佳实践指南","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"2. 工厂模式（Factory Pattern） 亦称：虚拟构造函数、Virtual Constructor、Factory Method 意图：它是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型 由于 Golang 中缺少类和继承等 OOP 特性，因此，无法使用 Go 来实现经典的工厂方法模式，但我们仍能实现基础版本，即简单工厂。 ```Go // iGun.go package factory type Gun interface { setName(name string) setPower(power int) name() string power() int } // gun.go type gun struct { name string power int } func (g *gun) setName(name string) { g.name = name } func (g *gun) setPower(power int) { g.power = power } func (g *gun) name() string { return g.name } func (g *gun) power() int { return g.power } // ak47.go type ak47 struct { gun } func newAk47() Gun { return \u0026ak47{ gun: gun{ name: \"AK47\", power: 10, } } } // m16.go type m16 struct { gun } func m16() Gun { return \u0026gun{ name: \"M16\", power: 17, } } // Factory.go func GunFactory(gunType string) (Gun, error) { switch gunType { case \"ak47\": return newAk47(), nil case \"m16\": return newM16(), nil default: return nil, errors.New(\"wrong gun type\") } } ``` ","date":"2024-07-28","objectID":"/posts/design-pattern/:3:2","tags":["Design Patten","Golang","C++","最佳实践"],"title":"设计模式精讲：从理论到实战的最佳实践指南","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"IV. 行为设计模式 ","date":"2024-07-28","objectID":"/posts/design-pattern/:4:0","tags":["Design Patten","Golang","C++","最佳实践"],"title":"设计模式精讲：从理论到实战的最佳实践指南","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"1. 策略模式（Strategy Pattern） 策略模式是一种行为设计模式，它能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。 在项目开发中，我们经常要根据不同的场景，采取不同的措施，也就是不同的策略。通过 if ... else ... 的形式来调用不同的策略，这种方式称之为硬编码。 内存缓存示例 假设构建内存缓存的场景，由于数据存于内存中，其大小会受到限制。 在达到其大小上限后，一些数据就必须被移除以留出空间，而此类操作可通过多种算法实现，例如： 最少最近使用（LRU）算法：移除最近最少使用的数据 最近最少使用（LFU）算法：移除使用频率最少使用的数据 先进先出（FIFO）算法：移除最先进入的数据 问题在于如何将缓存类与这些算法解耦，以便在运行时更改算法。 另外，在添加新算法时，缓存类不应该改变。 这就是策略模式发挥作用的场景：创建一系列算法，每个算法都有自己的类，这些类中的每一个都遵循相同的接口，这使得这些算法可以相互替换。 // cache.go type Cache struct { storage map[string]any rmAlgo RmAlgo capacity int maxCapacity int } func initCache(algo RmAlgo) *Cache { return \u0026Cache{ storage: make(map[string]any), rmAlgo: algo, capacity: 0, maxCapacity: 100, } } func (c *Cache) rm() { c.rmAlgo.Rm(c) c.capacity-- } func (c *Cache) setRmAlgo(algo RmAlgo) { c.rmAlgo = algo } func (c *Cache) get(key string) any { return c.storage[key] } func (c *Cache) add(key string, value any) { if c.capacity \u003e= c.maxCapacity { c.rm() } c.storage[key] = value c.capacity++ } // iCache.go 策略接口 type RmAlgo interface { Rm(c *Cache) } // fifo.go type Fifo struct{} func (f *Fifo) Rm(c *Cache) { fmt.Println(\"rm by fifo strategy\") } // lru.go type Lru struct{} func (l *Lru) Rm(c *Cache) { fmt.Println(\"rm by lru strategy\") } // lfu.go type Lfu struct{} func (l *Lfu) Rm(c *Cache) { fmt.Println(\"rm by lfu strategy\") } ","date":"2024-07-28","objectID":"/posts/design-pattern/:4:1","tags":["Design Patten","Golang","C++","最佳实践"],"title":"设计模式精讲：从理论到实战的最佳实践指南","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"2. 模板方法模式（Template Method Pattern） 模板方法模式是一种行为设计模式，它定义了一个操作中的算法的骨架，允许子类在不修改结构的情况下重写算法的特定步骤。 OTP 示例 假设在处理一个一次性密码（OTP）的场景，将 OTP 传递给用户的方式多种多样（短信、邮件等），但无论是短信还是邮件，整个 OTP 处理过程都是相同的： 生成一个随机的 n 位 OTP 数字 在缓存中保存这组数字以便进行后续验证 准备内容 发送通知 后续引入的任何新 OTP 类型都很有可能需要进行相同的步骤。 首先，定一个由固定数量的方法组成的基础模板算法，然后将实现每一个步骤方法，但不改变模版方法。 // iOtp.go type IOtp interface { GenerateRandomOtp(length int) string CacheOtp(otp string) PrepareContent() string SendNotification(message string) error } type Otp struct { iOtp IOtp } func (o *Otp) GenAndSendOtp(length int) error { opt := o.iOtp.GenerateRandomOtp(length) o.iOtp.CacheOtp(opt) content := o.iOtp.PrepareContent() return o.iOtp.SendNotification(content) } // sms.go type Sms struct { Otp } func (s *Sms) GenerateRandomOtp(length int) string { opt := \"\" for i := range length { opt += strconv.Itoa(rand.Intn(10)) } fmt.Println(\"SMS: Generate otp %s\", opt) return opt } func (s *Sms) CacheOtp(otp string) { fmt.Println(\"SMS: Cache otp %s\", otp) } func (s *Sms) PrepareContent() string { return fmt.Sprintf(\"Your OTP is %s\", otp) } func (s *Sms) SendNotification(message string) error { fmt.Println(\"SMS: Send message %s\", message) return nil } // email.go type Email struct { Otp } func (e *Email) GenerateRandomOtp(length int) string { opt := \"\" for i := range length { opt += strconv.Itoa(rand.Intn(10)) } fmt.Println(\"Email: Generate otp %s\", opt) return opt } func (e *Email) CacheOtp(otp string) { fmt.Println(\"Email: Cache otp %s\", otp) } func (e *Email) PrepareContent() string { return fmt.Sprintf(\"Your OTP is %s\", otp) } func (e *Email) SendNotification(message string) error { fmt.Println(\"Email: Send message %s\", message) return nil } ","date":"2024-07-28","objectID":"/posts/design-pattern/:4:2","tags":["Design Patten","Golang","C++","最佳实践"],"title":"设计模式精讲：从理论到实战的最佳实践指南","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"V. 结构型设计模式 ","date":"2024-07-28","objectID":"/posts/design-pattern/:5:0","tags":["Design Patten","Golang","C++","最佳实践"],"title":"设计模式精讲：从理论到实战的最佳实践指南","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"1. 代理模式（Proxy Pattern） 代理模式是一种结构设计模式，让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理(访问控制、缓存等)。 代理模式建议新建一个与原服务对象接口相同的代理类，然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象，并将所有工作委派给它。 Nginx 代理示例 Nginx 这样的 web 服务器可充当应用程序服务器的代理： 提供了的应用程序服务器的受控访问权限 可限制速度 可缓存请求 // server.go type Server interface { HandleRequest(string, string) (int, string) } // nginx.go type Nginx struct { application *Application maxAllowedRequest int rateLimiter map[string]int } func NewNginx() *Nginx { return \u0026Nginx{ application: \u0026Application{}, maxAllowedRequest: 10, rateLimiter: make(map[string]int), } } func (n *Nginx) HandleRequest(url string, method string) (int, string) { allowed := n.checkRateLimit(url) if !allowed { return 403, \"Forbidden\" } return n.application.HandleRequest(url, method) } func (n *Nginx) checkRateLimit(url string) bool { if n.rateLimiter[url] == 0 { n.rateLimiter[url] = 1 } if n.rateLimiter[url] \u003e n.maxAllowedRequest { return false } n.rateLimiter[url]++ return true } // application.go type Application struct {} func (a *Application) HandleRequest(url string, method string) (int, string) { if url == \"/app/status\" \u0026\u0026 method == \"GET\" { return 200, \"OK\" } if url == \"/create/user\" \u0026\u0026 method == \"POST\" { return 201, \"User Created\" } return 404, \"Not Found\" } 2. 选项模式 选项模式是一种结构设计模式，可以创建一个带有默认值的 struct 变量，并选择性地修改其中一些参数的值。 在 Python 中，创建一个对象时，可以给参数设置默认值，这样在不传入任何参数时， 可以返回携带默认值的对象，并在需要时修改对象的属性。 这种特性可以大大简化开发者创建一个对象的成本，尤其是在对象拥有众多属性时。 然而，在 Go 生态中，因为不支持给参数设置默认值，为了既能够创建带默认值的实例，又能够自定义参数的实例，开发者一般会通过以下两种方法实现： 分别开发两个用来创建实例的函数，一个带有默认值，一个不带默认值：此时需要实现两个函数，实现方式很不优雅； package options const ( defaultTimeout = 10 defaultCaching = false ) type Connection struct { addr string cache int timeout time.Duration } func NewConnection(addr string) (*Connection, error) { return \u0026Connection{ addr: addr, cache: defaultCaching, timeout: defaultTimeout, }, nil } func NewConnectionWithOptions(addr string, cache bool, timeout time.Duration) (*Connection, error) { return \u0026Connection{ addr: addr, cache: cache, timeout: timeout, }, nil } 创建一个带有默认值的选项，并用该选项创建实例: 每次创建实例时，都需要创建 Options，操作起来比较麻烦； package options const ( defaultTimeout = 10 defaultCaching = false ) type Connection struct { addr string cache int timeout time.Duration } type ConnectionOption struct { Cache bool Timeout time.Duration } func NewDefaultConnectionOption() *ConnectionOption { return \u0026ConnectionOption{ Cache: defaultCaching, Timeout: defaultTimeout, } } func NewConnection(addr string, opts *ConnectionOption) (*Connection, error) { return \u0026Connection{ addr: addr, cache: opt.Cache, timeout: opt.Timeout, }, nil } 解决方案 package options import \"time\" type Connection struct { addr string cache int timeout time.Duration } const ( defaultTimeout = 10 defaultCaching = false ) type options struct { timeout time.Duration cache bool } // Option overrides behavior of Connection type Option interface { apply(*options) } type optionFunc func(*options) func (f optionFunc) apply(o *options) { f(o) } func WithTimeout(t time.Duration) Option { return optionFunc(func(o *options) { o.timeout = t }) } func WithCaching(c bool) Option { return optionFunc(func(o *options) { o.cache = c }) } func NewConnection(addr string, opts ...Option) (*Connection, error) { o := \u0026options{ timeout: defaultTimeout, cache: defaultCaching, } for _, opt := range opts { opt.apply(o) } return \u0026Connection{ addr: addr, cache: o.cache, timeout: o.timeout, }, nil } Option 类型的选项参数需要实现 apply(*options) 函数，结合 WithTimeout、WithCache 函数的返回值和 optionFunc 的 apply 方法实现，可以知道 o.apply(\u0026options) 其实就是把 WithTimeout、WithCache 的返回值赋值给 options 结构体变量，以此动态地设置 options 结构体变量的字段值。 同时，我们还可以在 apply 函数中自定义赋值逻辑，例如 o.timeout = 10 * t，使得设置结构体属性的灵活性更大。 Options 模式的优点： 支持传递多个参数，并在参数发生变化时保持兼容性 支持任意顺行传递参数 支持默认值 方便扩展 通过 WithXXX 的函数命名，可以使参数意义更加明确 Tip 当结构体参数较少时，需要慎重考虑是否需要采用 Options 模式 ","date":"2024-07-28","objectID":"/posts/design-pattern/:5:1","tags":["Design Patten","Golang","C++","最佳实践"],"title":"设计模式精讲：从理论到实战的最佳实践指南","uri":"/posts/design-pattern/"},{"categories":["Go语言","项目管理","架构设计","工程实践","最佳实践"],"content":"详细介绍 Go 项目的标准目录结构，从 cmd、internal、pkg 到配置文件管理。通过实例讲解每个目录的最佳用法，帮助你构建结构清晰、易于维护的 Go 项目。针对不同类型的应用（微服务、CLI工具、库）提供完整的目录组织方案。","date":"2024-07-13","objectID":"/posts/golang-project-layout/","tags":["Go","Golang","项目结构","项目布局","代码组织","最佳实践","架构设计","工程实践","项目规范","代码管理"],"title":"Go 工程目录最佳实践：打造清晰、可维护的项目结构","uri":"/posts/golang-project-layout/"},{"categories":["Go语言","项目管理","架构设计","工程实践","最佳实践"],"content":" 导语 项目结构是代码质量的第一道防线。一个优秀的目录结构不仅能提高代码的可维护性，更能体现工程师的专业素养。本文将为你详细解读 Go 项目的标准目录结构，从微服务到单体应用，从命令行工具到共享库，帮助你掌握 Go 项目组织的最佳实践。无论是经验丰富的 Go 开发者，还是刚接触 Go 的新手，都能从这套久经考验的项目结构方案中获益。 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:0:0","tags":["Go","Golang","项目结构","项目布局","代码组织","最佳实践","架构设计","工程实践","项目规范","代码管理"],"title":"Go 工程目录最佳实践：打造清晰、可维护的项目结构","uri":"/posts/golang-project-layout/"},{"categories":["Go语言","项目管理","架构设计","工程实践","最佳实践"],"content":"Go Module 从 Go 1.14 版本开始，除非存在特定不使用 Go Modules 的理由，否则请使用，并且一旦使用，就无需再担心 $GOPATH 以及项目的存放位置。 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:1:0","tags":["Go","Golang","项目结构","项目布局","代码组织","最佳实践","架构设计","工程实践","项目规范","代码管理"],"title":"Go 工程目录最佳实践：打造清晰、可维护的项目结构","uri":"/posts/golang-project-layout/"},{"categories":["Go语言","项目管理","架构设计","工程实践","最佳实践"],"content":"Go 目录 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:0","tags":["Go","Golang","项目结构","项目布局","代码组织","最佳实践","架构设计","工程实践","项目规范","代码管理"],"title":"Go 工程目录最佳实践：打造清晰、可维护的项目结构","uri":"/posts/golang-project-layout/"},{"categories":["Go语言","项目管理","架构设计","工程实践","最佳实践"],"content":"/cmd /cmd，本项目的主干，其中每一个应用程序的目录名应该与你想要的可执行程序的名称相对应，例如 /cmd/myApp。 在 /cmd 目录下，不应该放置太多代码： 如果认为代码可以导入并可在其他项目中使用，那么它应该位于 /pkg 目录中. 如果代码不是可重用的，或者不希望其他人重用它，那么应该位于 /internal 目录中. 该目录下，通常有一个小的 main 函数，从 /internal 和 pkg 目录中导入和调用代码，除此之外没有别的东西. 微服务中的 app 服务类型分为4类：interface、service、job、admin |---cmd | |---kydenapp-admin | |---kydenapp-interface | |---kydenapp-job | |---kydenapp-service | |---kydenapp-task interface: 对外的 BFF 服务，接受来自用户的请求，比如暴露了 HTTP/gRPC 接口 service: 对内的微服务，仅接受来自内部其他服务或网关的请求，比如暴露了 gRPC 接口只对内服务 admin: 区别于 service，更多是面向运营测的服务，通常数据权限更高，隔离带来更好的代码级别安全 job: 流式任务处理的服务，上游一般依赖 message broker task: 定时任务，类似 cronjob，部署到 task 托管平台中 /cmd 应用目录负责程序的: 启动、关闭、配置初始化等 DTO(Data Transfer Object)，数据传输对象，这个概念来源于 J2EE 的设计模式， 但这里泛指用于展示层/API层与服务层（业务逻辑层）之间的数据传输对象。 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:1","tags":["Go","Golang","项目结构","项目布局","代码组织","最佳实践","架构设计","工程实践","项目规范","代码管理"],"title":"Go 工程目录最佳实践：打造清晰、可维护的项目结构","uri":"/posts/golang-project-layout/"},{"categories":["Go语言","项目管理","架构设计","工程实践","最佳实践"],"content":"internal internal，私有应用程序和库代码，它是不希望其他人在其应用程序或库中导入的代码. 该目录由 Go 强制执行，确保私有包不可导入。 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:2","tags":["Go","Golang","项目结构","项目布局","代码组织","最佳实践","架构设计","工程实践","项目规范","代码管理"],"title":"Go 工程目录最佳实践：打造清晰、可维护的项目结构","uri":"/posts/golang-project-layout/"},{"categories":["Go语言","项目管理","架构设计","工程实践","最佳实践"],"content":"pkg /pkg，外部应用程序可以使用的库代码（例如 /pkg/mypubliclib）. 如果应用程序项目真的很小，并且额外的嵌套并不能增加多少价值(除非你真的想要:-)，那就不要使用它。 当它变得足够大时，根目录会变得非常繁琐时(尤其是当你有很多非 Go 应用组件时)，请考虑使用。 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:3","tags":["Go","Golang","项目结构","项目布局","代码组织","最佳实践","架构设计","工程实践","项目规范","代码管理"],"title":"Go 工程目录最佳实践：打造清晰、可维护的项目结构","uri":"/posts/golang-project-layout/"},{"categories":["Go语言","项目管理","架构设计","工程实践","最佳实践"],"content":"api /api，协议定义目录，(xxapi.proto) protobuf 文件，以及生成的 go 文件. 通常把 api 文档直接在 proto 文件中描述。 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:4","tags":["Go","Golang","项目结构","项目布局","代码组织","最佳实践","架构设计","工程实践","项目规范","代码管理"],"title":"Go 工程目录最佳实践：打造清晰、可维护的项目结构","uri":"/posts/golang-project-layout/"},{"categories":["Go语言","项目管理","架构设计","工程实践","最佳实践"],"content":"configs 配置文件模版或默认配置 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:5","tags":["Go","Golang","项目结构","项目布局","代码组织","最佳实践","架构设计","工程实践","项目规范","代码管理"],"title":"Go 工程目录最佳实践：打造清晰、可维护的项目结构","uri":"/posts/golang-project-layout/"},{"categories":["Go语言","项目管理","架构设计","工程实践","最佳实践"],"content":"scripts 执行各种构建、安装、分析等操作的脚本，是的根级别的 Makefile 变得小而简单 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:6","tags":["Go","Golang","项目结构","项目布局","代码组织","最佳实践","架构设计","工程实践","项目规范","代码管理"],"title":"Go 工程目录最佳实践：打造清晰、可维护的项目结构","uri":"/posts/golang-project-layout/"},{"categories":["Go语言","项目管理","架构设计","工程实践","最佳实践"],"content":"test 额外的外部测试应用程序和测试数据 Go 会忽略以 . 或 _ 开头的目录和文件 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:7","tags":["Go","Golang","项目结构","项目布局","代码组织","最佳实践","架构设计","工程实践","项目规范","代码管理"],"title":"Go 工程目录最佳实践：打造清晰、可维护的项目结构","uri":"/posts/golang-project-layout/"},{"categories":["Go语言","项目管理","架构设计","工程实践","最佳实践"],"content":"docs 设计和用户文档（godoc 生成的文档除外） ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:8","tags":["Go","Golang","项目结构","项目布局","代码组织","最佳实践","架构设计","工程实践","项目规范","代码管理"],"title":"Go 工程目录最佳实践：打造清晰、可维护的项目结构","uri":"/posts/golang-project-layout/"},{"categories":["Go语言","项目管理","架构设计","工程实践","最佳实践"],"content":"tools 项目的支持工具，可以从 /pkg 和 /internal 目录导入代码 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:9","tags":["Go","Golang","项目结构","项目布局","代码组织","最佳实践","架构设计","工程实践","项目规范","代码管理"],"title":"Go 工程目录最佳实践：打造清晰、可维护的项目结构","uri":"/posts/golang-project-layout/"},{"categories":["Go语言","项目管理","架构设计","工程实践","最佳实践"],"content":"examples 应用程序和/或公共库的示例 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:10","tags":["Go","Golang","项目结构","项目布局","代码组织","最佳实践","架构设计","工程实践","项目规范","代码管理"],"title":"Go 工程目录最佳实践：打造清晰、可维护的项目结构","uri":"/posts/golang-project-layout/"},{"categories":["Go语言","项目管理","架构设计","工程实践","最佳实践"],"content":"third_party 外部辅助工具，分叉代码和其他第三方工具（例如 Swagger UI） ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:11","tags":["Go","Golang","项目结构","项目布局","代码组织","最佳实践","架构设计","工程实践","项目规范","代码管理"],"title":"Go 工程目录最佳实践：打造清晰、可维护的项目结构","uri":"/posts/golang-project-layout/"},{"categories":["Go语言","项目管理","架构设计","工程实践","最佳实践"],"content":"assets 与存储库一起使用的其他资源（图像、徽标等） 按理来说我们不应该 src 目录，但有些 Go 项目拥有一个 src 文件夹，这通常发生在开发人员具有 Java 背景 $GOPATH 环境变量指向你的(当前)工作空间(默认情况下，它指向非 windows 系统上的 $HOME/go)，这个工作空间包括顶层 /pkg, /bin 和 /src 目录，而实际项目最终是 /src 下的一个子目录，即 /xxx/workspace/src/proj/src/xxx.go（Go 1.11 之后，项目 proj 可以放在 GOPATH 之外）. ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:12","tags":["Go","Golang","项目结构","项目布局","代码组织","最佳实践","架构设计","工程实践","项目规范","代码管理"],"title":"Go 工程目录最佳实践：打造清晰、可维护的项目结构","uri":"/posts/golang-project-layout/"},{"categories":["Go语言","项目管理","架构设计","工程实践","最佳实践"],"content":"Reference https://talks.golang.org/2014/names.slide https://golang.org/doc/effective_go.html#names https://blog.golang.org/package-names https://go.dev/wiki/CodeReviewComments Style guideline for Go packages (rakyll/JBD) ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:3:0","tags":["Go","Golang","项目结构","项目布局","代码组织","最佳实践","架构设计","工程实践","项目规范","代码管理"],"title":"Go 工程目录最佳实践：打造清晰、可维护的项目结构","uri":"/posts/golang-project-layout/"},{"categories":["Go语言","并发编程","微服务","服务端开发","最佳实践"],"content":"深入探讨 Go Context 的核心概念和最佳实践，从基础用法到高级特性，帮助你理解如何使用 Context 实现请求追踪、超时控制、数据传递和优雅退出。通过实例讲解 Context 在实际项目中的应用场景和性能优化技巧。","date":"2024-06-01","objectID":"/posts/golang-context/","tags":["Go","Golang","Context","并发编程","微服务","服务治理","错误处理","最佳实践","并发控制","性能优化"],"title":"深入理解 Go Context：优雅的并发控制与请求管理","uri":"/posts/golang-context/"},{"categories":["Go语言","并发编程","微服务","服务端开发","最佳实践"],"content":" 导语 在现代 Go 应用中，Context 是实现并发控制和请求管理的核心机制。它不仅能够优雅地传递请求上下文，还能有效管理 goroutine 的生命周期，实现超时控制和优雅退出。本文将带你深入理解 Context 的设计理念和最佳实践，通过实例讲解如何在实际项目中运用 Context 来构建可靠、高效的并发应用。从链路追踪到资源管理，一文掌握 Context 的精髓。 ","date":"2024-06-01","objectID":"/posts/golang-context/:0:0","tags":["Go","Golang","Context","并发编程","微服务","服务治理","错误处理","最佳实践","并发控制","性能优化"],"title":"深入理解 Go Context：优雅的并发控制与请求管理","uri":"/posts/golang-context/"},{"categories":["Go语言","并发编程","微服务","服务端开发","最佳实践"],"content":"Context Context 除了用来传递上下文信息，还可以用来传递终结执行子任务的相关信号，终止多个执行子任务的 Goroutine。 context.Context 接口数据结构： // A Context carries a deadline, a cancellation signal, and other values across // API boundaries. // // Context's methods may be called by multiple goroutines simultaneously. type Context interface { // Deadline returns the time when work done on behalf of this context // should be canceled. Deadline returns ok==false when no deadline is // set. Successive calls to Deadline return the same results. Deadline() (deadline time.Time, ok bool) // Done returns a channel that's closed when work done on behalf of this // context should be canceled. Done may return nil if this context can // never be canceled. Successive calls to Done return the same value. // The close of the Done channel may happen asynchronously, // after the cancel function returns. // // WithCancel arranges for Done to be closed when cancel is called; // WithDeadline arranges for Done to be closed when the deadline // expires; WithTimeout arranges for Done to be closed when the timeout // elapses. // // Done is provided for use in select statements: // // // Stream generates values with DoSomething and sends them to out // // until DoSomething returns an error or ctx.Done is closed. // func Stream(ctx context.Context, out chan\u003c- Value) error { // for { // v, err := DoSomething(ctx) // if err != nil { // return err // } // select { // case \u003c-ctx.Done(): // return ctx.Err() // case out \u003c- v: // } // } // } // // See https://blog.golang.org/pipelines for more examples of how to use // a Done channel for cancellation. Done() \u003c-chan struct{} // If Done is not yet closed, Err returns nil. // If Done is closed, Err returns a non-nil error explaining why: // Canceled if the context was canceled // or DeadlineExceeded if the context's deadline passed. // After Err returns a non-nil error, successive calls to Err return the same error. Err() error // Value returns the value associated with this context for key, or nil // if no value is associated with key. Successive calls to Value with // the same key returns the same result. // // Use context values only for request-scoped data that transits // processes and API boundaries, not for passing optional parameters to // functions. // // A key identifies a specific value in a Context. Functions that wish // to store values in Context typically allocate a key in a global // variable then use that key as the argument to context.WithValue and // Context.Value. A key can be any type that supports equality; // packages should define keys as an unexported type to avoid // collisions. // // Packages that define a Context key should provide type-safe accessors // for the values stored using that key: // // // Package user defines a User type that's stored in Contexts. // package user // // import \"context\" // // // User is the type of value stored in the Contexts. // type User struct {...} // // // key is an unexported type for keys defined in this package. // // This prevents collisions with keys defined in other packages. // type key int // // // userKey is the key for user.User values in Contexts. It is // // unexported; clients use user.NewContext and user.FromContext // // instead of using this key directly. // var userKey key // // // NewContext returns a new Context that carries value u. // func NewContext(ctx context.Context, u *User) context.Context { // return context.WithValue(ctx, userKey, u) // } // // // FromContext returns the User value stored in ctx, if any. // func FromContext(ctx context.Context) (*User, bool) { // u, ok := ctx.Value(userKey).(*User) // return u, ok // } Value(key any) any } Deadline：返回 Context 被取消的时间，也就是完成工作的截至日期； Done：返回一个 channel，这个 channel 会在当前工作完成或者上下文被取消之后关闭，多次调用 Done 方法会返回同一个 channel； Err：放回 Context 结束的原因，只会在 Done 返回的 channel 被关闭时才会返回非空的值，如果 Context 被取消，会返回 Canceled 错误；如果 Context 超时，会返回 DeadlineExceeded 错误； Value：可用于从 Context 中获取传递的键值信息； ","date":"2024-06-01","objectID":"/posts/golang-context/:1:0","tags":["Go","Golang","Context","并发编程","微服务","服务治理","错误处理","最佳实践","并发控制","性能优化"],"title":"深入理解 Go Context：优雅的并发控制与请求管理","uri":"/posts/golang-context/"},{"categories":["Go语言","并发编程","微服务","服务端开发","最佳实践"],"content":"Example 在 Web 请求的处理过程中，一个请求可能启动多个 goroutine 协同工作，这些 goroutine 之间可能需要共享请求的信息，且当请求被取消或者执行超时时，该请求对应的所有 goroutine 都需要快速结束，释放资源，Context 就是为了解决上述场景而开发的。 package main import ( \"context\" \"fmt\" \"time\" ) const DB_ADDRESS = \"db_address\" const CALCULATE_VALUE = \"calculate_value\" func readDB(ctx context.Context, cost time.Duration) { fmt.Println(\"DB address is \", ctx.Value(DB_ADDRESS)) select { case \u003c-time.After(cost): fmt.Println(\"read data from db\") case \u003c-ctx.Done(): fmt.Println(ctx.Err()) } } func calculate(ctx context.Context, cost time.Duration) { fmt.Println(\"calculate value is\", ctx.Value(CALCULATE_VALUE)) select { case \u003c-time.After(cost): // 模拟数据计算 fmt.Println(\"calculate finish\") case \u003c-ctx.Done(): fmt.Println(ctx.Err()) // 任务取消的原因 // 一些清理工作 } } func main() { ctx := context.Background() // Add Context info ctx = context.WithValue(ctx, DB_ADDRESS, \"localhost:3306\") ctx = context.WithValue(ctx, CALCULATE_VALUE, \"123\") ctx, cancel := context.WithTimeout(ctx, time.Second*2) defer cancel() go readDB(ctx, time.Second*4) go calculate(ctx, time.Second*4) time.Sleep(time.Second * 5) } 使用 Context，能够有效地在一组 goroutine 中传递共享值、取消信号、deadline 等信息，及时关闭不需要的 goroutine。 ","date":"2024-06-01","objectID":"/posts/golang-context/:2:0","tags":["Go","Golang","Context","并发编程","微服务","服务治理","错误处理","最佳实践","并发控制","性能优化"],"title":"深入理解 Go Context：优雅的并发控制与请求管理","uri":"/posts/golang-context/"},{"categories":["Go语言","并发编程","微服务","服务端开发","最佳实践"],"content":"Reference Go Context ","date":"2024-06-01","objectID":"/posts/golang-context/:3:0","tags":["Go","Golang","Context","并发编程","微服务","服务治理","错误处理","最佳实践","并发控制","性能优化"],"title":"深入理解 Go Context：优雅的并发控制与请求管理","uri":"/posts/golang-context/"},{"categories":["Go语言","性能优化","内存管理","编程原理","最佳实践"],"content":"深入解析 Go 语言的逃逸分析机制，通过实例讲解各种常见的逃逸场景及其性能影响。掌握如何识别和优化内存分配，帮助你编写更高效的 Go 程序。包含详细的代码示例和性能优化建议。","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/","tags":["Go","Golang","逃逸分析","内存优化","性能优化","GC优化","编译优化","内存管理","性能调优","最佳实践"],"title":"Go 内存优化实战：逃逸分析完全指南","uri":"/posts/golang-escape-analysis/"},{"categories":["Go语言","性能优化","内存管理","编程原理","最佳实践"],"content":" 导语 在 Go 语言中，编译器通过逃逸分析来决定变量的内存分配位置，这直接影响着程序的性能和内存使用效率。但很多开发者对此知之甚少，导致代码中潜藏着性能隐患。本文将带你深入理解 Go 的逃逸分析机制，通过丰富的示例解析各种逃逸场景，帮助你掌握内存优化的关键技巧。从理论到实践，让你的 Go 程序更快、更高效。 ","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/:0:0","tags":["Go","Golang","逃逸分析","内存优化","性能优化","GC优化","编译优化","内存管理","性能调优","最佳实践"],"title":"Go 内存优化实战：逃逸分析完全指南","uri":"/posts/golang-escape-analysis/"},{"categories":["Go语言","性能优化","内存管理","编程原理","最佳实践"],"content":"I. Golang Escape Ananlysis Golang 编译器会自动决定把一个变量放在堆栈还是栈上，即逃逸分析（Escape Analysis）. Go 声称逃逸分析可以释放程序员关于内存的使用限制，更多地关注程序逻辑本身。 ","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/:1:0","tags":["Go","Golang","逃逸分析","内存优化","性能优化","GC优化","编译优化","内存管理","性能调优","最佳实践"],"title":"Go 内存优化实战：逃逸分析完全指南","uri":"/posts/golang-escape-analysis/"},{"categories":["Go语言","性能优化","内存管理","编程原理","最佳实践"],"content":"II. 逃逸规则 众所周知，当变量需要使用堆（heap）空间时，那么变量就应该进行逃逸。 一般情况下，一个引用对象中的引用类成员进行赋值，可能出现逃逸现象：可以理解为访问一个引用对象实际上底层就是通过一个指针来间接的访问，但如果再访问里面的引用成员就会有第二次间接访问，这样操作这部分对象的话，极大可能会出现逃逸的现象。 Golang 中的引用类型有函数类型 func()，接口类型 interface，切片类型 slice，字典类型 map，管道类型 channel，指针类型 * 等。 ","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/:2:0","tags":["Go","Golang","逃逸分析","内存优化","性能优化","GC优化","编译优化","内存管理","性能调优","最佳实践"],"title":"Go 内存优化实战：逃逸分析完全指南","uri":"/posts/golang-escape-analysis/"},{"categories":["Go语言","性能优化","内存管理","编程原理","最佳实践"],"content":"逃逸场景I： []interface{} 使用 [] 赋值 []interface{} 数据类型，必定逃逸 package main import \"fmt\" func main() { data := []interface{}{1, 2} val := data[0] fmt.Printf(\"%v\\n\", val) data[0] = 3 } $ go build -v -gcflags='-m' ./main.go command-line-arguments # command-line-arguments ./main.go:8:12: inlining call to fmt.Printf ./main.go:6:23: []interface {}{...} does not escape ./main.go:6:24: 1 escapes to heap ./main.go:6:27: 2 escapes to heap ./main.go:8:12: ... argument does not escape ./main.go:9:12: 3 escapes to heap ","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/:2:1","tags":["Go","Golang","逃逸分析","内存优化","性能优化","GC优化","编译优化","内存管理","性能调优","最佳实践"],"title":"Go 内存优化实战：逃逸分析完全指南","uri":"/posts/golang-escape-analysis/"},{"categories":["Go语言","性能优化","内存管理","编程原理","最佳实践"],"content":"逃逸场景II： map[string]interface{} 使用 [] 赋值 map[string]interface{} 数据类型，必定逃逸 package main import \"fmt\" func main() { dat := make(map[string]interface{}) dat[\"BlogName\"] = \"Kyden's Blog\" val := dat[\"BlogName\"] fmt.Printf(\"%v\\n\", val) } $ go build -v -gcflags='-m' ./main.go command-line-arguments # command-line-arguments ./main.go:9:12: inlining call to fmt.Printf ./main.go:6:13: make(map[string]interface {}) does not escape ./main.go:7:20: \"Kyden's Blog\" escapes to heap ./main.go:9:12: ... argument does not escape ","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/:2:2","tags":["Go","Golang","逃逸分析","内存优化","性能优化","GC优化","编译优化","内存管理","性能调优","最佳实践"],"title":"Go 内存优化实战：逃逸分析完全指南","uri":"/posts/golang-escape-analysis/"},{"categories":["Go语言","性能优化","内存管理","编程原理","最佳实践"],"content":"逃逸场景 III： map[interface{}]interface{} 使用 [] 赋值 map[interface{}]interface{} 数据类型，必定逃逸 package main import ( \"fmt\" ) func main() { dat := make(map[interface{}]interface{}) dat[\"BlogName\"] = \"Kyden's Blog\" val := dat[\"BlogName\"] fmt.Printf(\"%v\\n\", val) } $ go build -v -gcflags='-m' ./main.go command-line-arguments # command-line-arguments ./main.go:11:12: inlining call to fmt.Printf ./main.go:8:13: make(map[interface {}]interface {}) does not escape ./main.go:9:6: \"BlogName\" escapes to heap ./main.go:9:20: \"Kyden's Blog\" escapes to heap ./main.go:10:13: \"BlogName\" does not escape ./main.go:11:12: ... argument does not escape ","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/:2:3","tags":["Go","Golang","逃逸分析","内存优化","性能优化","GC优化","编译优化","内存管理","性能调优","最佳实践"],"title":"Go 内存优化实战：逃逸分析完全指南","uri":"/posts/golang-escape-analysis/"},{"categories":["Go语言","性能优化","内存管理","编程原理","最佳实践"],"content":"逃逸场景 IV：map[string][]string map[string][]string 数据类型，赋值会发生 []string 逃逸 package main import ( \"fmt\" ) func main() { dat := make(map[string][]string) dat[\"BlogName\"] = []string{\"Kyden's Blog\"} val := dat[\"BlogName\"] fmt.Printf(\"%v\\n\", val) } $ go build -v -gcflags='-m' ./main.go command-line-arguments # command-line-arguments ./main.go:11:12: inlining call to fmt.Printf ./main.go:8:13: make(map[string][]string) does not escape ./main.go:9:28: []string{...} escapes to heap ./main.go:11:12: ... argument does not escape ./main.go:11:21: val escapes to heap ","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/:2:4","tags":["Go","Golang","逃逸分析","内存优化","性能优化","GC优化","编译优化","内存管理","性能调优","最佳实践"],"title":"Go 内存优化实战：逃逸分析完全指南","uri":"/posts/golang-escape-analysis/"},{"categories":["Go语言","性能优化","内存管理","编程原理","最佳实践"],"content":"逃逸场景 V：[]*int []*int 数据类型，赋值的右值会发生逃逸 package main import \"fmt\" func main() { dat := []*int{nil} a := 10 dat[0] = \u0026a fmt.Printf(\"%v\\r\\n\", *dat[0]) fmt.Printf(\"%v\\r\\n\", dat[0]) } $ go build -v -gcflags='-m' ./main.go command-line-arguments # command-line-arguments ./main.go:9:12: inlining call to fmt.Printf ./main.go:10:12: inlining call to fmt.Printf ./main.go:7:2: moved to heap: a ./main.go:6:15: []*int{...} does not escape ./main.go:9:12: ... argument does not escape ./main.go:9:23: *dat[0] escapes to heap ./main.go:10:12: ... argument does not escape ","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/:2:5","tags":["Go","Golang","逃逸分析","内存优化","性能优化","GC优化","编译优化","内存管理","性能调优","最佳实践"],"title":"Go 内存优化实战：逃逸分析完全指南","uri":"/posts/golang-escape-analysis/"},{"categories":["Go语言","性能优化","内存管理","编程原理","最佳实践"],"content":"逃逸场景 VI：func(*int) func(*int) 数据类型，进行函数赋值，会使传递的形参逃逸 package main import \"fmt\" func f(a *int) { fmt.Printf(\"%v\\n\", *a) return } func main() { a := 10 fn := f fn(\u0026a) fmt.Printf(\"a = %v\\n\", a) } $ go build -v -gcflags='-m' ./main.go # command-line-arguments ./main.go:6:12: inlining call to fmt.Printf ./main.go:14:12: inlining call to fmt.Printf ./main.go:5:8: a does not escape ./main.go:6:12: ... argument does not escape ./main.go:6:21: *a escapes to heap ./main.go:14:12: ... argument does not escape ./main.go:14:25: a escapes to heap ","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/:2:6","tags":["Go","Golang","逃逸分析","内存优化","性能优化","GC优化","编译优化","内存管理","性能调优","最佳实践"],"title":"Go 内存优化实战：逃逸分析完全指南","uri":"/posts/golang-escape-analysis/"},{"categories":["Go语言","系统编程","并发编程","性能优化","编程原理"],"content":"深入解析 Go 语言 GMP 调度模型的设计理念和实现原理，从进程、线程到协程的演进，详细讲解 Goroutine 调度机制、任务窃取、阻塞处理等核心概念。通过源码分析和实例说明，帮助你全面理解 Go 的并发调度系统。","date":"2024-05-15","objectID":"/posts/golang-gmp/","tags":["Go","Golang","GMP","并发编程","系统编程","性能优化","调度器","线程管理","高性能","底层原理"],"title":"图解 Go 调度器：GMP 模型深度剖析","uri":"/posts/golang-gmp/"},{"categories":["Go语言","系统编程","并发编程","性能优化","编程原理"],"content":" 导语 Go 语言因其强大的并发特性而备受欢迎，而这一切的基础都在于其独特的 GMP 调度模型。本文将带你揭开 Go 调度器的神秘面纱，从操作系统的进程、线程概念开始，一步步深入理解 Goroutine 的工作原理。通过图解和源码分析，让你真正理解 Go 是如何实现高效的并发调度，以及为什么 Go 的并发编程如此简单优雅。无论你是 Go 开发新手还是经验丰富的工程师，这篇文章都能帮你更深入地理解 Go 的并发机制。 ","date":"2024-05-15","objectID":"/posts/golang-gmp/:0:0","tags":["Go","Golang","GMP","并发编程","系统编程","性能优化","调度器","线程管理","高性能","底层原理"],"title":"图解 Go 调度器：GMP 模型深度剖析","uri":"/posts/golang-gmp/"},{"categories":["Go语言","系统编程","并发编程","性能优化","编程原理"],"content":"I. Process、Thread、Co-routine ","date":"2024-05-15","objectID":"/posts/golang-gmp/:1:0","tags":["Go","Golang","GMP","并发编程","系统编程","性能优化","调度器","线程管理","高性能","底层原理"],"title":"图解 Go 调度器：GMP 模型深度剖析","uri":"/posts/golang-gmp/"},{"categories":["Go语言","系统编程","并发编程","性能优化","编程原理"],"content":"进程 Process 在操作系统中，进程使用进程控制块 (PCB, Process Control Block) 数据结构 task_struct 来描述，PCB 是进程存在的唯一标识。 进程是指在系统中正在运行的一个应用程序，程序一旦运行就是进程； 进程可以认为是程序执行的一个实例，进程是系统进行资源分配的最小单位，且每个进程拥有独立的地址空间； 一个进程无法直接访问到另一个进程的变量和数据结构，如果希望一个进程去访问另一个进程的资源，需要使用进程间的通信，如fifo、pipe、signal、socket 等； 进程调度算法：先来先服务调度算法、短作业优先调度算法、最短剩余作业优先调度算法、最高响应比优先调度算法、最高优先级优先调度算法、时间片轮转算法（公平调度，$20 - 50 ms$）、多级反馈队列调度算法($最高优先级 + 时间片轮转$)； ","date":"2024-05-15","objectID":"/posts/golang-gmp/:1:1","tags":["Go","Golang","GMP","并发编程","系统编程","性能优化","调度器","线程管理","高性能","底层原理"],"title":"图解 Go 调度器：GMP 模型深度剖析","uri":"/posts/golang-gmp/"},{"categories":["Go语言","系统编程","并发编程","性能优化","编程原理"],"content":"线程 Thread 用户态线程，是基于用户态的线程管理库来实现的，线程控制块 (Thread Control Block) 也是在库里实现，操作系统只能看到整个进程的PCB，即进程与用户线程属于多对一的模型。 内核态线程(Thread)，是由操作系统管理，对应的 TCB 存储在操作系统里，且其创建、销毁、调度都由操作系统完成； 轻量级线程 LWP(Light-weight process)，是由内核支持的用户线程，一个进程可以有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，即 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度。 在大多数系统中，LWP 和 普通进程的区别在于，LWP 只有一个最小的执行上下文和调度程序所需的统计信息。 线程是进程的一个实体，是进程的一条执行路径； 线程是比进程更小的独立运行的基本单位 一个程序至少存在一个进程，一个进程可以有多个($\u003e=1$)线程 进程与线程的区别 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈； 同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间； 同一进程内的线程共享本地的资源，但是进程之间的资源是独立的； 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程崩溃，即多进程比多线程健壮； 进程切换，消耗的资源大（主要是虚拟地址空间的切换开销），线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系； 多进程、多线程都可以并发执行，线程能减少并发执行的时间和空间开销； 每个独立的进程有一个程序入口、程序出口；线程不能独立运行，必须依存于应用程序中，有应用程序提供多个线程执行控制； ","date":"2024-05-15","objectID":"/posts/golang-gmp/:1:2","tags":["Go","Golang","GMP","并发编程","系统编程","性能优化","调度器","线程管理","高性能","底层原理"],"title":"图解 Go 调度器：GMP 模型深度剖析","uri":"/posts/golang-gmp/"},{"categories":["Go语言","系统编程","并发编程","性能优化","编程原理"],"content":"协程 Co-routine 协程，又称 “微线程”，表现为一个可以 suspend 和 resume 的函数。 实现协程的关键点：在于如何保存、恢复和切换上下文，协程切换只涉及基本的CPU上下文切换（CPU寄存器）. 所有的协程共用的都是一个栈，即系统栈，也就并不需要我们自行去给协程分配栈，因为是函数调用，我们当然也不必去显示的保存寄存器的值； Co-routine 分类 有栈 (stackful) 协程：实现类似于内核态线程的实现，不同协程的切换还是要切换对应的栈上下文，只是不用陷入内核，例如 goroutine、libco 无栈 (stackless) 协程：无栈协程的上下文都会放到公共内存中，在协程切换时使用状态机来切换，而不用切换对应的上下文（都已经在堆中），相比有栈协程更轻量，例如 C++20、Rust、JavaScript；本质就是一个状态机（state machine），即同一协程协程的切换本质不过是指令指针寄存器的改变 Co-routine 特点 一个线程可以有多个协程；协程不是被操作系统内核管理，而是完全由程序控制； 协程的开销远远小于线程；协程拥有自己的寄存器上下文和栈，在进行协程调度时，将寄存器上下文和栈保存到其他地方，在切换回来时恢复先前保存的寄存器上下文和栈； 每个协程表示一个执行单元，有自己的本地数据，与其他协程共享全局数据和其他资源； 跨平台、跨体系架构、无需线程上下文切换的开销、方便切换控制流，简化编程模型； 协程的执行效率极高，和多线程相比，线程数量越多，协程的性能优势越明显； ","date":"2024-05-15","objectID":"/posts/golang-gmp/:1:3","tags":["Go","Golang","GMP","并发编程","系统编程","性能优化","调度器","线程管理","高性能","底层原理"],"title":"图解 Go 调度器：GMP 模型深度剖析","uri":"/posts/golang-gmp/"},{"categories":["Go语言","系统编程","并发编程","性能优化","编程原理"],"content":"II. GMP Golang 为提供更加容易使用的并发工具，基于 GMP 模型实现了 goroutine 和 channel。 Goroutine 属于 Co-routine 的概念，非常轻量，一个 goroutine 初始空间只占几 KB 且可伸缩，使得在有限空间内支持大量 goroutine 并发。 Channel 可以独立创建和存取，在不同的 Goroutine 中传递使用，作为队列，遵循 FIFO 原则，同时保证同一时刻只能有一个 goroutine 访问。 channel 作为一种引用类型，声明时需要指定传输数据类型，声明形式如下(T 是 channel 可传输的数据类型)： // 声明 channel var ch chan T // 双向 channel var ch chan\u003c- T // 只能发送 msg 的 channel var ch \u003c-chan T // 只能接收 msg 的 channel // 创建 channel ch := make(chan T, capicity) // 双向 channel ch := make(chan\u003c- T, capicity) // 只能发送 msg 的 channel ch := make(\u003c-chan T, capicity) // 只能接收 msg 的 channel // 访问 channel ch \u003c- msg // 发送 msg msg := \u003c-ch // 接收 msg msg, ok := \u003c-ch // 接收 msg，同时判断 channel 是否接收成功 close(ch) // 关闭 channel ","date":"2024-05-15","objectID":"/posts/golang-gmp/:2:0","tags":["Go","Golang","GMP","并发编程","系统编程","性能优化","调度器","线程管理","高性能","底层原理"],"title":"图解 Go 调度器：GMP 模型深度剖析","uri":"/posts/golang-gmp/"},{"categories":["Go语言","系统编程","并发编程","性能优化","编程原理"],"content":"Golang 调度 调度组件 G：Goroutine，一个计算任务. 由需要执行的代码和其上下文组成，上下文包括：当前代码位置、栈空间(初始2K，可增长)、状态等。 M：Machine，系统线程，执行实体。与 C 语言中的线程相同，通过 clone 创建。 P: Processor，虚拟处理器，包含了 G 运行所需的资源，因此 M 必须获得 P 才能执行代码，否则必须陷入休眠（后台监控线程除外）。可理解为一种 token，有这个 token，才有在物理 CPU 核心上执行的权限。 相关数据结构定义如下： g 的数据结构： type g struct { // Stack parameters. // stack describes the actual stack memory: [stack.lo, stack.hi). // stackguard0 is the stack pointer compared in the Go stack growth prologue. // It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption. // stackguard1 is the stack pointer compared in the //go:systemstack stack growth prologue. // It is stack.lo+StackGuard on g0 and gsignal stacks. // It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash). stack stack // offset known to runtime/cgo stackguard0 uintptr // offset known to liblink stackguard1 uintptr // offset known to liblink _panic *_panic // innermost panic - offset known to liblink _defer *_defer // innermost defer m *m // current m; offset known to arm liblink sched gobuf syscallsp uintptr // if status==Gsyscall, syscallsp = sched.sp to use during gc syscallpc uintptr // if status==Gsyscall, syscallpc = sched.pc to use during gc stktopsp uintptr // expected sp at top of stack, to check in traceback // param is a generic pointer parameter field used to pass // values in particular contexts where other storage for the // parameter would be difficult to find. It is currently used // in four ways: // 1. When a channel operation wakes up a blocked goroutine, it sets param to // point to the sudog of the completed blocking operation. // 2. By gcAssistAlloc1 to signal back to its caller that the goroutine completed // the GC cycle. It is unsafe to do so in any other way, because the goroutine's // stack may have moved in the meantime. // 3. By debugCallWrap to pass parameters to a new goroutine because allocating a // closure in the runtime is forbidden. // 4. When a panic is recovered and control returns to the respective frame, // param may point to a savedOpenDeferState. param unsafe.Pointer atomicstatus atomic.Uint32 stackLock uint32 // sigprof/scang lock; TODO: fold in to atomicstatus goid uint64 schedlink guintptr waitsince int64 // approx time when the g become blocked waitreason waitReason // if status==Gwaiting preempt bool // preemption signal, duplicates stackguard0 = stackpreempt preemptStop bool // transition to _Gpreempted on preemption; otherwise, just deschedule preemptShrink bool // shrink stack at synchronous safe point // asyncSafePoint is set if g is stopped at an asynchronous // safe point. This means there are frames on the stack // without precise pointer information. asyncSafePoint bool paniconfault bool // panic (instead of crash) on unexpected fault address gcscandone bool // g has scanned stack; protected by _Gscan bit in status throwsplit bool // must not split stack // activeStackChans indicates that there are unlocked channels // pointing into this goroutine's stack. If true, stack // copying needs to acquire channel locks to protect these // areas of the stack. activeStackChans bool // parkingOnChan indicates that the goroutine is about to // park on a chansend or chanrecv. Used to signal an unsafe point // for stack shrinking. parkingOnChan atomic.Bool // inMarkAssist indicates whether the goroutine is in mark assist. // Used by the execution tracer. inMarkAssist bool coroexit bool // argument to coroswitch_m raceignore int8 // ignore race detection events nocgocallback bool // whether disable callback from C tracking bool // whether we're tracking this G for sched latency statistics trackingSeq uint8 // used to decide whether to track this G trackingStamp int64 // timestamp of when the G last started being tracked runnableTime int64 // the amount of time spent runnable, cleared when running, only used when tracking lockedm muintptr sig uint32 writebuf []byte sigcode0 uintptr sigcode1 uintptr sigpc uintptr parentGoid uint64 // goid of g","date":"2024-05-15","objectID":"/posts/golang-gmp/:2:1","tags":["Go","Golang","GMP","并发编程","系统编程","性能优化","调度器","线程管理","高性能","底层原理"],"title":"图解 Go 调度器：GMP 模型深度剖析","uri":"/posts/golang-gmp/"},{"categories":["Go语言","系统编程","并发编程","性能优化","编程原理"],"content":"Goroutine 切换成本 gobuf 描述了一个 Goroutine 所有现场，从一个 g 切换到另一个 g，只要把这几个现场字段保存下来，再将 g 入队，M 就可以执行其他 g 了，无需进入内核态。 gobuf 数据结构如下 type gobuf struct { // The offsets of sp, pc, and g are known to (hard-coded in) libmach. // // ctxt is unusual with respect to GC: it may be a // heap-allocated funcval, so GC needs to track it, but it // needs to be set and cleared from assembly, where it's // difficult to have write barriers. However, ctxt is really a // saved, live register, and we only ever exchange it between // the real register and the gobuf. Hence, we treat it as a // root during stack scanning, which means assembly that saves // and restores it doesn't need write barriers. It's still // typed as a pointer so that any other writes from Go get // write barriers. sp uintptr pc uintptr g guintptr ctxt unsafe.Pointer ret uintptr lr uintptr bp uintptr // for framepointer-enabled architectures } ","date":"2024-05-15","objectID":"/posts/golang-gmp/:2:2","tags":["Go","Golang","GMP","并发编程","系统编程","性能优化","调度器","线程管理","高性能","底层原理"],"title":"图解 Go 调度器：GMP 模型深度剖析","uri":"/posts/golang-gmp/"},{"categories":["Go语言","系统编程","并发编程","性能优化","编程原理"],"content":"runtime 可拦截 goroutine 阻塞场景解析 Goroutine 属于协程的一种，因此存在运行态、阻塞态等各种状态。 那么 goroutine 什么情况下会发生阻塞？ 当 goroutine 发生阻塞时，GMP 模型如何应对？ 显然，当 goroutine 发生可被 runtime 拦截的阻塞时，GMP 模型并不会阻塞调度循环， 而是把 goroutine 挂起，即让 g 先进某个数据结构，待 ready 后在继续执行，并不会占用线程， 同时线程会进入 schedule，继续消费队列，执行其他的 g. 场景 I: 延迟 package main import ( \"fmt\" \"time\" ) func main() { fmt.Println(\"Before: \", time.Now()) time.Sleep(30 * time.Minute) fmt.Println(\"After: \", time.Now()) } 函数调用链如下： time.Sleep -\u003e runtime.timeSleep { ... gp := getg() t := gp.timer ... t.arg = gp ... } -\u003e gopark(resetForSleep, unsafe.Pointer(t), waitReasonSleep, traceBlockSleep, 1) 显然，在 runtime.timeSleep 函数中，获取到的当前 g 被挂在 runtime.timer.arg 上，然后被挂起。 场景 II: Channel send / recv (chan / select) package main import ( \"fmt\" \"sync\" \"time\" ) func main() { var ch = make(chan int) var wg = sync.WaitGroup{} wg.Add(2) go func(ch chan\u003c- int) { defer close(ch) defer wg.Done() time.Sleep(time.Second) ch \u003c- 1 }(ch) go func(ch \u003c-chan int) { defer wg.Done() val := \u003c-ch fmt.Println(val) }(ch) wg.Wait() } 函数 ch\u003c- 调用链如下： ch\u003c- -\u003e runtime.chansend1 -\u003e runtime.chansend { ... gp := getg() mysg := acquireSudog() ... gp.waiting = mysg gp.param = nil c.sendq.enqueue(mysg) // Signal to anyone trying to shrink our stack that we're about // to park on a channel. The window between when this G's status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. gp.parkingOnChan.Store(true) gopark(chanparkcommit, unsafe.Pointer(\u0026c.lock), waitReasonChanSend, traceBlockChanSend, 2) ... } -\u003e gopark 函数 ch\u003c- 调用链如下： \u003c-ch -\u003e runtime.chanrecv1(c *hchan, elem unsafe.Pointer) -\u003e runtime.chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { ... // no sender available: block on this channel. gp := getg() mysg := acquireSudog() ... gp.waiting = mysg mysg.g = gp ... c.recvq.enqueue(mysg) // Signal to anyone trying to shrink our stack that we're about // to park on a channel. The window between when this G's status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. gp.parkingOnChan.Store(true) gopark(chanparkcommit, unsafe.Pointer(\u0026c.lock), waitReasonChanReceive, traceBlockChanRecv, 2) } -\u003e runtime.gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceReason traceBlockReason, traceskip int) 根据调用链可知，g 被封装进 sudog 中，然后挂在了 hchan.sendq 链表上。 相关数据结构 sudog, sendq 如下： sudog 的数据结构： // sudog (pseudo-g) represents a g in a wait list, such as for sending/receiving // on a channel. // // sudog is necessary because the g ↔ synchronization object relation // is many-to-many. A g can be on many wait lists, so there may be // many sudogs for one g; and many gs may be waiting on the same // synchronization object, so there may be many sudogs for one object. // // sudogs are allocated from a special pool. Use acquireSudog and // releaseSudog to allocate and free them. type sudog struct { // The following fields are protected by the hchan.lock of the // channel this sudog is blocking on. shrinkstack depends on // this for sudogs involved in channel ops. g *g next *sudog prev *sudog elem unsafe.Pointer // data element (may point to stack) // The following fields are never accessed concurrently. // For channels, waitlink is only accessed by g. // For semaphores, all fields (including the ones above) // are only accessed when holding a semaRoot lock. acquiretime int64 releasetime int64 ticket uint32 // isSelect indicates g is participating in a select, so // g.selectDone must be CAS'd to win the wake-up race. isSelect bool // success indicates whether communication over channel c // succeeded. It is true if the goroutine was awoken because a // value was delivered over channel c, and false if awoken // because c was closed. success bool // waiters is a count of semaRoot waiting list other than head of list, // clamped to a uint16 to fit in unused space. // Only meaningful at the head of the list. // (If we wanted to be overly clever, we could store a high 16 bits // in the se","date":"2024-05-15","objectID":"/posts/golang-gmp/:2:3","tags":["Go","Golang","GMP","并发编程","系统编程","性能优化","调度器","线程管理","高性能","底层原理"],"title":"图解 Go 调度器：GMP 模型深度剖析","uri":"/posts/golang-gmp/"},{"categories":["Go语言","系统编程","并发编程","性能优化","编程原理"],"content":"runtime 不可拦截 goroutine 阻塞场景解析 time.Sleep / channel send / channel recv / select / net read / net write / sync.Mutex 等阻塞场景可被 runtime 拦截，然而仍存在一些阻塞情况是 runtime 无法拦截的，例如：在执行 C 代码或阻塞在 syscall 上时，必须占用一个线程。 ","date":"2024-05-15","objectID":"/posts/golang-gmp/:2:4","tags":["Go","Golang","GMP","并发编程","系统编程","性能优化","调度器","线程管理","高性能","底层原理"],"title":"图解 Go 调度器：GMP 模型深度剖析","uri":"/posts/golang-gmp/"},{"categories":["Go语言","系统编程","并发编程","性能优化","编程原理"],"content":"III. Sysmon system monitor，高优先级，在专有线程中执行，不需要绑定 p. ","date":"2024-05-15","objectID":"/posts/golang-gmp/:3:0","tags":["Go","Golang","GMP","并发编程","系统编程","性能优化","调度器","线程管理","高性能","底层原理"],"title":"图解 Go 调度器：GMP 模型深度剖析","uri":"/posts/golang-gmp/"},{"categories":["Go语言","系统编程","并发编程","性能优化","编程原理"],"content":"IV. Summary Runtime 构成：Scheduler、Netpoll、内存管理、垃圾回收 GMP：M - 任务消费者；G - 计算任务；P - 可以使用 CPU 的 token GMP 中的队列抽象：P 的本地 runnext 字段 –» P 的 local run queue –» global run queue；采用多级队列减少锁竞争 调度循环：线程 M 在持有 P 的情况下不断消费运行队列中的 G 的过程 处理阻塞： runtime 可以接管的阻塞： channel send / recv，sync.Mutex，net read / write，select，time.Sleep 所有 runtime 可接管的阻塞都是通过 gopark / goparkunlock 挂起，goready 恢复 runtime 不可接管的阻塞：syscall，cgo，长时间运行需要剥离 P 执行； sysmon： 一个后台高级优先级循环，执行时不需要绑定任何的 P 负责： 检查是否已经没有活动线程，如果是则崩溃 轮询 netpoll 剥离在 syscall 上阻塞的 M 的 P 发信号，抢占已经执行时间过长的 G ","date":"2024-05-15","objectID":"/posts/golang-gmp/:4:0","tags":["Go","Golang","GMP","并发编程","系统编程","性能优化","调度器","线程管理","高性能","底层原理"],"title":"图解 Go 调度器：GMP 模型深度剖析","uri":"/posts/golang-gmp/"},{"categories":["Go语言","系统编程","并发编程","性能优化","编程原理"],"content":"V. Q \u0026 A 为什么阻塞等待的 goroutine，有时表现为 g 有时表现为 sudog ？ sudog (pseudo-g) 表示等待列表中的 g，例如用于在 channel 上的 send/recv. g 与同步对象是多对多的关系: 一个 g 可以出现在多个等待列表中，因此一个 g 可能有多个 sudog； 很多 g 可能在等待同一个同步对象，因此一个对象可能有很多 sudog 一个 g 可能对应多个 sudog，比如一个 g 会同时 select 多个 channel ","date":"2024-05-15","objectID":"/posts/golang-gmp/:5:0","tags":["Go","Golang","GMP","并发编程","系统编程","性能优化","调度器","线程管理","高性能","底层原理"],"title":"图解 Go 调度器：GMP 模型深度剖析","uri":"/posts/golang-gmp/"},{"categories":["Go语言","系统编程","并发编程","性能优化","编程原理"],"content":"VI. Reference Golang的协程调度器原理及GMP设计思想 Golang 生产-消费调度流程: Producer Golang 生产-消费调度流程: Consumer 极端情况下收缩 Go 的线程数 Go Scheduler 变更史 internal/poll/fd_poll_runtime.go internal/poll/fd_unix.go net/fd_unix.go runtime/runtime2.go runtime/time.go runtime/proc.go runtime/netpoll.go runtime/netpoll_epoll.go runtime/sema.go sync/mutex.go time/sleep.go ","date":"2024-05-15","objectID":"/posts/golang-gmp/:6:0","tags":["Go","Golang","GMP","并发编程","系统编程","性能优化","调度器","线程管理","高性能","底层原理"],"title":"图解 Go 调度器：GMP 模型深度剖析","uri":"/posts/golang-gmp/"},{"categories":["Go语言","网络编程","系统编程","性能优化","编程原理"],"content":"深入剖析 Go 语言网络轮询器的实现原理，从 Linux epoll 机制到 Go runtime 的调度集成。通过源码分析和实例讲解，全面介绍 netpoll 的初始化流程、事件处理机制以及与 goroutine 调度的交互过程，帮助你掌握 Go 高性能网络编程的核心知识。","date":"2024-05-08","objectID":"/posts/golang-netpoll/","tags":["Go","Golang","netpoll","网络编程","IO多路复用","网络模型","高性能","系统编程","网络框架","性能优化"],"title":"揭秘 Go 网络轮询器：从 epoll 到 netpoll 的架构实现","uri":"/posts/golang-netpoll/"},{"categories":["Go语言","网络编程","系统编程","性能优化","编程原理"],"content":" 导语 Go 语言的高性能网络编程背后，隐藏着一个精心设计的网络轮询器。它巧妙地将 Linux epoll 的高效事件通知机制与 Go runtime 的 goroutine 调度系统完美结合，成就了 Go 简单优雅却高效强大的网络编程模型。本文将带你深入探索这个神奇的系统，从底层的 epoll 实现到上层的 goroutine 调度，全方位解析 Go 网络轮询器的工作原理。无论你是想深入理解 Go 的并发机制，还是追求网络应用的极致性能，这都是一篇不容错过的技术探索。 Golang 源码版本 本文所涉及的源码版本：v1.22.3 ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:0:0","tags":["Go","Golang","netpoll","网络编程","IO多路复用","网络模型","高性能","系统编程","网络框架","性能优化"],"title":"揭秘 Go 网络轮询器：从 epoll 到 netpoll 的架构实现","uri":"/posts/golang-netpoll/"},{"categories":["Go语言","网络编程","系统编程","性能优化","编程原理"],"content":"I. 基础概念 网络编程，是允许不同计算机上的程序通过网络通信的开发过程，涉及多种协议（HTTP、TCP/IP等）以及不同编程语言的应用。 ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:1:0","tags":["Go","Golang","netpoll","网络编程","IO多路复用","网络模型","高性能","系统编程","网络框架","性能优化"],"title":"揭秘 Go 网络轮询器：从 epoll 到 netpoll 的架构实现","uri":"/posts/golang-netpoll/"},{"categories":["Go语言","网络编程","系统编程","性能优化","编程原理"],"content":"同步、异步、并发模型 IO 模型 读写操作和阻塞阶段 阻塞 IO 程序阻塞于读写函数 IO 复用 程序阻塞于 IO 复用系统调用，但可同时监听多个 IO 事件；对 IO 本身的读写操作是非阻塞的 SIGIO 信号 信号触发读写就绪事件，用户程序执行读写操作；程序本身没有阻塞阶段 异步 IO 内核执行读写操作并触发读写完成事件；程序没有阻塞阶段 主要用于区分内核向应用程序通知的是何种 IO 事件（就绪事件 or 完成事件），以及由谁来完成 IO 读写（应用程序 or 内核） IO模型中的同步 同步 IO 模型，指的是应用程序发起 IO 操作后，必须等待 IO 操作完成后才能继续执行后续的操作，即 IO 操作的结果需要立即返回给应用程序；在此期间，应用程序处于阻塞状态，无法做其他操作。 优点：编程模型简单 缺点：效率较低（应用程序的执行速度被 IO 操作所限制） 对于操作系统内核来说，同步 IO 操作是指在内核处理 IO 请求时需要等待 IO 模型中的异步 异步 IO 模型，指的是应用程序发起 IO 操作后，无须等待 IO 操作完成，可以立即进行后续的操作；在此期间，操作系统负责把 IO 操作的结果返回给应用程序； 优点：可以充分利用系统资源，提高 IO 操作的效率 缺点：编程模型相对复杂 对于操作系统内核来说，异步 IO 操作指的是，在内核处理 IO 请求时无需等待，立即返回 并发模式 并发模式，指的是 I/O 处理单元和多个逻辑单元之间协调完成任务的方法 ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:1:1","tags":["Go","Golang","netpoll","网络编程","IO多路复用","网络模型","高性能","系统编程","网络框架","性能优化"],"title":"揭秘 Go 网络轮询器：从 epoll 到 netpoll 的架构实现","uri":"/posts/golang-netpoll/"},{"categories":["Go语言","网络编程","系统编程","性能优化","编程原理"],"content":"Linux Epoll epoll 在内核里使用红黑树(Red-black tree)来跟踪进程所有待检测的文件描述字 fd，把需要监控的 socket 通过 epoll_ctl() 函数加入内核中的红黑树里（红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)） epoll 使用事件驱动的机制，在内核里维护了一个链表(List)来记录就绪事件。 当某个 socket 有事件发生时，内核通过回调函数将其加入到这个就绪事件列表中。 当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率 两种触发模式 Level trigger：服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束 Edge trigger：服务器端只会从 epoll_wait 中苏醒一次 事件宏 EPOLLIN 表示对应的文件描述符可读（包括对端 socket 正常关闭） EPOLLOUT 表示对应的文件描述符可写 EPOLLPRI 表示对应的文件描述符有紧急的数据可读（带外数据） EPOLLERR 表示对应的文件描述符发生错误 EPOLLHUP 表示对应的文件描述符被挂断 EPOLLET 将 EPOLL 设为边缘触发模式（默认电平触发） EPOLLONESHOT 只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 socket 的话，需要再次把这个 socket 加入到内核中的事件注册表中 ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:1:2","tags":["Go","Golang","netpoll","网络编程","IO多路复用","网络模型","高性能","系统编程","网络框架","性能优化"],"title":"揭秘 Go 网络轮询器：从 epoll 到 netpoll 的架构实现","uri":"/posts/golang-netpoll/"},{"categories":["Go语言","网络编程","系统编程","性能优化","编程原理"],"content":"II. 应用示例 package main import \"net\" func main() { l, _ := net.Listen(\"tcp\", \"127.0.0.1:2333\") for { conn, _ := l.Accept() go func() { defer conn.Close() buf := make([]byte, 4096) _, _ = conn.Read(buf) conn.Write(buf) }() } } ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:2:0","tags":["Go","Golang","netpoll","网络编程","IO多路复用","网络模型","高性能","系统编程","网络框架","性能优化"],"title":"揭秘 Go 网络轮询器：从 epoll 到 netpoll 的架构实现","uri":"/posts/golang-netpoll/"},{"categories":["Go语言","网络编程","系统编程","性能优化","编程原理"],"content":"III. 相关数据结构 // src/net/fd_fake.go // Network file descriptor. type netFD struct { pfd poll.FD // immutable until Close family int sotype int isConnected bool // handshake completed or use of association with peer net string laddr Addr raddr Addr // The only networking available in WASI preview 1 is the ability to // sock_accept on a pre-opened socket, and then fd_read, fd_write, // fd_close, and sock_shutdown on the resulting connection. We // intercept applicable netFD calls on this instance, and then pass // the remainder of the netFD calls to fakeNetFD. *fakeNetFD } // poll.FD`: `src/internal/poll/fd_unix.go // FD is a file descriptor. The net and os packages use this type as a // field of a larger type representing a network connection or OS file. type FD struct { // Lock sysfd and serialize access to Read and Write methods. fdmu fdMutex // System file descriptor. Immutable until Close. Sysfd int // Platform dependent state of the file descriptor. SysFile // I/O poller. pd pollDesc // Semaphore signaled when file is closed. csema uint32 // Non-zero if this file has been set to blocking mode. isBlocking uint32 // Whether this is a streaming descriptor, as opposed to a // packet-based descriptor like a UDP socket. Immutable. IsStream bool // Whether a zero byte read indicates EOF. This is false for a // message based socket connection. ZeroReadIsEOF bool // Whether this is a file rather than a network socket. isFile bool } // Addr represents a network end point address. // // The two methods [Addr.Network] and [Addr.String] conventionally return strings // that can be passed as the arguments to [Dial], but the exact form // and meaning of the strings is up to the implementation. type Addr interface { Network() string // name of the network (for example, \"tcp\", \"udp\") String() string // string form of address (for example, \"192.0.2.1:25\", \"[2001:db8::1]:80\") } // fdMutex is a specialized synchronization primitive that manages // lifetime of an fd and serializes access to Read, Write and Close // methods on FD. type fdMutex struct { state uint64 rsema uint32 wsema uint32 } type SysFile struct { // Writev cache. iovecs *[]syscall.Iovec } type pollDesc struct { runtimeCtx uintptr } 通过源码可以看到，Golang 网络编程涉及到的 netFD, poll.FD, Addr, SysFile 以及 pollDesc 之间的关系如下： fdmu 是为了保证对同一个文件的读、写操作能分别被序列化 Sysfd 就是操作系统中 syscall 返回的 fd 值 pd，pollDesc I/O poller，是 Go 对 poll 过程的一个抽象，所有平台的抽象都是一样的 csema，当文件被关闭时会被触发 isBlocking 表明 FD 是否为 blocking 模式 IsStream 标志该 FD 是否是流式，与流式相反的是基于 packet 的，即 UDP socket ZeroReadIsEOF，当连接读到 0 长度时，用来区分是否代表 EOF. 如果是基于 packet 的 socket 连接，则始终是 false isFile 标志该 FD 是否代表文件，还是网络连接 netFD 结构中包含一个 poll.FD 类型的成员 pfd，以及 Addr 接口类型的 laddr 和 raddr poll.FD 结构含有 SysFile 和 pollDesc 类型的成员，以及 fdMutex 类型的 fdmu ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:3:0","tags":["Go","Golang","netpoll","网络编程","IO多路复用","网络模型","高性能","系统编程","网络框架","性能优化"],"title":"揭秘 Go 网络轮询器：从 epoll 到 netpoll 的架构实现","uri":"/posts/golang-netpoll/"},{"categories":["Go语言","网络编程","系统编程","性能优化","编程原理"],"content":"IV. TCP 网络编程基本流程 本部分涉及众多函数调用，为了描述清晰，采用了图的形式，其中，每一块第一行表示该块所表示的函数名称，其他部分表示该函数中关键函数调用。 ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:4:0","tags":["Go","Golang","netpoll","网络编程","IO多路复用","网络模型","高性能","系统编程","网络框架","性能优化"],"title":"揭秘 Go 网络轮询器：从 epoll 到 netpoll 的架构实现","uri":"/posts/golang-netpoll/"},{"categories":["Go语言","网络编程","系统编程","性能优化","编程原理"],"content":"创建 TCP socket 并监听: net.Listen NOTE 需要注意的是，在执行 net.(*netFD).listenStream 之前，由于 maxListenerBacklog 函数调用了 open(\"/proc/sys/net/core/somaxconn\")，则会导致 epoll 底层红黑树的提前创建: runtime.netpollinit -\u003e syscall.EpollCreate1 -\u003e Syscall6(SYS_EPOLL_CREATE1, uintptr(flags), 0, 0, 0, 0, 0). 另外，当启用 Timer 时，也存在提前初始化 netpoll 的可能，原因： Timers rely on the network poller time.NewTimer -\u003e runtime.startTimer -\u003e runtime.addtimer -\u003e runtime.doaddtimer -\u003e netpollGenericInit() // doaddtimer adds t to the current P's heap. // The caller must have locked the timers for pp. func doaddtimer(pp *p, t *timer) { // Timers rely on the network poller, so make sure the poller // has started. if netpollInited.Load() == 0 { netpollGenericInit() } ... } ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:4:1","tags":["Go","Golang","netpoll","网络编程","IO多路复用","网络模型","高性能","系统编程","网络框架","性能优化"],"title":"揭秘 Go 网络轮询器：从 epoll 到 netpoll 的架构实现","uri":"/posts/golang-netpoll/"},{"categories":["Go语言","网络编程","系统编程","性能优化","编程原理"],"content":"获取 TCP 连接: net.(*TCPListener).Accept ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:4:2","tags":["Go","Golang","netpoll","网络编程","IO多路复用","网络模型","高性能","系统编程","网络框架","性能优化"],"title":"揭秘 Go 网络轮询器：从 epoll 到 netpoll 的架构实现","uri":"/posts/golang-netpoll/"},{"categories":["Go语言","网络编程","系统编程","性能优化","编程原理"],"content":"TCP 连接读数据: net.(*TCPConn).Read ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:4:3","tags":["Go","Golang","netpoll","网络编程","IO多路复用","网络模型","高性能","系统编程","网络框架","性能优化"],"title":"揭秘 Go 网络轮询器：从 epoll 到 netpoll 的架构实现","uri":"/posts/golang-netpoll/"},{"categories":["Go语言","网络编程","系统编程","性能优化","编程原理"],"content":"TCP 连接写数据: net.(*TCPConn).Write ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:4:4","tags":["Go","Golang","netpoll","网络编程","IO多路复用","网络模型","高性能","系统编程","网络框架","性能优化"],"title":"揭秘 Go 网络轮询器：从 epoll 到 netpoll 的架构实现","uri":"/posts/golang-netpoll/"},{"categories":["Go语言","网络编程","系统编程","性能优化","编程原理"],"content":"V. netpoll 执行流程: netpoll 在调度和 GC 的关键点上都会检查一次 netpoll，确定是否存在 ready 状态的 FD： startTheWorldWithSema // reason is the same STW reason passed to stopTheWorld. start is the start // time returned by stopTheWorld. // // now is the current time; prefer to pass 0 to capture a fresh timestamp. // // stattTheWorldWithSema returns now. func startTheWorldWithSema(now int64, w worldStop) int64 { assertWorldStopped() mp := acquirem() // disable preemption because it can be holding p in a local var if netpollinited() { list, delta := netpoll(0) // non-blocking injectglist(\u0026list) netpollAdjustWaiters(delta) } lock(\u0026sched.lock) procs := gomaxprocs if newprocs != 0 { procs = newprocs newprocs = 0 } p1 := procresize(procs) sched.gcwaiting.Store(false) if sched.sysmonwait.Load() { sched.sysmonwait.Store(false) notewakeup(\u0026sched.sysmonnote) } unlock(\u0026sched.lock) worldStarted() ... } findrunnable // Finds a runnable goroutine to execute. // Tries to steal from other P's, get g from local or global queue, poll network. // tryWakeP indicates that the returned goroutine is not normal (GC worker, trace // reader) so the caller should try to wake a P. func findRunnable() (gp *g, inheritTime, tryWakeP bool) { ... // Poll network until next timer. if netpollinited() \u0026\u0026 (netpollAnyWaiters() || pollUntil != 0) \u0026\u0026 sched.lastpoll.Swap(0) != 0 { sched.pollUntil.Store(pollUntil) if mp.p != 0 { throw(\"findrunnable: netpoll with p\") } if mp.spinning { throw(\"findrunnable: netpoll with spinning\") } delay := int64(-1) if pollUntil != 0 { if now == 0 { now = nanotime() } delay = pollUntil - now if delay \u003c 0 { delay = 0 } } if faketime != 0 { // When using fake time, just poll. delay = 0 } list, delta := netpoll(delay) // block until new work is available ... } ... } pollWork // pollWork reports whether there is non-background work this P could // be doing. This is a fairly lightweight check to be used for // background work loops, like idle GC. It checks a subset of the // conditions checked by the actual scheduler. func pollWork() bool { if sched.runqsize != 0 { return true } p := getg().m.p.ptr() if !runqempty(p) { return true } if netpollinited() \u0026\u0026 netpollAnyWaiters() \u0026\u0026 sched.lastpoll.Load() != 0 { if list, delta := netpoll(0); !list.empty() { injectglist(\u0026list) netpollAdjustWaiters(delta) return true } } return false } sysmon // Always runs without a P, so write barriers are not allowed. // //go:nowritebarrierrec func sysmon() { ... lock(\u0026sched.sysmonlock) // Update now in case we blocked on sysmonnote or spent a long time // blocked on schedlock or sysmonlock above. now = nanotime() // trigger libc interceptors if needed if *cgo_yield != nil { asmcgocall(*cgo_yield, nil) } // poll network if not polled for more than 10ms lastpoll := sched.lastpoll.Load() if netpollinited() \u0026\u0026 lastpoll != 0 \u0026\u0026 lastpoll+10*1000*1000 \u003c now { sched.lastpoll.CompareAndSwap(lastpoll, now) list, delta := netpoll(0) // non-blocking - returns list of goroutines if !list.empty() { // Need to decrement number of idle locked M's // (pretending that one more is running) before injectglist. // Otherwise it can lead to the following situation: // injectglist grabs all P's but before it starts M's to run the P's, // another M returns from syscall, finishes running its G, // observes that there is no work to do and no other running M's // and reports deadlock. incidlelocked(-1) injectglist(\u0026list) incidlelocked(1) netpollAdjustWaiters(delta) } } ... } 根据 ready 的事件时 Read 或 Write，分别从 poolDesc 的 rg、wg 上获取该唤醒的 goroutine. 然后将已经 ready 的 goroutine push 到 toRun 链表，并且 toRun 链表最终会从 netpoll() 返回，通过 injectglist 进入全局队列. 相当于每次调度循环都要执行 netpoll，检查频率还是比较高的 // netpoll checks for ready network connections. // Returns list of goroutines that become runnable. // delay \u003c 0: blocks indefinitely // delay == 0: does not block, just polls // delay \u003e 0: block for up to that many nanoseconds func netpoll(delay int64) (gList, int32) { if epfd == -1 { return gList{}, 0 } var waitms int32 if delay \u003c 0 { waitms = -1 } else if ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:5:0","tags":["Go","Golang","netpoll","网络编程","IO多路复用","网络模型","高性能","系统编程","网络框架","性能优化"],"title":"揭秘 Go 网络轮询器：从 epoll 到 netpoll 的架构实现","uri":"/posts/golang-netpoll/"},{"categories":["Go语言","网络编程","系统编程","性能优化","编程原理"],"content":"VI. 总结 Golang 通过对 Linux 内核提供的 epoll 实现进行封装，实现了同步编程异步执行的效果，其核心数据结构是 netFD，并将 Sysfd 与 pollDesc 结构绑定。 当某个 netFD 产生 EAGAIN 错误时，则当前 Goroutine 将会被存储到其对应的 pollDesc 中，同时 Goroutine 会 gopark()，直至这个 netFD 再次发生读写事件，会将此 Goroutine 设置为 ready 并放入 toRun 队列等待重新运行，而底层事件通知机制就是 epoll. Golang 中 netpoll 的创建与初始化的可能来源：Timer、读文件、TCP Listen. 如下的调度和 GC 关键函数 startTheWorldWithSema、findrunnable、pollWork、sysmon 都会进行 netpoll 执行流程，检查是否存在 ready 状态的 FD. ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:6:0","tags":["Go","Golang","netpoll","网络编程","IO多路复用","网络模型","高性能","系统编程","网络框架","性能优化"],"title":"揭秘 Go 网络轮询器：从 epoll 到 netpoll 的架构实现","uri":"/posts/golang-netpoll/"},{"categories":["Go语言","网络编程","系统编程","性能优化","编程原理"],"content":"VII. Reference runtime/netpoll.go runtime/netpoll_epoll.go runtime/proc.go net/fd_unix.go internal/poll/fd_poll_runtime.go internal/poll/fd_unix.go ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:7:0","tags":["Go","Golang","netpoll","网络编程","IO多路复用","网络模型","高性能","系统编程","网络框架","性能优化"],"title":"揭秘 Go 网络轮询器：从 epoll 到 netpoll 的架构实现","uri":"/posts/golang-netpoll/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"深入探讨 Go 语言性能优化的完整工具链，从基准测试到性能分析，再到实际优化。通过实例讲解如何使用 Benchmark、pprof 等工具发现性能瓶颈，并结合实际场景分享优化策略和最佳实践，帮助你构建高性能的 Go 应用。","date":"2024-04-20","objectID":"/posts/golang-profile/","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":" 导语 在高并发的生产环境中，性能问题往往在最意想不到的时候出现：CPU 突然飙升、内存悄然泄露、Goroutine 数暴增、接口延迟陡升……如何在这些危机时刻快速定位和解决问题？本文将为你揭示 Go 语言性能优化的完整工具链和方法论，从基准测试的正确姿势，到性能分析工具的熟练应用，再到实战中的优化策略。无论你是在进行性能优化，还是在为未来的性能问题未雨绸缪，这都是一份不可或缺的实战指南。 测试环境的稳定性、一致性 性能测试的结果在很大程度上受到测试环境的影响，因此，在进行性能测试时应尽可能保持测试环境的稳定和一致。 测试机器在测试时，不要执行其他任务，不要与其他人共享硬件资源，不要开启节能模式 避免使用虚拟机和云主机：一般情况下，为了尽可能地提高资源利用率，虚拟机和云主机 CPU 和内存一般进行超分配，会导致超分机器的性能表现不稳定 超分配是针对硬件资源来说的，商业上对应的就是云主机的超卖。虚拟化技术带来的最大直接收益是服务器整合，通过 CPU、内存、存储、网络的超分配（Overcommitment）技术，最大化服务器的使用率。Linux 上专门有一个指标，Steal Time(st)，用来衡量被虚拟机监视器(Hypervisor)偷去给其它虚拟机使用的 CPU 时间所占的比例。 例如，虚拟化的技能之一就是随心所欲的操控 CPU，例如一台 32U(物理核心)的服务器可能会创建出 128 个 1U(虚拟核心)的虚拟机，当物理服务器资源闲置时，CPU 超分配一般不会对虚拟机上的业务产生明显影响，但如果大部分虚拟机都处于繁忙状态时，那么各个虚拟机为了获得物理服务器的资源就要相互竞争，相互等待。 ","date":"2024-04-20","objectID":"/posts/golang-profile/:0:0","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"I. Benchmark Go 语言 testing 标准库内置支持 Benchmark 测试。 Benchmark 和普通单元测试用例一样，都位于 _test.go 文件，并且函数名以 Benchmark 开头，参数是 b *testing.B. go test 命令默认不运行 Benchmark 测试，需要在命令中加上 -bench 参数来进行测试： go test -bench .: 运行当前 packge 内的用例 go test -bench 'In$' .: -bench 参数支持正则表达式，只有匹配到的用例才会运行 go test -bench ./\u003cpackage name\u003e: 运行子 package 内的用例 go test -bench ./...: 运行当前目录下所有的 package 内的用例 ","date":"2024-04-20","objectID":"/posts/golang-profile/:1:0","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"浅析 Benchmark 工作原理 Benchmark 用例参数 b *testing.B 中的 N 属性表示该用例需要运行的次数。 一般情况下，不同用例的 b.N 是不一样的。 b.N 从 1 开始，若该用例能够在 1s 内完成，b.N 的值则会增加，再次执行。b.N 的值大概以 1, 2, 3, 5, 10, 20, 30, 50, 100 … 这样的序列增加，越到后面，增加越快。 ➜ ziwi go test -bench='Fib$' -cpu=2,4 -benchtime=50x -count=2 -benchmem . goos: darwin goarch: arm64 pkg: go-temp/ziwi cpu: Apple M1 Pro BenchmarkFib-2 50 205.0 ns/op 0 B/op 0 allocs/op BenchmarkFib-2 50 386.7 ns/op 0 B/op 0 allocs/op BenchmarkFib-4 50 383.3 ns/op 0 B/op 0 allocs/op BenchmarkFib-4 50 385.0 ns/op 0 B/op 0 allocs/op PASS ok go-temp/ziwi 0.196s BenchmarkFib-10: -10 即 GOMAXPROCS，默认等于 CPU 核数，可通过 -cpu 参数改变 GOMAXPROCS，-cpu 支持传入一个列表作为参数 6097884 和 183.7 ns/op: 表示该用例执行了 6097884 次，每次执行需要花费的时间为 183.7 ns/op 为了提高性能测试的准确度，可以使用 -benchtime 和 -count 两个参数分别调整测试时长(默认 1s)和执行轮数。 其中，-benchtime 的值除了是时间外，还可以是具体次数：go test -bench='Fib$' -benchtime=300x . -benchmem 参数可以度量内存分配的次数 ","date":"2024-04-20","objectID":"/posts/golang-profile/:1:1","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"ResetTimer \u0026 StopTimer \u0026 StartTimer b.ResetTimer(): 用于将进行 Benchmark 开始前的准备工作所消耗的时间忽略掉 b.StopTimer(): 暂停计时 b.StartTimer(): 开始计时 ","date":"2024-04-20","objectID":"/posts/golang-profile/:1:2","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"II. Profile 当面对一个未知程序，如何分析这个程序的性能，并找到瓶颈点呢？ pprof 就是用来解决这个问题的 ","date":"2024-04-20","objectID":"/posts/golang-profile/:2:0","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"CPU 性能分析 CPU性能分析（CPU profiling）是最常见的性能分析类型，当启动 CPU 性能分析时，运行时（runtime）将每隔 10ms 中断一次，记录此时正在运行的协程（goroutines）的堆栈信息。 程序结束后，可以分析记录的数据找到最热代码路径（hosttest code paths）。 What’s the meaning of “hot codepath” Compiler hot paths are code execution paths in the compiler in which most of the execution time is spent, and which are potentially executed very often. – What’s the meaning of “hot codepath” 一个函数在性能分析数据中出现的次数越多，说明执行该函数代码路径（code path）花费的时间占总运行时间的比重越大。 ","date":"2024-04-20","objectID":"/posts/golang-profile/:2:1","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"内存性能分析 内存性能分析（Memory profiling）记录堆内存分配时的堆栈信息，忽略栈内存分配信息，当启动 memory 性能分析时，默认每 1000 次采样 1 次（这个比例可调整）。 由于内存性能分析是基于采样的，因此基于内存分析数据来判断程序所有的内存使用情况是很困难的。 ","date":"2024-04-20","objectID":"/posts/golang-profile/:2:2","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"阻塞性能分析 阻塞性能分析（block profiling）是 Go 特有的，它用来记录一个协程等待一个共享资源花费的时间，因此在判断程序的并发瓶颈时会很有用。 阻塞场景： 在没有缓冲区的信道上发送或接收数据 从空的信道上接收数据，或发送数据到满的信道上 尝试获得一个已经被其他协程锁住的排它锁 When using block profilling 一般情况下，当所有的 CPU 和 memory 瓶颈解决后，才会考虑阻塞性能分析。 ","date":"2024-04-20","objectID":"/posts/golang-profile/:2:3","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"实践场景 在进行 API 压测、全链路压测、线上生产环境被高峰流量打爆的过程中随时可能发生故障等问题，例如： CPU 占用过高，超过 90%； 内存爆掉，OOM(Out of memory)； Goroutine 数量过多，80W； 线程数超高； 延迟过高； 在发生以上故障时，一般需要结合 pprof 寻找故障原因，并根据不同的情况选择不同的方案； 线上一定要具有开启 pprof 的能力，如果考虑安全性，也要具有通过配置开启的能力； ","date":"2024-04-20","objectID":"/posts/golang-profile/:2:4","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"压测时需要关注的服务指标 Request rate: The number of service requests per second. Errors: The number of request that failed. Duration: The time for requests to complete. Goroutine / Thread 数量: 如果 Goroutine 数量很多，需要关注这些 Goroutine 的执行情况. GC 频率 gctrace 的内容: GC 的 STW 时间 还有一些其他 Memstats 相关的其他指标，可以参考 Prometheus. ","date":"2024-04-20","objectID":"/posts/golang-profile/:2:5","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"压测手段 wrk: a HTTP benchmarking tool wrk2: a HTTP benchmarking tool based mostly on wrk HEY: a tiny program that sends some load to a web application. Vegate: a versatile HTTP load testing tool built out of a need to drill HTTP services with a constant request rate. h2load: HTTP/2 benchmarking tool ghz: gRPC benchmarking and load testing tool ","date":"2024-04-20","objectID":"/posts/golang-profile/:2:6","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"pprof 应用实例 package main import ( \"net/http\" _ \"net/http/pprof\" ) var quit chan struct{} = make(chan struct{}) func f() { \u003c- quit } func main() { go func() { http.ListenAndServe(\":8080\", nil) }() for i := 0; i \u003c 10000; i++ { go f() } for {} // Test } go tool pprof -http=:9999 localhost:8080/debug/pprof/heap 注意事项 测试代码中引入 net/http/pprof 包： _ \"net/http/pprof\" 单独启动一个 Goroutine 开启监听(端口自定，例如这里是 8080)：go func() { http.ListenAndServe(\":8080\", nil) }() $ go tool pprof -http=:9999 localhost:8080/debug/pprof/heap ","date":"2024-04-20","objectID":"/posts/golang-profile/:2:7","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"III. Optimize ","date":"2024-04-20","objectID":"/posts/golang-profile/:3:0","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"优化方向 在分析上图的应用程序运行过程，可以发现进行程序优化时，一般从可以从以下方面入手： 应用层优化: 主要指的是逻辑优化、内存使用优化、CPU 使用优化、阻塞优化等，并且本层优化效果可能优于底层优化； 底层优化：GC优化、Go 标准库优化、Go runtime 优化等 ","date":"2024-04-20","objectID":"/posts/golang-profile/:3:1","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"基本优化流程 外部依赖：在监控系统中查看是否存在问题，例如依赖的上游服务 (DB/redis/MQ) 延迟过高； CPU 占用：通过查看 CPU profile 检查是否存在问题，优化占用 CPU 较多的部分逻辑； 内存占用：看 Prometheus，内存 RSS / Goroutine 数量 / Goroutine 栈占用 –» 如果 Goroutine 数量不多，则重点关注 heap profile 中的 inuse –» 定时任务类需要看 alloc Goroutine 数量过多 –» 从 profile 网页进去看看 Goroutine 的执行情况（在干什么？） –» 检查死锁、阻塞等问题 –» 个别不在意延迟的选择第三方库优化 ","date":"2024-04-20","objectID":"/posts/golang-profile/:3:2","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"常见优化场景 字符串拼接 package main import ( \"fmt\" \"testing\" ) func BenchmarkConcat0(b *testing.B) { var str string for i := 0; i \u003c b.N; i++ { str = \"\" str += \"userid : \" + \"1\" str += \"localtion : \" + \"ab\" } } func BenchmarkConcat1(b *testing.B) { var str string for i := 0; i \u003c b.N; i++ { str = \"\" str += fmt.Sprintf(\"userid : %v\", \"1\") str += fmt.Sprintf(\"localtion : %v\", \"ab\") } } $ go test -bench=. -benchmem goos: linux goarch: amd64 pkg: github.com/lutianen/go-test/bench0 cpu: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz BenchmarkConcat0-16 35702518 32.86 ns/op 24 B/op 1 allocs/op BenchmarkConcat1-16 8105732 140.9 ns/op 56 B/op 3 allocs/op PASS ok github.com/lutianen/go-test/bench0 2.506s 逃逸分析 用户声明的对象，被放在栈上还是堆上？ 可以通过编译器的 escape analysis 来决定 go build -gcflags=\"-m\" xxx.go package main func main() { var sl = make([]int, 1024) println(sl[0]) var sl0 = make([]int, 10240) println(sl0[0]) } $ go build -gcflags=\"-m\" main.go # command-line-arguments ./main.go:3:6: can inline main ./main.go:4:15: make([]int, 1024) does not escape ./main.go:7:16: make([]int, 10240) escapes to heap TODO: 各种逃逸分析的可能性有哪些？ Trasval 2-D Matrix package bench1 import \"testing\" func BenchmarkHorizontal(b *testing.B) { arrLen := 10000 arr := make([][]int, arrLen, arrLen) for i := 0; i \u003c arrLen; i++ { arrInternal := make([]int, arrLen) for j := 0; j \u003c arrLen; j++ { arrInternal[j] = 0 } arr[i] = arrInternal } for i := 0; i \u003c b.N; i++ { for x := 0; x \u003c len(arr); x++ { for y := 0; y \u003c len(arr); y++ { arr[x][y] = 1 } } } } func BenchmarkVertical(b *testing.B) { arrLen := 10000 arr := make([][]int, arrLen, arrLen) for i := 0; i \u003c arrLen; i++ { arrInternal := make([]int, arrLen) for j := 0; j \u003c arrLen; j++ { arrInternal[j] = 0 } arr[i] = arrInternal } for i := 0; i \u003c b.N; i++ { for x := 0; x \u003c len(arr); x++ { for y := 0; y \u003c len(arr); y++ { arr[y][x] = 1 } } } } $ go test -bench=. -benchmem goos: linux goarch: amd64 pkg: github.com/lutianen/go-test/bench1 cpu: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz BenchmarkHorizontal-16 15 71020410 ns/op 54629717 B/op 666 allocs/op BenchmarkVertical-16 1 1059649022 ns/op 819445856 B/op 10002 allocs/op PASS ok github.com/lutianen/go-test/bench1 3.676s Zero Garbage / Allocation Zero Grabage 一般指的是通过利用 sync.Pool 将堆分配完全消灭的优化技术。 例如，在 http router 框架 fasthttp 中应用较多. False Sharing CPU 运行过程中修改数据是一个 cache line为单位，当两个变量A/B满足以下条件： 在内存中相邻 并发修改频繁 那么，当 CPU0 修改变量 A 时，会导致 CPU1 中的变量 B 缓存失效。 解决方法，在定义数据结构中，填充一些 padding 用以满足该数据结构正好是 cache line 的整数倍； type NoPad struct { x uint64 y uint64 } type WithPad struct { x uint64 _ [6]uint64 y uint64 } 查看 cache line 大小：cat /sys/devices/system/cpu/cpu\u003ccore-num\u003e/cache/index0/coherency_line_size 降低外部命令调用频次 优化前： func f(wr http.ResponseWriter, r *http.Request) { uuid, _ := exec.Command(\"uuidgen\").Output() // Use exec.Command wr.Header()[\"Content-Type\"] = []string{\"application/text\"} io.WriteString(wr, string(uuid)) } 优化后： import uuid \"github.com/satori/go.uuid\" func f(wr http.ResponseWriter, r *http.Request) { uuid, _ := uuid.NewV4() // Replace exec.Command with existing library wr.Header()[\"Content-Type\"] = []string{\"application/text\"} io.WriteString(wr, uuid.String()) } 总结： 线上使用 exec 命令是非常危险的 采用第三方库代替外部命令 阻塞导致高延迟 锁阻塞 var mtx sync.Mutex var data = map[string]string{ \"hint\": \"hello wold\", } func f(wr http.ResponseWriter, r *http.Request) { mtx.Lock() defer mtx.Unlock() buf := data[\"hint\"] time.Sleep(time.Millisecond * 10) // 临界区内的慢操作 wr.Header()[\"Content-Type\"] = []string{\"application/json\"} io.WriteString(wr, buf) } 减小临界区 - 优化后： var mtx sync.Mutex var data = map[string]string{ \"hint\": \"hello wold\", } func f(wr http.ResponseWriter, r *http.Request) { mtx.Lock() buf := data[\"hint\"] mtx.Unlock() time.Sleep(time.Millisecond * 10) // 慢操作放置于临界区之外 wr.Header()[\"Content-Type\"] = []string{\"application/json\"} io.WriteString(wr, buf) } 在后端系统开发中，锁瓶颈是较常见的问题，例如文件锁 双 Buffer 完全干掉锁阻塞 使用双 Buffer / RCU 完全消除读阻塞：全量更新，直接替换原 config func updateConfig() { var newConfig = \u0026MyConfig { WhiteList: make(map[int]struct{}), } // Do a lot of compulation ","date":"2024-04-20","objectID":"/posts/golang-profile/:3:3","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"IV. Coutinuous Profiling 压测是一个蹲点行为，然而真实场景并不美好，它们通常是难以发现的偶发问题： 该到吃饭的时候，CPU 使用尖刺 凌晨四点半，系统发生 OOM 刚睡着的时候，Goroutine 数量爆炸 产品被部署到客户那里，想登陆客户的环境并不方便 此时 Coutinuout Profiling 就派上用场了. 自省式的 Profile Dumper，可以根据 CPU 利用率、Memory 利用率、Goroutine 数量等多个指标检测系统，设置定时周期进行检测，当发现某个指标异常时，自动 Dump file. ","date":"2024-04-20","objectID":"/posts/golang-profile/:4:0","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"V. Summary _pad 优化，针对多个线程更新同一个结构体内不同的字段场景有效，而针对一个线程同时更新整个结构体的场景意义不大； 第三方接口出现问题，如何保护自己的服务？ 对外部调用必须有超时 ==\u003e 熔断 goroutine 初始化栈空间为 2KB，最大 1GB，那么 heap 为什么不爆栈？ 在 Go 语言中，goroutine 和 heap 使用单独的内存空间：Goroutine 有自己的堆栈空间，用于存储局部变量、函数帧和其他运行时信息；heap 则是一个共享内存空间，用于存储动态分配的对象，例如 slice、map 和 strings。 当 Goroutine 需要分配的内存多于起堆栈上的可用内存时，它将自动从 stack 中分配内存，采用的是 stack 分配机制完成，运行 goroutine 分配任何数量的内存，而不用担心 stack 空间耗尽； 除了堆分配之外，goroutine 还可以使用一种称为堆栈复制的技术来在它们之间共享数据，堆栈复制比堆分配更有效，但它只能用于共享足够小以适合堆栈的数据。 ","date":"2024-04-20","objectID":"/posts/golang-profile/:5:0","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","性能优化","调试工具","程序分析","开发工具"],"content":"VI. Reference Benchmarks Game Go Web Frame Benchmarks Go HTTP Router Benchmark Web 场景跨语言性能对比 《Systems Performance》 Dave 分享的 High Performance Go Workshop go-perfbook: best practices for writing high-performance Go code Delve What is Continuous Profiling? Google-Wide Profiling: A Continuous Profiling Infrastructure for Data Centers Go 语言笔试面试题汇总 七天用Go从零实现系列 How to write benchmarks in Go ","date":"2024-04-20","objectID":"/posts/golang-profile/:6:0","tags":["Go","Golang","Profile","pprof","性能分析","性能优化","调试工具","内存分析","性能监控","程序调优"],"title":"Go 性能优化实战：从 Benchmark 到 Profile 的完整指南","uri":"/posts/golang-profile/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"全面介绍 Go 语言最实用的 12 个 Linter 工具，从基础的代码规范检查到高级的静态分析。通过实例讲解每个工具的特点、配置方法和最佳实践，帮助你在项目中建立完善的代码质量保证体系。包含 GolangCI-Lint 和 reviewdog 的 CI/CD 集成指南。","date":"2024-04-19","objectID":"/posts/golang-linter/","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":" 导语 在追求高质量 Go 代码的道路上，Linter 工具是你最可靠的伙伴。从代码风格的统一到潜在 bug 的预防，从性能隐患的发现到最佳实践的保证，一个优秀的 Linter 配置可以帮你规避 80% 的常见问题。本文将带你全面了解 Go 生态中最实用的 12 个 Linter 工具，通过实例讲解它们的特点和使用方法，帮助你打造一个强大的代码质量保障体系。无论是个人项目还是团队协作，这些工具都能帮你写出更好的 Go 代码。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:0:0","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"目录 说明 何为 Linter？ Gocyclo bodyclose sqlrows funlen goconst ineffassign lll errcheck whitespace GolangCI-Lint reviewdog Summary Reference ","date":"2024-04-19","objectID":"/posts/golang-linter/:1:0","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"O. 说明 如特殊说明，文中代码已在在 Mac 和 Linux 系统下进行测试 ","date":"2024-04-19","objectID":"/posts/golang-linter/:2:0","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"I. 何为 Linter？ Linter 是一种静态代码分析工具，用于在编译前检查代码中的错误、风格问题及潜在的 Bug。 在 Golang 生态中，Linter 工具帮助开发者在早期阶段就发现问题，从而避免后期修复的高成本。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:3:0","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"II. Gocyclo Gocyclo 是一款用于分析 Go 代码中函数圈复杂度的 Linter 工具，帮助开发者识别需要重构的复杂函数。 通过降低圈复杂度，代码变得更加简洁、易读且更易维护。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:4:0","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"函数圈复杂度(cyclomatic complexities) 圈复杂度，是一种衡量代码复杂性的指标，通过计算代码中的决策点（如if语句、循环等）来评估函数的复杂度，具体计算方法如下： 一个函数的基本圈复杂度为 1 当函数中存在的每一个 if, for, case, \u0026\u0026 or ||，都会使得该函数的圈复杂度加 1 在 Go 语言中，由于 if err != nil 的特殊情况存在，因此，其圈复杂度阈值默认为 15，而其他编程语言中圈复杂度阈值一般默认为 10。 在 Go 语言中，switch 中的 default 并不会增加函数的圈复杂度； Gocyclo 可以作为单独的命令行工具使用，也可以与其他 Linter 工具(如 golangci-lint)集成使用，提供更全面的代码质量检查。 同时，它也可以集成到 CI/CD 流程中，帮助团队持续改善代码质量。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:4:1","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"安装 go install github.com/fzipp/gocyclo/cmd/gocyclo@latest ","date":"2024-04-19","objectID":"/posts/golang-linter/:4:2","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"如何使用 Gocyclo linter ？ Calculate cyclomatic complexities of Go functions. Usage: gocyclo [flags] \u003cGo file or directory\u003e ... Flags: -over N show functions with complexity \u003e N only and return exit code 1 if the set is non-empty -top N show the top N most complex functions only -avg, -avg-short show the average complexity over all functions; the short option prints the value without a label -ignore REGEX exclude files matching the given regular expression The output fields for each line are: \u003ccomplexity\u003e \u003cpackage\u003e \u003cfunction\u003e \u003cfile:line:column\u003e 使用示例 // gocyclo-test/main.go package main import ( \"fmt\" \"strconv\" ) func main() { var a = 10 if a == 10 { f() } else { fmt.Printf(\"%s\", strconv.Itoa(a)) } switch a{ case 10: fmt.Println(a) default: fmt.Println(\"default\") } } func f() { a := 10 b := 12 if a != b { // do something fmt.Println(\"a != b\") } } $ gocyclo gocyclo-test/main.go 3 main main gocyclo-test/main.go:8:1 2 main f gocyclo-test/main.go:24:1 ","date":"2024-04-19","objectID":"/posts/golang-linter/:4:3","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"III. bodyclose 在 Go 中，即使读取了所有的响应内容，也需要显式关闭响应体以释放资源，否则可能导致资源泄漏、连接池耗尽，进而影响应用性能。 bodyclose 主要关注于 HTTP 响应体的正确关闭，通过检查 resp.Body 是否被正确关闭。 它既可以单独使用，也可以集成到其他 linter 工具（例如 golangci-lint）中。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:5:0","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"安装 go install github.com/timakin/bodyclose@latest ","date":"2024-04-19","objectID":"/posts/golang-linter/:5:1","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"如何使用 bodyclose ? $ bodyclose bodyclose is a tool for static analysis of Go programs. Usage of bodyclose: bodyclose unit.cfg # execute analysis specified by config file bodyclose help # general help, including listing analyzers and flags bodyclose help name # help on specific analyzer and its flags 使用示例 这里展示借助 golangci-lint 的方式使用 bodyclose. // main.go package kyden import ( \"fmt\" \"io\" \"net/http\" ) func f() error{ resp, err := http.Get(\"http://example.com/\") if err != nil { return err } // defer resp.Body.Close() // \u003c\u003c\u003c body, err := io.ReadAll(resp.Body) fmt.Println(body) return nil } $ golangci-lint run --disable-all -E bodyclose main.go main.go:11:26: response body must be closed (bodyclose) resp, err := http.Get(\"http://example.com/\") 避免使用 http 库中 body 忘记 close 的更优方案是: 对 Go 官方提供的 http 进行封装，使调用方（Caller）不用显示调用 close 函数. package httpclient import ( \"io/ioutil\" \"net/http\" ) // Client 是一个自定义的 HTTP 客户端结构体 type Client struct { http.Client } // Get 封装了 http.Get 方法 func (c *Client) Get(url string) (string, error) { resp, err := c.Client.Get(url) if err != nil { return \"\", err } // 确保在函数返回时关闭响应体 defer resp.Body.Close() // 读取响应内容 body, err := ioutil.ReadAll(resp.Body) if err != nil { return \"\", err } return string(body), nil } ","date":"2024-04-19","objectID":"/posts/golang-linter/:5:2","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"IV. sqlrows 在 Go 的 database/sql 包中，sql.Rows 是一个 struct，用于表示从数据库查询中返回的多行结果。 它提供了一组方法，允许开发者逐行读取查询结果。 迭代结果：使用 Next() 方法逐行遍历结果集。 扫描数据：使用 Scan() 方法将当前行的列值复制到指定的变量中。 关闭结果集：使用 Close() 方法释放与结果集相关的资源。 sqlrows 的官方介绍： sqlrows is a static code analyzer which helps uncover bugs by reporting a diagnostic for mistakes of sql.Rows usage. ","date":"2024-04-19","objectID":"/posts/golang-linter/:6:0","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"安装 go install github.com/gostaticanalysis/sqlrows@latest ","date":"2024-04-19","objectID":"/posts/golang-linter/:6:1","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"如何使用 sqlrows ? $ sqlrows sqlrows is a tool for static analysis of Go programs. Usage of sqlrows: sqlrows unit.cfg # execute analysis specified by config file sqlrows help # general help sqlrows help name # help on specific analyzer and its flags Go 源码【注意 Not Good(NG) 处】 // main.go package kyden import ( \"context\" \"database/sql\" ) func f(ctx context.Context, db *sql.DB) (interface{}, error) { rows, err := db.QueryContext(ctx, \"SELECT * FROM users\") defer rows.Close() // NG: using rows before checking for errors if err != nil { return nil, err } // defer rows.Close() // NG: this return will not release a connection. for rows.Next() { err = rows.Scan() if err != nil { return nil, err } } return nil, nil } 针对两种 NG 的不同输出： go vet -vettool=$(which sqlrows) main.go # command-line-arguments ./main.go:10:11: using rows before checking for errors go vet -vettool=$(which sqlrows) main.go # command-line-arguments ./main.go:9:33: rows.Close must be called ","date":"2024-04-19","objectID":"/posts/golang-linter/:6:2","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"V. funlen funlen，用于检查函数的长度，确保函数的可读性和可维护性。 默认情况下，funlen 将函数的最大行数限制(lines)为 60 行，最大语句数(statements)限制为 40 条。 通常，funlen 会结合 golangci-lint 使用， 并集成到开发工作流中，提升代码质量. ","date":"2024-04-19","objectID":"/posts/golang-linter/:7:0","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"安装 funlen 可以通过 golangci-lint 安装: go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest ","date":"2024-04-19","objectID":"/posts/golang-linter/:7:1","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"如何使用 funlen ？ linters: disable-all: true enable: - funlen linters-settings: funlen: lines: 60 statements: 40 使用示例 // main.go package main import ( \"fmt\" ) func main() { f() } func f () { fmt.Println(\"Test funlen\") a := 1 fmt.Println(a) b := 1 fmt.Println(b) c := 1 fmt.Println(c) } 下面的 .golangci.yml 仅用于展示 funlen 的用法，具体参数请根据实际项目自行调整。 # .golangci.yml linters: disable-all: true enable: - funlen linters-settings: funlen: lines: 6 statements: 4 $ golangci-lint run main.go:12: Function 'f' has too many statements (7 \u003e 4) (funlen) ","date":"2024-04-19","objectID":"/posts/golang-linter/:7:2","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"VI. goconst goconst 会扫描代码，识别出在多个地方重复出现的字符串。 这些字符串通常是相同的文本，开发者通过将重复的字符串提取为常量，代码变得更加清晰，减少了硬编码的出现，降低了出错的可能性。 可以根据项目需求自定义 goconst 的行为，例如设置字符串的最小长度、最小出现次数等。 goconst 通常作为 golangci-lint 的一部分使用。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:8:0","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"如何使用 goconst ? linters: disable-all: true enable: - goconst linters-settings: goconst: min-len: 3 min-occurrences: 3 使用示例 // main.go package main import \"fmt\" func f() { a := \"Hello\" fmt.Println(a) b := \"Hello\" fmt.Println(b) c := \"Hello\" fmt.Println(c) } 下面的 .golangci.yml 仅用于展示 funlen 的用法，具体参数请根据实际项目自行调整。 # .golangci.yml linters: disable-all: true enable: - goconst linters-settings: goconst: min-len: 3 min-occurrences: 3 $ golangci-lint run main.go:7:10: string `Hello` has 3 occurrences, make it a constant (goconst) a := \"Hello\" ^ ","date":"2024-04-19","objectID":"/posts/golang-linter/:8:1","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"VII. ineffassign ineffassign，主要用于检测代码中对现有变量的赋值操作是否未被使用。 这种未使用的赋值通常是代码中的潜在错误，可能导致逻辑上的混乱或资源的浪费。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:9:0","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"如何使用 ineffassign ? 通常作为 golangci-lint 的一部分使用。 linters: disable-all: true enable: - ineffassign 使用示例 // main.go package main import \"fmt\" func f() { a := \"Hello\" // ... // Not assign a value to `a` // ... a = \"kyden\" fmt.Println(a) } $ golangci-lint run main.go:7:5: ineffectual assignment to a (ineffassign) a := \"Hello\" ^ ","date":"2024-04-19","objectID":"/posts/golang-linter/:9:1","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"VIII. lll 通过限制行的长度，lll 有助于确保代码在查看时不会横向滚动，提升代码的可读性。 lll，主要用于检查代码行的长度，检查每一行的长度是否超过指定的最大值。 默认情况下，lll 将最大行长度限制为 120 个字符。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:10:0","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"如何使用 lll ? lll 通常作为 golangci-lint 的一部分使用。 linters: disable-all: true enable: - lll linters-settings: lll: line-length: 80 使用示例 // main.go package kyden func f() int { a := \"This is a very long line that exceeds the maximum line length set by the linter and should be broken up into smaller, more manageable lines.\" return len(a) } golangci-lint run main.go:5: the line is 151 characters long, which exceeds the maximum of 80 characters. (lll) a := \"This is a very long line that exceeds the maximum line length set by the linter and should be broken up into smaller, more manageable lines.\" 解决方案 使用反引号（`）定义多行字符串，允许字符串跨越多行而不需要使用连接符 ","date":"2024-04-19","objectID":"/posts/golang-linter/:10:1","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"IX. errcheck errcheck，专门检查未处理的错误，确保开发者在调用可能返回错误的函数时，正确地检查和处理这些错误，从而提高代码的健壮性和可靠性。 errcheck 会扫描 Go 代码，查找未检查错误的地方 除了检查函数返回的错误,还可以检查类型断言是否被忽略 可以检查是否将错误赋值给了空白标识符 ","date":"2024-04-19","objectID":"/posts/golang-linter/:11:0","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"如何使用 ? errcheck 通常作为 golangci-lint 的一部分使用 linters-settings: errcheck: check-type-assertions: true # 检查类型断言是否被忽略,默认为 false check-blank: true # 检查是否将错误赋值给空白标识符,默认为 false disable-default-exclusions: true # 禁用默认的忽略函数列表,默认为 false exclude-functions: # 指定要忽略检查的函数列表 # ... 使用示例 // main.go package main import ( \"fmt\" ) func main() { hello(\"Kyden\") // err Not Check _ = hello(\"Kyden\") // err assign to _ err := hello(\"Go\") if err != nil { return } } func hello(str string) error { fmt.Printf(\"Hello, %s\", str) return nil } 下面的 .golangci.yml 仅用于展示 errcheck 的用法，具体参数请根据实际项目自行调整。 # .golangci.yml linters: disable-all: true enable: - errcheck linters-settings: errcheck: check-type-assertions: true check-blank: true golangci-lint run main.go:9:10: Error return value is not checked (errcheck) hello(\"Kyden\") // err Not Check ^ main.go:11:5: Error return value is not checked (errcheck) _ = hello(\"Kyden\") // err assign to _ ^ ","date":"2024-04-19","objectID":"/posts/golang-linter/:11:1","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"X. whitespace whitespace 是一个 Go 语言的 linter，主要用于检查代码中不必要的空行，即检查函数、条件语句（如 if、for）等开头和结尾的多余空行。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:12:0","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"如何使用 whitespace ? whitespace 也包含在 golangci-lint 中，只需在配置中启用即可。 linters: disable-all: true enable: - whitespace 使用示例 // main.go package main import ( \"fmt\" ) func main() { err := hello(\"Kyden\") if err != nil { return } } func hello(str string) error { if len(str) \u003c= 0 { return fmt.Errorf(\"str len \u003c= 0\") } fmt.Printf(\"Hello, %s\", str) return nil } $ gosrc golangci-lint run main.go:15:31: unnecessary leading newline (whitespace) ^ main.go:25:1: unnecessary trailing newline (whitespace) ^ main.go:17:23: unnecessary leading newline (whitespace) ^ ","date":"2024-04-19","objectID":"/posts/golang-linter/:12:1","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"XI. GolangCI-Lint 生产级静态分析工具 golangci-lint is a fast Go linters runner. It runs linters in parallel, uses caching, supports YAML configuration, integrates with all major IDEs, and includes over a hundred linters. golangci-lint 是一款快速的 Go 语言 linter，它并行运行多个 linter 程序，使用缓存，支持 YAML 配置，与所有主流集成开发环境集成，并包含一百多个 linter 程序。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:13:0","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"安装 go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest # Verify golangci-lint --version ","date":"2024-04-19","objectID":"/posts/golang-linter/:13:1","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"如何使用 golangci-lint ? 在不进行任何配置的情况下，GolangCI-Lint 将默认采用启动以下 Linters: errcheck, gosimple, govet, ineffassign, staticcheck, unused. 也可以通过传递 -E(--enable) 参数来启动 Linter，传递 -D(--disable) 来禁用 Linter. golangci-lint run --disable-all -E errcheck ","date":"2024-04-19","objectID":"/posts/golang-linter/:13:2","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"Visual Studio Code 集成 由于个人一直使用 VSCode 开发各种程序，这里只展示其如何集成 GolangCI-Lint。 Step 1. settings.json 启用 golangci-lint \"go.lintTool\": \"golangci-lint\", \"go.lintFlags\": [ \"--fast\" // Using it in an editor without --fast can freeze your editor. ] Step 2. 配置 .golangci.yml 当使用 Golangci-lint 时，它会自动在编辑的 Go 文件所在的目录或父目录中查找 .golangci.yml 配置文件。 如果找到了配置文件，Golangci-lint 就会根据该配置文件的设置来运行 linter。 因此，在 VS Code 的设置中，不需要专门配置 Golangci-lint。 只需要在项目根目录或相应的目录下创建 .golangci.yml 配置文件，并在其中指定需要启用的 linter 和相关选项即可。 Step 3. Enjoy your coding time 🥂 Golangci-lint 同样支持 GoLang、NeoVim 等流行 IDE 集成. ","date":"2024-04-19","objectID":"/posts/golang-linter/:13:3","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":".golangci.yml 参考配置 这里给出一个个人在用的 golangci-lint 完整配置文件，以供参考： run: timeout: 5m go: 1.21 linters-settings: funlen: lines: 150 statements: 100 goconst: min-len: 3 min-occurrences: 3 lll: line-length: 80 govet: # 对于linter govet，这里手动开启了它的某些扫描规则 shadow: true check-unreachable: true check-rangeloops: true check-copylocks: true # 启动nilness检测 enable: - nilness linters: disable-all: true enable: - bodyclose - errcheck - funlen - goconst - gocyclo - gofmt - goimports - gosimple - govet - ineffassign - lll - misspell # Go 静态分析工具，专注于检查代码中的拼写错误 - nilerr - rowserrcheck - staticcheck - typecheck - unconvert - unparam - unused - whitespace issues: skip-dirs: - test exclude-files: - _test.go 更多详细信息，请参考官方文档 ","date":"2024-04-19","objectID":"/posts/golang-linter/:13:4","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"XII. reviewdog A code review dog who keeps your codebase healthy. reviewdog 是一个用于自动化代码审查的工具，旨在通过集成各种 linter 工具来简化代码质量检查。它能够将 lint 工具的输出结果作为评论发布到代码托管服务（如 GitHub、GitLab 等），从而提高代码审查的效率和准确性。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:14:0","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"功能 自动发布评论：reviewdog 可以将 lint 工具的结果自动发布为评论，帮助开发者快速识别代码中的问题。 支持多种 linter：它支持多种静态分析工具，包括 golangci-lint、eslint、pylint 等，可以方便地集成到现有的开发流程中。 过滤输出：支持根据 diff 过滤 lint 工具的输出，只报告在当前变更中出现的问题。 多种报告模式：支持多种报告模式，如 GitHub PR 评论、GitHub Checks、GitLab 合并请求讨论等。 本地运行：除了在 CI/CD 环境中运行外，reviewdog 也可以在本地环境中使用，方便开发者在提交代码前进行检查。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:14:1","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"安装 # Install the latest version. (Install it into ./bin/ by default). $ curl -sfL https://raw.githubusercontent.com/reviewdog/reviewdog/master/install.sh | sh -s # Specify installation directory ($(go env GOPATH)/bin/) and version. $ curl -sfL https://raw.githubusercontent.com/reviewdog/reviewdog/master/install.sh | sh -s -- -b $(go env GOPATH)/bin [vX.Y.Z] # In alpine linux (as it does not come with curl by default) $ wget -O - -q https://raw.githubusercontent.com/reviewdog/reviewdog/master/install.sh | sh -s [vX.Y.Z] 推荐使用第二种安装方式 curl -sfL https://raw.githubusercontent.com/reviewdog/reviewdog/master/install.sh | sh -s -- -b $(go env GOPATH)/bin，具体安装实例如下： $ curl -sfL https://raw.githubusercontent.com/reviewdog/reviewdog/master/install.sh | sh -s -- -b $(go env GOPATH)/bin reviewdog/reviewdog info checking GitHub for latest tag reviewdog/reviewdog info found version: 0.20.1 for v0.20.1/Darwin/arm64 reviewdog/reviewdog info installed /Users/kyden/go/bin/reviewdog ","date":"2024-04-19","objectID":"/posts/golang-linter/:14:2","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"如何使用 reviewdog ? 本地使用 golangci-lint run ./... 2\u003e\u00261 | reviewdog -f=golangci-lint -reporter=local 官方示例 ","date":"2024-04-19","objectID":"/posts/golang-linter/:14:3","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"Github Action 1. 创建 GitHub Actions 工作流 在项目根目录下创建一个 GitHub Actions 工作流文件，.github/workflows/reviewdog.yml 2. 配置 .golangci.yml 在项目根目录下创建一个 .golangci.yml 配置文件，配置需要启用的 linter 3. 提交代码 当你提交代码并创建拉取请求时，GitHub Actions 会自动运行 reviewdog，并根据 lint 工具的输出在拉取请求中添加评论，指出代码中的问题。 更多内容请参考官方示例 ","date":"2024-04-19","objectID":"/posts/golang-linter/:14:4","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"XIII. Summary 综上所述，Golang 生态中有众多优秀的 Linter 工具，它们能够有效地检查代码质量，提高项目的可维护性和可靠性。 开发者可以根据项目需求，选择合适的 Linter 工具，并将其集成到 CI/CD 流程中，持续改善代码质量。 未来，随着 Golang 社区的不断发展，相信会有更多优秀的 Linter 工具问世，为 Golang 开发者提供更加强大的代码分析能力。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:15:0","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Go语言","开发工具","代码质量","持续集成","最佳实践"],"content":"XIV. Reference Cyclomatic complexity Gocyclo bodyclose sqlrows GolangCI-Lint static analysis reviewdog ","date":"2024-04-19","objectID":"/posts/golang-linter/:16:0","tags":["Go","Golang","Linter","代码检查","静态分析","代码质量","CI/CD","最佳实践","开发工具","工程实践"],"title":"Go 代码质量守护者：12 个必备 Linter 工具完全指南","uri":"/posts/golang-linter/"},{"categories":["Typora","Theme","Markdown","Software"],"content":" 导语 分享一个好看的 Typora 主题 ","date":"2024-04-18","objectID":"/posts/typora-theme/:0:0","tags":["Typora","Theme","Markdown","Software"],"title":"Typora Theme","uri":"/posts/typora-theme/"},{"categories":["Typora","Theme","Markdown","Software"],"content":"效果 本 Typora 软件主题是在 Purple 之上修改而来，具体效果如下： ","date":"2024-04-18","objectID":"/posts/typora-theme/:1:0","tags":["Typora","Theme","Markdown","Software"],"title":"Typora Theme","uri":"/posts/typora-theme/"},{"categories":["Typora","Theme","Markdown","Software"],"content":"Source 由于实现源码太长，给出下载连接：kyden.css @include-when-export url(https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400\u0026subset=latin,latin-ext); /* open-sans-regular - latin-ext_latin */ @font-face { font-family: \"Open Sans\"; font-style: normal; font-weight: normal; src: local(\"Open Sans Regular\"), local(\"OpenSans-Regular\"), url(\"./github/open-sans-v17-latin-ext_latin-regular.woff2\") format(\"woff2\"); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD, U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF; } /* open-sans-italic - latin-ext_latin */ @font-face { font-family: \"Open Sans\"; font-style: italic; font-weight: normal; src: local(\"Open Sans Italic\"), local(\"OpenSans-Italic\"), url(\"./github/open-sans-v17-latin-ext_latin-italic.woff2\") format(\"woff2\"); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD, U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF; } /* open-sans-700 - latin-ext_latin */ @font-face { font-family: \"Open Sans\"; font-style: normal; font-weight: bold; src: local(\"Open Sans Bold\"), local(\"OpenSans-Bold\"), url(\"./github/open-sans-v17-latin-ext_latin-700.woff2\") format(\"woff2\"); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD, U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF; } /* open-sans-700italic - latin-ext_latin */ @font-face { font-family: \"Open Sans\"; font-style: italic; font-weight: bold; src: local(\"Open Sans Bold Italic\"), local(\"OpenSans-BoldItalic\"), url(\"./github/open-sans-v17-latin-ext_latin-700italic.woff2\") format(\"woff2\"); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD, U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF; } :root { --title-color: #8064a9; --text-color: #444444; --light-text-color: #666666; --lighter-text-color: #888888; /* --link-color: #2aa899; */ /* --code-color: #745fb5; */ --link-color: #745fb5; /* --code-color: #2aa899; */ --code-color: #ec71b7; --shadow-color: #eee; --border-quote: rgba(116, 95, 181, 0.2); --border-quote-grey: #c8c8c8; --border: #e7e7e7; --link-bottom: #bbb; --shadow: 3px 3px 10px var(--shadow-color); --inline-code-bg: #f4f2f9; --header-weight: normal; --side-bar-bg-color: #fafafa; --control-text-color: var(var(--light-text-color)); --active-file-text-color: var(--title-color); --active-file-bg-color: var(--shadow-color); --item-hover-bg-color: var(--shadow-color); --active-file-border-color: var(var(--title-color)); --base-font: \"Open Sans\", \"Clear Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif; --title-font: \"EB Garamond\", \"Source Sans Pro\", serif; --monospace: Courier, Monospace !important; } /* 打印 */ @media print { html { font-size: 0.9rem; } table, pre { page-break-inside: avoid; } pre { word-wrap: break-word; } #write { max-width: 100%; } @page { size: A2; font-size: 0.2rem; /* PDF output size */ margin-left: 0; margin-right: 0; } } html { font-size: 16px; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; text-rendering: optimizelegibility; -webkit-font-smoothing: initial; } body { color: var(--text-color); -webkit-font-smoothing: antialiased; line-height: 1.6; letter-spacing: 0; overflow-x: hidden; } /* 页边距 和 页面大小 */ #write { font-family: var(--base-font); /* max-width: 914px; */ margin: 0 auto; padding: 1rem 4rem; padding-bottom: 100px; } #write p { line-height: 1.6rem; word-spacing: 0.05rem; } body\u003e*:first-child { margin-top: 0 !important; } body","date":"2024-04-18","objectID":"/posts/typora-theme/:2:0","tags":["Typora","Theme","Markdown","Software"],"title":"Typora Theme","uri":"/posts/typora-theme/"},{"categories":["Typora","Theme","Markdown","Software"],"content":"Reference Typora Purple ","date":"2024-04-18","objectID":"/posts/typora-theme/:3:0","tags":["Typora","Theme","Markdown","Software"],"title":"Typora Theme","uri":"/posts/typora-theme/"},{"categories":null,"content":"KYDEN 起源 奥地利心理学家阿德勒曾说：幸福的人用童年治愈一生，不幸的人用一生治愈童年。 生于华中地区的小农村，我有幸拥有一段无忧无虑的童年时光。 在那段岁月里，纸鸢翱翔于蓝天的画面，始终是最为深刻的记忆，也因此成为了我选择昵称的灵感源泉。 Kyden（纸鸢飞舞，鸢舞）巧妙融合了英文\"kite\"（风筝、纸鸢）与\"dance\"（舞蹈）的韵味。 这个名字宛如一首清雅的田园诗，描绘着纸鸢在碧空中舞动的优美姿态。 恰似一只古意盎然的纸鸢，乘着和煦的春风直上云霄，在湛蓝的天际间描绘出曼妙的弧线。 时而轻盈似蝶，跃然于云端；时而从容不迫，盘旋于苍穹。 每一个转折都是行云流水的诗画，每一次翻飞都是对浩渺天空的深情呢喃。 Kyden 不仅寄托着对自由与优雅的无限向往，更承载着如纸鸢般追逐梦想、翱翔九天的浪漫情怀。 它既是对诗意人生的礼赞，也是对广袤天际的深情寄语。 考虑到各大平台用户名的占用情况，我也会选用 kydance、kytedance 作为替代昵称，延续着纸鸢飞舞的诗意韵味。这些变体虽形式略有不同，却依然传递着同样的情思与意境。 ","date":"2024-04-18","objectID":"/about/:1:0","tags":null,"title":"关于KYDEN","uri":"/about/"},{"categories":null,"content":"Special Thanks Thanks to the authors of following resources included in the theme: Hugo: The world’s fastest framework for building websites FixIt: FixIt is a clean, elegant but advanced blog theme for Hugo. Gitalk: Gitalk is a modern comment component based on GitHub Issue and Preact. ","date":"2024-04-18","objectID":"/about/:2:0","tags":null,"title":"关于KYDEN","uri":"/about/"},{"categories":null,"content":"Timeline 收到 京东 意向函 2023-09-26收到 Tencent 录用意向书 2023-10-08收到 Tencent Offer 2023-11-20收到 京东 Offer 2023-11-21收到 快手 Offer 电话沟通 2023-12-14使用 Hugo 创建博客 2024-04-17完成研究生毕业设计答辩终稿 2024-05-29入职 Tencent -\u003e 开启人生新篇章（打工人） 2024-06-25迁移博客到 FixIt 主题 2025-01-04","date":"2024-04-18","objectID":"/about/:3:0","tags":null,"title":"关于KYDEN","uri":"/about/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"从系统安装到日常应用，从基础配置到性能优化，带你全面掌握 Arch Linux 的使用技巧，打造一个完美的开发环境。","date":"2024-04-17","objectID":"/posts/arch-linux/","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"I. Install Arch ","date":"2024-04-17","objectID":"/posts/arch-linux/:1:0","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"1. Download Arch Linux ISO archlinux-x86_64.iso ","date":"2024-04-17","objectID":"/posts/arch-linux/:1:1","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"2. U 盘 ventoy 准备 ventory 过程：略 选择 Arch Linux install medium (x86_64, UEFI) 启动安装环境 进入 root@archiso 后，需要设置互联网，推荐使用网线连接 检查网络接口是否已经启用 ip link # ... 2: enp0s3: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 ... # ... 尖括号内的“UP”，表示接口已经启用，否则使用以下命令：ip link set enp0s3 up 请使用 ping 命令测试网络: ping www.baidu.com ","date":"2024-04-17","objectID":"/posts/arch-linux/:1:2","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"3. 更新系统时钟 在互联网连接之后，systemd-timesyncd 服务将自动校准系统时间，便于安装软件包时验证签名 # Update system clock $ timedatectl ","date":"2024-04-17","objectID":"/posts/arch-linux/:1:3","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"4. 分区设置 $ mkfs.ext4 /dev/nvme1n1p7 #用作根分区，挂载到 / # mkfs.fat -F32 /dev/nvme1n1p3 #用作EFI分区 ，挂载到 /boot/efi # 如果安装Windows时已经有个EFI分区，就把上面的 /dev/nvme1n1p3 换成已有的EFI分区 $ mkfs.ext4 /dev/nvme1n1p8 # 挂载到 /home 目录 # mount $ mount /dev/nvme1n1p7 /mnt $ mkdir -p /mnt/boot/efi $ mount /dev/nvme1n1p1 /mnt/boot/efi $ mount --mkdir /dev/nvme1n1p8 /mnt/home ","date":"2024-04-17","objectID":"/posts/arch-linux/:1:4","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"5. 选择软件镜像仓库 手动修改 /etc/pacman.d/mirrorlist，添加相关镜像 $ vim /etc/pacman.d/mirrorlist Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch # Update keyring $ pacman -Sy archlinuxcn-keyring $ pacman -Syyu ","date":"2024-04-17","objectID":"/posts/arch-linux/:1:5","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"6. 安装基础包 $ pacstrap /mnt bash base base-devel linux linux-headers linux-firmware neovim xsel # fstab $ genfstab -U -p /mnt \u003e\u003e /mnt/etc/fstab ","date":"2024-04-17","objectID":"/posts/arch-linux/:1:6","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"7. chroot -\u003e 设置系统属性 切换系统 # chroot $ arch-chroot /mnt 设置时区 # Set time zone $ ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime $ hwclock --systohc 修改 hostname $ vim /etc/hostname arch 设置 locale $ vim /etc/locale.conf `LANG_en_US.UTF-8` $ vim /etc/locale.gen en_US.UTF-8 UTF-8 # 取消注释 zh_CN.UTF-8 UTF-8 # 取消注释 $ locale-gen 网络管理器，蓝牙, 音频 # Install and enable NetworkManager, bluetooth, audio $ pacman -S networkmanager bluez bluez-utils pulseaudio-bluetooth alsa-utils pulseaudio pulseaudio-alsa sof-firmware $ systemctl enable NetworkManager.service $ systemctl enable bluetooth.service 设置 password # Set password $ passwd 引导相关 # ucode $ cat /proc/cpuinfo | grep \"model name\" $ pacman -S intel-ucode # amd-ucode # 安装引导加载程序 $ pacman -S grub efibootmgr os-prober $ grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB # 配置 os-prober $ vim /etc/default/grub GRUB_DISABLE_OS_PROBER=false # 取消注释 $ grub-mkconfig -o /boot/grub/grub.cfg Create user and usergroup $ useradd -m -G wheel kyden # 为新用户 kyden 设置 passwd # 修改权限 $ pacman -S sudo man-pages man-db $ vim /etc/sudoers %wheel ALL=(ALL:ALL) ALL # 取消注释 # 切换至 kyden 用户 $ su - kyden 桌面程序 - KDE # KDE $ sudo pacman -S plasma xorg nvidia dolphin konsole fish noto-fonts-cjk noto-fonts-emoji $ sudo systemctl enable sddm # reboot $ exit $ swapoff /mnt/swapfile $ umount -R /mnt $ reboot ","date":"2024-04-17","objectID":"/posts/arch-linux/:1:7","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"II. Software ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:0","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"Test NetworkManager # Test networkManager $ ping baidu.com $ systemctl enable NetworkManager ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:1","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"pacman 镜像修改 $ sudo vim /etc/pacman.conf # Misc options Color ParallelDownloads = 5 [multilib] Include = /etc/pacman.d/mirrorlist # 键入： [archlinuxcn] Server = https://mirrors.utsc.edu.cn/archlinuxcn/$arch $ sudo pacman -Syyu $ sudo pacman -S archlinuxcn-keyring ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:2","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"常见通用软件 $ yay -S fish # curl -L https://get.oh-my.fish | fish $ fish_config # 取消问候语 $ set -U fish_greeting \"\" $ sudo vim /etc/systemd/system/clash.service $ sudo systemctl daemon-reload $ sudo systemctl enable clash $ sudo systemctl start clash $ sudo systemctl status clash $ sudo pacman -S obs-studio 输入法 fcitx5 $ sudo pacman -S fcitx5 fcitx5-configtool fcitx5-qt fcitx5-gtk fcitx5-chinese-addons fcitx5-material-color fcitx5-pinyin-moegirl fcitx5-pinyin-zhwiki $ sudo vim /etc/environment GTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=\\@im=fcitx # 为了让一些使用特定版本 SDL2 库的游戏能正常使用输入法 SDL_IM_MODULE=fcitx $ yay -S clash-verge-rev-bin $ yay -Sy neofetch google-chrome obs-studio baidunetdisk \\ nutstore-experimental xunlei-bin telegram-desktop \\ gitkraken visual-studio-code-bin typora-free redis \\ net-tools pot-translation translate-shell okular \\ snipaste gwenview kcalc wemeet-bin vlc wget ark \\ shotcut inkscape ninja gnu-netcat tcpdump cmake \\ clang tree python-pip caj2pdf-qt ttf-hack-nerd \\ transmission-gtk gpick speedcrunch drawio-desktop \\ zeal electronic-wechat-uos-bin \\ linuxqq lx-music-desktop gpick: 可以从桌面任何地方取色，并且它还提供一些其它的高级特性 SpeedCrunch: 一个漂亮，开源，高精度的科学计算器 Snipaste: 截图工具，如不可用可选用spectacle drawio-desktop: Security-first diagramming for teams zeal：离线文档浏览器 trans-shell 基础用法 # 翻译到locale语言 $ trans [Words] # 翻译到指定语言 $ trans :zh [word] # 翻译到多种目标语言 $ trans :zh+ja word # 翻译句子和短语 $ trans en:zh \"word processor\" $ trans :zh \"To-morrow, and to-morrow, and to-morrow,\" # 简洁模式：默认情况下，Translate Shell 尽可能多的显示翻译信息。如果你希望只显示简要信息，只需要加上 -b选项。 $ trans -b :zh \"Saluton, Mondo\" $ trans -b :@ja \"Saluton, Mondo\" #显示发音符号，如果有的话，如日语罗马音，汉语拼音 # 翻译文件或网页 $ trans :zh file://\u003cinput.txt\u003e $ trans :zh https://github.com/kydance/ # 进入交互模式 $ trans -shell $ trans -shell en:fr Alais tsbz 'trans -b :zh' tsz 'trans :zh' tsbe 'trans -b :en' tse 'trans :en' office # Install WPS $ yay -S wps-office wps-office-mui-zh-cn ttf-wps-fonts ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:3","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"远程工具 - Remmina $ yay -S remmina freerdp 使用教程 安装 freerdp 插件后，可以走 RDP 协议远程 Win10（Win10 不需要其他任何设置） ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:4","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"Git 配置 git 设置user.name和user.emal $ git config --global user.name \"kyden\" $ git config --global user.email xxxxxx@gmail.com # Verify $ git config --list 生成密钥 # 要求多次输入密码，可不要输入密码 $ ssh-keygen -t rsa -C 'xxxxxx@gmail.com' GitHub 配置 SSH Keys 打开生成的 Key 文件 ~/.ssh/id_rsa.pub: cat ~/.ssh/id_rsa.pub 复制全部内容，在 Key 中粘贴 Git 常用命令 git status git clone git pull git push git commit -m 'commits' or git commit -m 'commits' kyden.go git add . or git kyden.go git reflog Git实现从本地添加项目到远程仓库 Steps: GitHub 上创建一个新的远程仓库 - Create a new repo -\u003e Create repository 本地仓库：创建并初始化 -\u003e 添加待上传到远程仓库的项目文件 git init 远程仓库和本地仓库关联 git remote add origin git@github.com:kydance/\u003crepository name\u003e 项目文件添加、提交、推送 由于远程库是空的，我们第一次 push master 分支时，加上了 -u 参数，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来 在以后的 push 或者 pull 时就可以简化命令 git add file $ git commit -m '\u003ccommit statements\u003e' file $ git push -u origin master 用 SSH 密钥在一台机器上管理多个账户 1. 检查一下我们是否有任何现有的 SSH 密钥 ls -al ~/.ssh 这将列出所有现有的公钥和私钥对，如果 ~/.ssh/id_rsa 是可用的，我们可以重新使用它，否则 ssh-keygen -t rsa 生成一个默认 ~/.ssh/id_rsa 的密钥. 通过以上方法，我们可以得到两个不同的密钥： id_rsa id_rsa.pub id_rsa_kyden id_rsa_kyden.pub 2. 将不同 SSH 密钥添加到相应的 GitHub 账户中 复制公钥 ~/.ssh/id_rsa.pub 的内容，将密钥粘贴在 Settings -\u003e SSH and GPG keys -\u003e New SSH key 的方框中即可 3. 在 ssh-agent 上注册新的 SSH 密钥 创建并编辑 SSH 配置文件 ~/.ssh/config Host kyden HostName github.com User git IdentityFile ~/.ssh/id_rsa_kyden Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa 注意更换 Host 当你克隆一个仓库或为本地仓库设置 remote origin 时，确保与你使用的主机名记号一致 (@ 和 : 之间的字符串应该与我们在 SSH 配置文件中给出的内容相匹配）: # git clone git@github.com:kydance/dotfiles.git git clone git@kyden:kydance/dotfiles.git 4. 为本地仓库设置 user GitHub 会根据提交（commit）描述所附的电子邮件 ID 来识别任何提交的作者. 一旦我们克隆/创建了本地的 Git 仓库，确保 Git 配置的 user.name 和 user.email 正是你想要的 ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:5","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"Golang # Download and install go $ sudo pacman -S go $ vim .config/fish/config.sh # Set environment variable in `.config/fish/config.sh` or `/etc/profile` or `~/.profile` GOROOT /usr/lib/go GOPATH /home/kyden/goProj GOBIN /home/kyden/goProj/bin PATH $GOPATH/bin $GOROOT/bin $GOBIN $PATH GOROOT，设置 Golang 的安装位置 GOBIN，执行 go install 后生成可执行文件的目录 GOPATH，工作目录，一般设置到用户目录下 ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:6","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"MySQL 很多 Linux 发行版都放弃了对 MySQL 的支持（原因自行 Google）转而支持 mariadb（MySQL的另一个分支），Arch Linux就是其中之一，mariadb 具有和 MySQL 一模一样的操作命令，所以完全不用考虑迁移兼容的问题 安装mariadb: # install $ sudo pacman -Sy mariadb 配置 mariadb 命令，创建数据库都在 /var/lib/mysql/ 目录下面: # Config $ sudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql 开启mariadb 服务: # Enable service $ systemctl start mariadb 初始化密码，期间有让你设置密码的选项，设置你自己的密码就行了，然后根据自己需要 y/n 就可，因为很多后面可以再修改: # Set password $ sudo /usr/bin/mysql_secure_installation 登录mariadb 和mysql命令是一样的: # Test $ mysql -u root -p 设置开机自启动服务: # Enable $ systemctl enable mariadb ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:7","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"挂载其他硬盘分区 # Get UUID and TYPE $ sudo blkid # eg: # /dev/nvme1n1p3: LABEL=\"Document\" BLOCK_SIZE=\"512\" UUID=\"111915F1111915F1\" TYPE=\"ntfs\" PARTLABEL=\"Basic data partition\" PARTUUID=\"666266ba-233b-11ed-95be-00e04c3656eb\" # Write UUID TYPE ... $ sudo vim /etc/fstab # \u003cdevice\u003e \u003cdir\u003e \u003ctype\u003e \u003coptions\u003e \u003cdump\u003e \u003cfsck\u003e UUID=111915F1111915F1 /home/kyden/doc ntfs3 defaults 0 0 \u003cdevice\u003e 描述要挂载的特定块设备或远程文件系统 \u003cdir\u003e 描述挂载目录 \u003ctype\u003e 文件系统类型 \u003coptions\u003e 相关的挂载选项 \u003cdump\u003e 会被 dump(8) 工具检查。该字段通常设置为 0, 以禁用检查 \u003cfsck\u003e 设置引导时文件系统检查的顺序; 对于 root 设备该字段应该设置为 1。对于其它分区该字段应该设置为 2,或设置为 0 以禁用检查 NOTE: TYPE 为 ntfs 时导致启动失败，修改为 ntfs3 后成功挂载 ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:8","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"Present Windows ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:9","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"picgo picgo-core Download and Install PigGo-Core Get token with GitHub Configure NOTE：使用时，将注释删掉，以免产生不必要的麻烦 // ~/.picgo/config.json { \"picBed\": { \"current\": \"github\", \"github\": { \"repo\": \"\u003cuserName\u003e/PicBed\", // 设定仓库名：上文在 GitHub 创建的仓库 `\u003cuserName\u003e/PicBed` \"branch\": \"master\", // 设定分支名：`master` \"token\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\", // 设定 Token：上文生成的 toke \"path\": \"\", // 指定存储路径：为空的话会上传到根目录，也可以指定路径 \"customUrl\": \"\" // 设定自定义域名：可以为空 }, \"uploader\": \"github\", \"transformer\": \"path\" }, \"picgoPlugins\": { \"picgo-plugin-github-plus\": true } } ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:10","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"CUDA \u0026 cuDNN # install $ yay -S cuda-11.7 cudnn8-cuda11.0 Arch Linux 会将 CUDA 相关档案安装至 /opt/cuda，有需要的话可以将 CUDA 的 PATH 加到 ~/bashrc，此路径永远指向最新版CUDA # ~/.fish_config set PATH /opt/cuda-11.7/bin $PATH set LD_LIBRARY_PATH /opt/cuda-11.7/lib64/ $PATH pip install torch==1.13.1+cu117 torchvision==0.14.1+cu117 torchaudio==0.13.1 --extra-index-url https://download.pytorch.org/whl/cu117 ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:11","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"Clash Verge DNS 泄露问题 DNS 泄露其实并没有一个明确的定义，也不存在一个官方解释。 举个例子，当你在访问一个需要代理才能访问的域名时（例如 YouTube，Netflix 等黑名单网站），在获取其 IP 的过程中，没有使用代理的 DNS 服务器解析，而是使用当前网络环境的 DNS 服务器解析，这个过程就是所谓的 DNS 泄露，存在隐私问题泄漏的风险。 如果在 DNS Leak Test 、ipleak这种网站的列表中看到了中国国旗，就要意识到可能发生了DNS泄露。 虽然没有人知道具体的探测机制是什么，但很可能是从网络层面获取的。在一般的家庭网络拓扑中，wireshark可以看到什么内容，运营商就能看见什么内容，所以你使用114.114.114.114、223.5.5.5这样的DNS解析去访问了什么网站是很清晰的。 Clash开启TUN模式，关闭系统代理去使用：与普通的系统代理模式区别在于，TUN模式下Clash会创建一张虚拟网卡，从网络层面接管所有的网络流量。 开启TUN模式 使用稳定的DNS DNS这部分有人会教使用运营商的DNS，运营商的DNS只适合小白用户，因为他可能连反诈，所以建议使用国内大厂的。 [Optional] 关闭浏览器的QUIC, 中国大陆的isp是限速udp的, 所以导致QUIC这个优秀的协议, 到了中国大陆的网络下成了个负面增益效果。 about://flags/#enable-quic 设置为Disabled (点下方弹出的重启浏览器生效) 关闭浏览器中的“安全DNS” chrome://settings/security 在Clash Verge的【Profiles】中，点右上角的\"NEW\" -\u003e Type选择\"Script\" -\u003e Name随意填写(例如，“修改DNS”) 右击新建的文件，然后\"Edit File\"，输入以下内容后启用： function main(content) { const isObject = (value) =\u003e { return value !== null \u0026\u0026 typeof value === 'object' } const mergeConfig = (existingConfig, newConfig) =\u003e { if (!isObject(existingConfig)) { existingConfig = {} } if (!isObject(newConfig)) { return existingConfig } return { ...existingConfig, ...newConfig } } const cnDnsList = [ 'tls://223.5.5.5', 'tls://1.12.12.12', ] const trustDnsList = [ 'https://doh.apad.pro/dns-query', 'https://dns.cooluc.com/dns-query', 'https://1.0.0.1/dns-query', ] const notionDns = 'tls://dns.jerryw.cn' const notionUrls = [ 'http-inputs-notion.splunkcloud.com', '+.notion-static.com', '+.notion.com', '+.notion.new', '+.notion.site', '+.notion.so', ] const combinedUrls = notionUrls.join(','); const dnsOptions = { 'enable': true, 'default-nameserver': cnDnsList, // 用于解析DNS服务器 的域名, 必须为IP, 可为加密DNS 'nameserver-policy': { [combinedUrls]: notionDns, 'geosite:geolocation-!cn': trustDnsList, }, 'nameserver': trustDnsList, // 默认的域名解析服务器, 如不配置fallback/proxy-server-nameserver, 则所有域名都由nameserver解析 } // GitHub加速前缀 const githubPrefix = 'https://ghproxy.lainbo.com/' // GEO数据GitHub资源原始下载地址 const rawGeoxURLs = { geoip: 'https://github.com/MetaCubeX/meta-rules-dat/releases/download/latest/geoip-lite.dat', geosite: 'https://github.com/MetaCubeX/meta-rules-dat/releases/download/latest/geosite.dat', mmdb: 'https://github.com/MetaCubeX/meta-rules-dat/releases/download/latest/country-lite.mmdb', } // 生成带有加速前缀的GEO数据资源对象 const accelURLs = Object.fromEntries( Object.entries(rawGeoxURLs).map(([key, githubUrl]) =\u003e [key, `${githubPrefix}${githubUrl}`]), ) const otherOptions = { 'unified-delay': true, 'tcp-concurrent': true, 'profile': { 'store-selected': true, 'store-fake-ip': true, }, 'sniffer': { enable: true, sniff: { TLS: { ports: [443, 8443], }, HTTP: { 'ports': [80, '8080-8880'], 'override-destination': true, }, }, }, 'geodata-mode': true, 'geox-url': accelURLs, } content.dns = mergeConfig(content.dns, dnsOptions) return { ...content, ...otherOptions } } 设置完成后，验证DNS解析结果是否都是来自国外的Cloudflare和Google的DNS, 这时节点服务器不管拿到了你传过去的真ip地址还是假ip地址, 他都会再去请求一次Cloudflare/Google的DNS服务, 确保解析的正确性。 重要的是没有中国大陆的DNS服务器了，如果还是有，那你应该往当前设备的更上层寻找问题所在，比如路由器的设置等。 GEOIP，CN问题 目前市面上绝大多数的代理工具都依赖于 GeoIP2 数据库判断地址所属地。它们的规则结尾部分一般都会有一条类似 GEOIP, CN，用来查询目的 IP 地址是否属于中国大陆，从而判断是否直连。 这些代理工具通常使用的 GeoIP2 数据库是来自于 MaxMind 的 GeoLite2 免费数据库。这个数据库目前存在一下几个问题： 获取不便：从 2019 年 12 月 30 日起，必须注册后才能下载 数据量大：数据库庞大，包含全球的 IP 地址段，约 10 MB 准确度低：对中国大陆的 IP 地址判定不准，如：香港阿里云的 IP 被判定为新加坡、中国大陆等。 庞大的数据量对于大多数中国大陆的用户来说是没有意义的，因为只仅需要去判断 IP 的地理位置是否属于中国大陆境内，其他国家的 IP 一律代理/直连。过多的数据量会增加载入时间，降低查询效率。 我们在之前创建的Script中已经包含了下载更精简合适中国大陆的IP数据库链接, 现在只需要手动操作下载和替换即可: Update GeoData: Clash Verge Rev的设置菜单中点击Update GeoData 验证下载: 打开Clash Verge托盘中的APP Dir，找到geoip.dat文件，验证其大小是否为几百KB 重启Clash Verge：确保数据库被正确应用 ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:12","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"III. 内核更换 Install The Desired Kernel # linux-lts linux-lts-headers $ sudo pacman -S linux-lts linux-lts-headers Editing GRUB Config File $ sudo vim /etc/default/grub GRUB_DISABLE_SUBMENU=y # disables the GRUB submenu, i.e., it enables all the available kernels to be listed on the main GRUB Menu itself instead of the “Advanced option for Arch Linux” option. GRUB_DEFAULT=saved # saves the last kernel used GRUB_SAVEDEFAULT=true # makes sure that grub uses the last selected kernel is used as default Re-Generate GRUB Configuration file # grub-mkconfig $ sudo grub-mkconfig -o /boot/grub/grub.cfg Choose Kernel From GRUB During Boot. 🥂 ","date":"2024-04-17","objectID":"/posts/arch-linux/:3:0","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"IV. System optimization ","date":"2024-04-17","objectID":"/posts/arch-linux/:4:0","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"SSD 优化 TRIM, 会帮助清理SSD中的块，从而延长SSD的使用寿命 # SSD Optimal $ sudo systemctl enable fstrim.timer $ sudo systemctl start fstrim.timer ","date":"2024-04-17","objectID":"/posts/arch-linux/:4:1","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"SWAP 设置 https://wiki.archlinux.org/title/Swap#Swappiness 查看 swap 使用率，一般是 60 ，意思是 60% 的概率将内存整理到 swap: cat /proc/sys/vm/swappiness 修改 swap 使用策略为 10%，即 10% 的概率将内存整理到 swap: sudo sysctl -w vm.swappiness=10 修改配置文件：sudo vim /etc/sysctl.d/99-swappiness.conf 在文件末尾加上下面这行内容：vm.swappiness=10 重启后可查看 swappiness 的值 ","date":"2024-04-17","objectID":"/posts/arch-linux/:4:2","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"Systemd journal size limit 控制日志最大可使用多少磁盘空间，修改/etc/systemd/journald.conf 中的SystemMaxUse参数 SystemMaxUse=50M ","date":"2024-04-17","objectID":"/posts/arch-linux/:4:3","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"V. Problem And Solution ","date":"2024-04-17","objectID":"/posts/arch-linux/:5:0","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"1. clear command - terminals database is inaccessible 解决方案： Path for Anaconda3 is set in .bashrc. It is interfering with the clear command. Removing Anaconda path from path solved the issue. $ echo $CONDA_PREFIX /opt/miniconda $sudo mv $CONDA_PREFIX/bin/clear $CONDA_PREFIX/bin/clear_old ","date":"2024-04-17","objectID":"/posts/arch-linux/:5:1","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"2. tput: unknown terminal \"xterm-256color\" 解决方案： # setenv $ setenv TERMINFO /usr/lib/terminfo ","date":"2024-04-17","objectID":"/posts/arch-linux/:5:2","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"3. 更新内核后，双屏显示时，某一个屏幕黑屏，但鼠标能够移动过去并显示，另一屏幕正常 解决方案： xrandr --output HDMI-1-0 --right-of eDP1 --auto 命令解释：配置 HDMI-1-0 输出，使其位于 eDP1 输出的右侧，并自动选择最佳的分辨率和刷新率设置 $ xrandr --listmonitors Monitors: 2 0: +*eDP1 2560/360x1440/200+0+0 eDP1 1: +HDMI-1-0 1920/479x1080/260+2560+0 HDMI-1-0 $ xrandr --output HDMI-1-0 --right-of eDP1 --auto ","date":"2024-04-17","objectID":"/posts/arch-linux/:5:3","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"4. zip 压缩包解压乱码 产生这种情况的原因是，zip 格式本身的缺陷导致的： zip 格式没有指定文件名的编码格式，因此在压缩和解压时都会采用操作系统本地编码， Windows 下简体中文采用的是 GBK/GB312 编码，而 Linux 采用的是 UTF-8 编码，两者不一致导致了乱码的产生。 解决方案: # Use `-O GBK` $ unzip -O GBK xxx.zip ","date":"2024-04-17","objectID":"/posts/arch-linux/:5:4","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"5. wps-office大部分字体粗体出现过粗无法正常显示问题 问题: freetype2 更新至 2.13.0 以上版本后出现的问题，导致 wps-office 文档编辑文字大部分字体设置粗体出现过粗无法正常显示。 解决方案： freetype2 降级至 2.13.0 Download freetype2.13.0 降级 sudo pacman -U freetype2-2.13.0-1-x86_64.pkg.tar.zst 修改 /etc/pacman.conf -\u003e IgnorePkg = freetype2，排除掉这个包（不让它更新） freetype2: ignoring package upgrade (2.13.0-1 =\u003e 2.13.2-1) # update $ env LD_LIBRARY_PATH=/usr/local/freetype2-2.13.0-1-x86_64/usr/lib $ update-desktop-database ~/.local/share/applications ","date":"2024-04-17","objectID":"/posts/arch-linux/:5:5","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"6. wpspdf 无法打开 PDF 文件 wpspdf 依赖于 libtiff5.so.5 以支撑其 PDF 功能。 而系统更新后，Arch Linux 提供的是 libtiff.so.6 或更新版本，导致其无法正常工作。 解决方案： 安装 libtiff5 ","date":"2024-04-17","objectID":"/posts/arch-linux/:5:6","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"7. WPS 无法输入中文 解决方案 - wpp wpspdf wpp et ","date":"2024-04-17","objectID":"/posts/arch-linux/:5:7","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["Linux系统","系统配置","开发环境","系统管理","最佳实践"],"content":"8. lx-music 数据同步失败 解决方案 确保PC端的同步服务已启用成功: 若连接码、同步服务地址没有内容，则证明服务启动失败，此时看启用同步功能复选框后面的错误信息自行解决 在手机浏览器地址栏输入http://x.x.x.x:5963/hello后回车，若此地址可以打开并显示 Hello~::-::v4，则证明移动端与PC端网络已互通， 若移动端无法打开第2步的地址，则在PC端的浏览器地址栏输入并打开该地址，若可以打开，则可能性如下： LX Music PC端被电脑防火墙拦截 PC端与移动端不在同一个网络下， 路由器开启了AP隔离（一般在公共网络下会出现这种情况） 要验证双方是否在同一个网络或是否开启AP隔离，可以在电脑打开cmd使用ping命令ping移动端显示的ip地址，若可以通则说明网络正常 ","date":"2024-04-17","objectID":"/posts/arch-linux/:5:8","tags":["Arch Linux","Linux","系统安装","系统配置","开发环境","系统优化","系统管理","桌面环境","包管理","最佳实践"],"title":"从零开始的 Arch Linux 完全上手指南：打造你的理想工作环境","uri":"/posts/arch-linux/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"通过 Hugo 和 GitHub Pages 快速搭建个人博客网站的完整教程，包含从环境配置、主题选择到部署发布的全过程详解。","date":"2024-04-17","objectID":"/posts/build-blog/","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":" 导语 想要拥有一个专业的技术博客，但又担心过程繁琐？本文将教你如何利用 Hugo 的快速建站框架，结合 GitHub Pages 的免费托管服务，在短短 30 分钟内搭建一个美观实用的个人博客网站。无需购买服务器，零基础也能轻松驾驭！ ","date":"2024-04-17","objectID":"/posts/build-blog/:0:0","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"I. 前言 在博客网站搭建完成之后，有充分的理由相信，自己在未来很长一段时间内将不会再次重复建站。 常言道天有不测风云，为了防止各种意外情况发生，导致本博客网站无法正常使用，同时防止自己忘记搭建流程，记录于此。 ","date":"2024-04-17","objectID":"/posts/build-blog/:1:0","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"II. 效果 ","date":"2024-04-17","objectID":"/posts/build-blog/:2:0","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"III. 相关知识简介 ","date":"2024-04-17","objectID":"/posts/build-blog/:3:0","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"Github Pages GitHub Pages 是一个免费的静态网站托管服务，它允许用户通过 GitHub 存储库来托管和发布网页，可以使用它来展示项目文档、博客或个人简历。 现阶段，Github Pages 支持公共存储库的免费的托管；对于私有仓库，需要进行缴费。 ","date":"2024-04-17","objectID":"/posts/build-blog/:3:1","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"Hugo 官方号称，Hugo 是世界上最快的网站建设框架(The world’s fastest framework for building websites)。 ","date":"2024-04-17","objectID":"/posts/build-blog/:3:2","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"IV. Steps ","date":"2024-04-17","objectID":"/posts/build-blog/:4:0","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"1. Github 仓库创建 需要创建两个仓库，一个用于网站源码管理(A)，一个用于网站部署(B): A 可以是 public，也可以是 private； B 仓库的名称必须是 \u003cusername\u003e.github.io（username 是 Github Accout 中username，不是 profile 中的 Name），同时还需要添加 README.md，例如：kydance.github.io. ","date":"2024-04-17","objectID":"/posts/build-blog/:4:1","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"2. 使用 Hugo 创建网站 首先，使用 Git 将 A 拉取下来： $ git clone git@github.com:kydance/blog.git # ... 然后，进入本地的 A 目录（即，blog）下，使用 hugo 建站： # Linux: Install Hugo $ sudo pacman -S hugo # Verify $ hugo version # 建站，然后将生成的内容复制到 `A` 仓库中 $ hugo new blog $ mv blog/ . $ rm -rf blog ","date":"2024-04-17","objectID":"/posts/build-blog/:4:2","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"3. Hugo 设置网站主题 可以从 Hugo Themes 挑选合适的主题进行应用： $ cd themes $ git clone https://github.com/kakawait/hugo-tranquilpeak-theme.git tranquilpeak # ... 安装 Hugo 主题后，根据个人情况修改相应的配置文件即可； ","date":"2024-04-17","objectID":"/posts/build-blog/:4:3","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"4. 文章管理 启动 Hugo server 启动本地 server： $ hugo server -D Watching for changes in /Users/kyden/git-space/kyden-blog/{archetypes,assets,content,i18n,layouts,static} Watching for config changes in /Users/kyden/git-space/kyden-blog/config.toml Start building sites … hugo v0.139.3+extended+withdeploy darwin/arm64 BuildDate=2024-11-29T15:36:56Z VendorInfo=brew WARN Current environment is \"development\". The \"comment system\", \"CDN\" and \"fingerprint\" will be disabled. 当前运行环境是 \"development\". \"评论系统\", \"CDN\" 和 \"fingerprint\" 不会启用. | EN -------------------+------ Pages | 303 Paginator pages | 2 Non-page files | 62 Static files | 86 Processed images | 0 Aliases | 135 Cleaned | 0 Built in 436 ms Environment: \"development\" Serving pages from disk Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 浏览器打开 http://localhost:1313/ 进行预览； 新建文章 # `post/Golang/Go.md` 表明 markdown 的路径 $ hugo new content `post/Golang/Go.md` 一键创建文章: ./new-blog.sh \u003cname\u003e #!/bin/bash CONTENT_PATH=posts/ # Welcome to the new-blog.sh script! echo -e \"\\033[0;32mCreating new blog post...\\033[0m\" # Check if the user has provided an argument if [ $# -ne 1 ] then echo -e \"\\033[0;31mMissing one argument, Usage: new-blog.sh \u003cblog-name\u003e\\033[0m\"; exit; fi # Get the blog name from the user CONTENT_PATH=$CONTENT_PATH$1/$1.md echo -e \"\\033[0;32mBlog path: $CONTENT_PATH\\033[0m\" # Create the new blog post hugo new content $CONTENT_PATH # Success echo -e \"\\033[0;32mCreate new blog post $CONTENT_PATH successful.\\033[0m\" 部署文章 构建 Hugo 网站相关静态文件 Hugo 将构建完成的静态内容保存到 A 仓库中的 public 文件夹中； $ hugo # ... 部署 进入 public 目录，利用 Git 进行管理该文件夹，并推送到远程 B 仓库中： $ git init $ git commit -m \"first commit\" $ git branch -M master $ git remote add origin https://github.com/kydance/kydance.github.io.git $ git push -u origin master # ... 自动化一键部署：deploy.sh #!/bin/bash echo -e \"\\033[0;32mDeploying updates to GitHub...\\033[0m\" # Build the project. hugo # if using a theme, replace with hugo -t # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\"rebuilding site `date` \" echo -e \"\\033[0;32m$msg\\033[0m\" if [ $# -eq 1 ] then msg=\"$1\" fi git commit -m \"$msg\" # Push source and build repos. git push origin master # Come Back up to the Project Root cd .. 删除文章 进入 blog/posts/ 目录中，删除，目标文件夹（包含相关文章资源）即可； NOTE：blog/public 中相关文件可以删除，也可以不删除，推荐删除； ","date":"2024-04-17","objectID":"/posts/build-blog/:4:4","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"5. 网站图标 把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 realfavicongenerator 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. avatar头像 在 gavatar 网站注册并上传图片即可 ","date":"2024-04-17","objectID":"/posts/build-blog/:4:5","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"6. Google Analytics 首先，在 Google Analytics 网站中注册、设置完成相应选项，即可获取 ID：G-XXXXXXXXXX； 然后在 layout/_default/baseof.html 文件中添加以下代码即可： \u003c!-- Google tag (gtag.js) --\u003e \u003cscript async src=\"https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX\"\u003e\u003c/script\u003e \u003cscript\u003e window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-XXXXXXXXXX'); \u003c/script\u003e 该段代码获取方法如下： Google Analytics -\u003e 管理 -\u003e “媒体资源设置\"列中的数据流 -\u003e 网站 -\u003e 对应的数据流 -\u003e “Google 代码” 下的查看代码说明 -\u003e “安装说明” 选择手动添加. 建议添加完成后，在 Google Analytics 分析中进行测试，确保生效 ","date":"2024-04-17","objectID":"/posts/build-blog/:4:6","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"7. Gitalk 评论系统 Gitalk 的评论采用的是 PR/Issue 的方式存储评论，因此，一般需要新建一个专门的 Repo，例如kydance/gitalk. GitHub 申请注册新应用，并填写以下相关内容： Application name: 随意 Homepage URL: 包含 http/https 前缀，例如https://kydance.github.io Authorization callback URL: 和上面 Homepage URL 保持一致就行 注册完成后，手动生成 Client secrets(只会出现一次)，同时获得 Client ID. 最后，在主题设置中填写相应信息即可，例如 LoveIt 中的 config.toml: [params.page.comment] enable = true [params.page.comment.gitalk] enable = true owner = \"lutianen\" repo = \"gitalk\" clientId = \"xxxxxxxxxxxxxxxxxxxx\" clientSecret = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" ","date":"2024-04-17","objectID":"/posts/build-blog/:4:7","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"8. 网站运行时间统计 在 footer.html 加入以下内容即可： {{- /* runtime */ -}} \u003c/br\u003e\u003cscript\u003e function siteTime() { var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var today = new Date(); var startYear = 2024; var startMonth = 4; var startDate = 18; var startHour = 12; var startMinute = 57; var startSecond = 2; var todayYear = today.getFullYear(); var todayMonth = today.getMonth() + 1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond); var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond); var diff = t2 - t1; var diffYears = Math.floor(diff / years); var diffDays = Math.floor((diff / days) - diffYears * 365); var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours); var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes); var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds); if (startYear == todayYear) { document.getElementById(\"sitetime\").innerHTML = \"已安全运行 \" + diffDays + \" 天 \" + diffHours + \" 小时 \" + diffMinutes + \" 分钟 \" + diffSeconds + \" 秒\"; } else { document.getElementById(\"sitetime\").innerHTML = \"已安全运行 \" + diffYears + \" 年 \" + diffDays + \" 天 \" + diffHours + \" 小时 \" + diffMinutes + \" 分钟 \" + diffSeconds + \" 秒\"; } } setInterval(siteTime, 1000); \u003c/script\u003e \u003cspan id=\"sitetime\"\u003e载入运行时间...\u003c/span\u003e ","date":"2024-04-17","objectID":"/posts/build-blog/:4:8","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"V. 主题扩展 ","date":"2024-04-17","objectID":"/posts/build-blog/:5:0","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"Link kydance.github.io https://kydance.github.io ","date":"2024-04-17","objectID":"/posts/build-blog/:5:1","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"Admonition This is a note NOTE This is a abstract ABSTRACT This is a info INFO This is a tip TIP This is a success SUCCESS This is a question QUESTION This is a warning WARNING This is a failure FAILURE This is a danger danger This is a bug BUG This is a example EXAMPLE This is a quote QUOTE ","date":"2024-04-17","objectID":"/posts/build-blog/:5:2","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"Video ","date":"2024-04-17","objectID":"/posts/build-blog/:5:3","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"VI. Problem And Solution ","date":"2024-04-17","objectID":"/posts/build-blog/:6:0","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"添加图片不显示 Hugo 的配置文件和文章中的引用图片都是以 static 作为根目录，因此图片无法显示的解决方案如下： 将图片放入 static/img 目录下 在文章中的图片引用方式为：/img/xxx.png 无法采用 Typora 等软件进行预览，需要在网页中进行预览: http://localhost:1313/ ","date":"2024-04-17","objectID":"/posts/build-blog/:6:1","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"文章缩略 如果想要文章在某个地方缩略，只需要在该位置加入 \u003c!--more--\u003e 即可。 ","date":"2024-04-17","objectID":"/posts/build-blog/:6:2","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"},{"categories":["网站建设","博客系统","静态网站","网站部署","最佳实践"],"content":"VII. References Abot Github Pages Hugo Gitalk 评论系统安装 参考文章 ","date":"2024-04-17","objectID":"/posts/build-blog/:7:0","tags":["Hugo","博客搭建","静态网站","网站建设","主题开发","网站部署","SEO优化","个人博客","技术博客","最佳实践"],"title":"30分钟搭建个人技术博客：Hugo + GitHub Pages 零基础建站指南","uri":"/posts/build-blog/"}]