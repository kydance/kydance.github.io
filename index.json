[{"categories":["tmux","Guide","Tools\""],"content":" 导语 Tmux，一款优秀的终端复用工具，使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机 ","date":"2024-10-03","objectID":"/posts/tmux-guide/:0:0","tags":["tmux","Guide","Tools\""],"title":"Tmux Guide","uri":"/posts/tmux-guide/"},{"categories":["tmux","Guide","Tools\""],"content":"Feature 强劲的、易于使用的命令行界面 可以横向、纵向分割窗口 窗格可以自由移动和调整大小，或直接利用四个预设布局之一 支持 UTF-8 编码及 256 色终端 可在多个缓冲区进行复制和粘贴 可通过交互式菜单来选择窗口、会话及客户端 支持跨窗口搜索 支持自动及手动锁定窗口 可以自由配置绑定快捷键 ","date":"2024-10-03","objectID":"/posts/tmux-guide/:1:0","tags":["tmux","Guide","Tools\""],"title":"Tmux Guide","uri":"/posts/tmux-guide/"},{"categories":["tmux","Guide","Tools\""],"content":"Tmux 中的 server, session, window 和 Pane 在 Tmux 系统中，存在以下极其重要的大小层级: Server -\u003e Session -\u003e Window -\u003e Pane. Server: 整个 tmux 的后台服务. NOTE: 当配置文件不生效时，就需要使用 tmux kill-server 来重启 Tmux Session: 可以理解为 workplace Window: 相当于 VIM 中的buffer Pane: 窗口中的小分屏，相当于 VIM 中的 split / vsplit ","date":"2024-10-03","objectID":"/posts/tmux-guide/:2:0","tags":["tmux","Guide","Tools\""],"title":"Tmux Guide","uri":"/posts/tmux-guide/"},{"categories":["tmux","Guide","Tools\""],"content":"Installation Require: version \u003e= 2.1 ","date":"2024-10-03","objectID":"/posts/tmux-guide/:3:0","tags":["tmux","Guide","Tools\""],"title":"Tmux Guide","uri":"/posts/tmux-guide/"},{"categories":["tmux","Guide","Tools\""],"content":"Linux yum install -y tmux yay -S tmux apt-get install tmux ","date":"2024-10-03","objectID":"/posts/tmux-guide/:3:1","tags":["tmux","Guide","Tools\""],"title":"Tmux Guide","uri":"/posts/tmux-guide/"},{"categories":["tmux","Guide","Tools\""],"content":"Mac brew install tmux ","date":"2024-10-03","objectID":"/posts/tmux-guide/:3:2","tags":["tmux","Guide","Tools\""],"title":"Tmux Guide","uri":"/posts/tmux-guide/"},{"categories":["tmux","Guide","Tools\""],"content":"常用命令 Tmux 的默认 prefix-key 是 \u003cC-b\u003e ","date":"2024-10-03","objectID":"/posts/tmux-guide/:4:0","tags":["tmux","Guide","Tools\""],"title":"Tmux Guide","uri":"/posts/tmux-guide/"},{"categories":["tmux","Guide","Tools\""],"content":"启动新 session $ tmux [new -s sessionName -n windowName] # e.g. tmux new -s kyden -n nvim ","date":"2024-10-03","objectID":"/posts/tmux-guide/:4:1","tags":["tmux","Guide","Tools\""],"title":"Tmux Guide","uri":"/posts/tmux-guide/"},{"categories":["tmux","Guide","Tools\""],"content":"恢复 Session tmux at[-t sessionName] ","date":"2024-10-03","objectID":"/posts/tmux-guide/:4:2","tags":["tmux","Guide","Tools\""],"title":"Tmux Guide","uri":"/posts/tmux-guide/"},{"categories":["tmux","Guide","Tools\""],"content":"Session List tmux ls ","date":"2024-10-03","objectID":"/posts/tmux-guide/:4:3","tags":["tmux","Guide","Tools\""],"title":"Tmux Guide","uri":"/posts/tmux-guide/"},{"categories":["tmux","Guide","Tools\""],"content":"关闭 Session tmux kill-session -t sessionName ","date":"2024-10-03","objectID":"/posts/tmux-guide/:4:4","tags":["tmux","Guide","Tools\""],"title":"Tmux Guide","uri":"/posts/tmux-guide/"},{"categories":["tmux","Guide","Tools\""],"content":"关闭整个 tmux 服务器 tmux kill-server ","date":"2024-10-03","objectID":"/posts/tmux-guide/:4:5","tags":["tmux","Guide","Tools\""],"title":"Tmux Guide","uri":"/posts/tmux-guide/"},{"categories":["tmux","Guide","Tools\""],"content":"Session Command prefix-key command description \u003cC-b\u003e ? 显示快捷键帮助文档 \u003cC-b\u003e d 断开当前 Session \u003cC-b\u003e r 强制重载当前 Session \u003cC-b\u003e : 进入命令模式，可直接输入命令 ","date":"2024-10-03","objectID":"/posts/tmux-guide/:4:6","tags":["tmux","Guide","Tools\""],"title":"Tmux Guide","uri":"/posts/tmux-guide/"},{"categories":["tmux","Guide","Tools\""],"content":"Window Command prefix-key command description \u003cC-b\u003e c 新建窗口 \u003cC-b\u003e \u0026 关闭当前窗口 \u003cC-b\u003e p / n / \u003cnumber\u003e 切换到上一个 / 下一个 / 指定窗口 \u003cC-b\u003e w 打开窗口列表，用于切换窗口 \u003cC-b\u003e , 重命名当前窗口 \u003cC-b\u003e . 修改窗口编号 ","date":"2024-10-03","objectID":"/posts/tmux-guide/:4:7","tags":["tmux","Guide","Tools\""],"title":"Tmux Guide","uri":"/posts/tmux-guide/"},{"categories":["tmux","Guide","Tools\""],"content":"Pane Command prefix-key command description \u003cC-b\u003e \" / % 新建上下 / 左右 pane \u003cC-b\u003e x 关闭当前 pane \u003cC-b\u003e z 最大化当前 pane(重复取消最大化) \u003cC-b\u003e q 显示面板编号，在编号消失前输入对应的数字可切换到相应的面板 \u003cC-b\u003e \u003cleft\u003e / \u003cright\u003e / up / down 移动光标切换面板 \u003cC-b\u003e o 选择下一 pane \u003cC-b\u003e \u003cspace\u003e 在自带的面板布局中循环切换 ","date":"2024-10-03","objectID":"/posts/tmux-guide/:4:8","tags":["tmux","Guide","Tools\""],"title":"Tmux Guide","uri":"/posts/tmux-guide/"},{"categories":["tmux","Guide","Tools\""],"content":"配置文件 配置文件 .tmux.conf 通常位于 ~/.tmux.conf 处，可输入 restart tmux 进行 mtum 重启 # recover colorful terminal set -g default-terminal \"xterm-256color\" # 窗口面板起始序列号 set -g base-index 1 set -g pane-base-index 1 # 从tmux v1.6版起，支持设置第二个指令前缀，使用 ` 作为第二指令前缀 # set-option -g prefix2 ` # (Tmux v2.1) 支持鼠标: 选取文本、调整面板大小、选中并切换面板 set-option -g mouse on # 状态栏窗口名称格式 set -wg window-status-format \" #I #W \" # 状态栏当前窗口名称格式(#I：序号，#w：窗口名称，#F：间隔符) set -wg window-status-current-format \" #I:#W#F \" # 状态栏窗口名称之间的间隔 set -wg window-status-separator \"\" # 开启vi风格后，支持vi的C-d、C-u、hjkl等快捷键 setw -g mode-keys vi # 绑定 Escape 进入 复制 模式 bind Escape copy-mode setw -g automatic-rename off setw -g allow-rename off ","date":"2024-10-03","objectID":"/posts/tmux-guide/:5:0","tags":["tmux","Guide","Tools\""],"title":"Tmux Guide","uri":"/posts/tmux-guide/"},{"categories":["Golang","配置文件","YAML","Viper"],"content":" 导语 对于一个 Go 应用程序，同城需要解析以下类别的配置：命令行选项、命令行参数、配置文件，而对于一个非命令行工具的应用程序，不需要考虑读取命令行参数这类场景，其需要的配置内容都可以通过命令行选项或配置文件加载到程序中。 Tips 命令行工具可能会有子命令，例如 kubectr create 中的 create 就是一个命令行参数 ","date":"2024-09-22","objectID":"/posts/go-viper/:0:0","tags":["Golang","配置文件","YAML","Viper"],"title":"Go 如何优雅地读取配置？","uri":"/posts/go-viper/"},{"categories":["Golang","配置文件","YAML","Viper"],"content":"为何选择配置文件作为配置项的读取方式？ 对于一个配置项，既可以通过命令行选项，又能够通过配置文件来读取，而且二者是一个彼此可以取代的，因此，对于非命令行工具的应用程序个人更倾向于通过配置文件完成，原因如下： 配置文件更易部署：可以将应用所需要的所有配置聚合在一个配置文件中。 当需署时，只需要部署、加载这个配置文件即可，不需要配置一大堆命令行选项； 配置文件更易维护：将所有的配置项都保存在配置文件中，加上详细的配置说明，不需要的配置项可以注释掉。 一个具有全量配置项、详细说明的配置文件，更易于理解。并且在修改时，只需要修改配置项的值，而不需要修改配置项名称，更不易出错； 配置文件可以实现热加载功能：应用程序监听配置文件的变更，有变更时，自动重新加载配置文件，实现配置热加载功能； 配置层次表达更清晰：命令行参数无法直接表达\"层次\"，但配置文件可以。层次化的配置表达，更易于理解，也更易于维护。 方便新增配置项：多数情况下，配置项新增只需在配置文件中新增一行即可，不需要修改源码； 总结 命令行工具可能会有子命令，例如 kubectr create 中的 create 就是一个命令行参数 总结：当配置项少的时候（比如 5 个以内），可以从命令行选项中读取。 参数较多的时候，建议使用配置文件，配置文件更易部署、维护、热加载、层次表达更清晰。 ","date":"2024-09-22","objectID":"/posts/go-viper/:1:0","tags":["Golang","配置文件","YAML","Viper"],"title":"Go 如何优雅地读取配置？","uri":"/posts/go-viper/"},{"categories":["Golang","配置文件","YAML","Viper"],"content":"为何选择 YAML 作为配置文件的格式？ 当打算采用配置文件来读取配置项时，那么就存在多种文件格式，例如：JSON、YAML、TOML、INI 等。 个人推荐使用 YAML，理由如下： YAML 语法简单、格式易读、程序易处理； YAML 格式可以表达非常丰富、复杂的配置结构； YAML 格式普适性高，新人零理解成本； 最终配置：使用 YAML 格式的配置文件，并采用 viper 来读取配置 ","date":"2024-09-22","objectID":"/posts/go-viper/:2:0","tags":["Golang","配置文件","YAML","Viper"],"title":"Go 如何优雅地读取配置？","uri":"/posts/go-viper/"},{"categories":["Golang","配置文件","YAML","Viper"],"content":"使用 viper 读取配置文件内容 在 浅析现代化命令行框架 Cobra 中，我们了解到可以通过 cobra-cli init --viper 生成一个通过 viper 来配置应用程序的 Demo 应用，那么就可以知道它的应用加载逻辑如下： /* Copyright © 2024 Kyden \u003ckytedance@gmail.com\u003e This file is part of CLI application foo. */ package cmd import ( \"fmt\" \"os\" \"github.com/spf13/cobra\" \"github.com/spf13/viper\" ) var cfgFile string // rootCmd represents the base command when called without any subcommands var rootCmd = \u0026cobra.Command{ Use: \"kydendemo\", Short: \"A brief description of your application\", Long: `A longer description that spans multiple lines and likely contains examples and usage of using your application. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application.`, // Uncomment the following line if your bare application // has an action associated with it: // Run: func(cmd *cobra.Command, args []string) { }, } // Execute adds all child commands to the root command and sets flags appropriately. // This is called by main.main(). It only needs to happen once to the rootCmd. func Execute() { err := rootCmd.Execute() if err != nil { os.Exit(1) } } func init() { cobra.OnInitialize(initConfig) // Here you will define your flags and configuration settings. // Cobra supports persistent flags, which, if defined here, // will be global for your application. rootCmd.PersistentFlags().StringVar( \u0026cfgFile, \"config\", \"\", \"config file (default is $HOME/.kydendemo.yaml)\") // Cobra also supports local flags, which will only run // when this action is called directly. rootCmd.Flags().BoolP(\"toggle\", \"t\", false, \"Help message for toggle\") } // initConfig reads in config file and ENV variables if set. func initConfig() { if cfgFile != \"\" { // Use config file from the flag. viper.SetConfigFile(cfgFile) } else { // Find home directory. home, err := os.UserHomeDir() cobra.CheckErr(err) // Search config in home directory with name \".kydendemo\" (without extension). viper.AddConfigPath(home) viper.SetConfigType(\"yaml\") viper.SetConfigName(\".kydendemo\") } viper.AutomaticEnv() // read in environment variables that match // If a config file is found, read it in. if err := viper.ReadInConfig(); err == nil { fmt.Fprintln(os.Stderr, \"Using config file:\", viper.ConfigFileUsed()) } } 其中，rootCmd 设置了命令行选项 --config，用于指定配置文件路径，默认值是 \"\"； 通过 cobra.OnInitialize(initConfig) 设置了 kydendemo 在运行时的回调函数 initConfig， 它的执行逻辑主要是： 如果指定了 cfgFile，则直接读取该配置文件； 如果没有指定，则读取 $HOME/.kydendemo.yaml，找到则读取； 若 cfgFile == \"\"，且没有找到配置文件，则调用 viper.ReadInConfig() 读取配置文件时报错； ","date":"2024-09-22","objectID":"/posts/go-viper/:3:0","tags":["Golang","配置文件","YAML","Viper"],"title":"Go 如何优雅地读取配置？","uri":"/posts/go-viper/"},{"categories":["Golang","配置文件","YAML","Viper"],"content":"Reference viper ","date":"2024-09-22","objectID":"/posts/go-viper/:4:0","tags":["Golang","配置文件","YAML","Viper"],"title":"Go 如何优雅地读取配置？","uri":"/posts/go-viper/"},{"categories":["现代化","命令行","框架","Cobra","CLI"],"content":" 导语 Cobra 是一个可以创建强大的现代化 CLI 应用程序库，它还提供了一个可以生成应用和命令文件的程序的命令行工具：cobra-cli. ","date":"2024-09-21","objectID":"/posts/go-cobra/:0:0","tags":["现代化","命令行","框架","Cobra","CLI"],"title":"浅析现代化命令行框架 Cobra","uri":"/posts/go-cobra/"},{"categories":["现代化","命令行","框架","Cobra","CLI"],"content":"I. Cobra 简介 Cobra 是一个可以创建强大的现代化 CLI 应用程序库，它还提供了一个可以生成应用和命令文件的程序的命令行工具：cobra-cli。 许多大型项目（e.g. kubernetes, Docker, Etcd, Rkt, Hugo etc.）都采用了 cobra 来构建他们的应用程序。 Cobra 具有很多特性，一些核心特性如下： 可以构建基于子命令的 CLI，并支持嵌套子命令：app server, app fetch 可以通过 cobra-cli init appname \u0026 cobra-cli add cmdname 轻松生成应用和子命令 智能化命令建议：app srver...did you mean app server 自动生成命令和标志的 helpe 文本，并能自动识别 -h, --help 等标志 自动为应用程序生成 bash、zsh、fish、powershell 自动补全脚本 支持命令别名、自定义帮助、自定义用法等 可以与 viper、pflag 紧密集成，用于构建 12-factor 应用程序 Cobra 建立在 commands、arguments 和 flags 结构之上。Commands 代表命令，arguments 代表非选项参数，flags 代表选项参数（标志）。 CLI 模式 一个好的应用程序应该是易懂的，用户可以清晰知道如何去使用这个应用程序，因此通常遵循如下模式： APPNAME VERB NOUN --ADJECTIVE 或者 APPNAME COMMAND ARG --FLAG，例如： # clone 是一个 Commands # URL 是一个非选项参数 # bare 一个选项参数 git clone URL --bare NOTE：VERB 代表动词，NOUN 代表名词，ADJECTIVE 代表形容词 ","date":"2024-09-21","objectID":"/posts/go-cobra/:1:0","tags":["现代化","命令行","框架","Cobra","CLI"],"title":"浅析现代化命令行框架 Cobra","uri":"/posts/go-cobra/"},{"categories":["现代化","命令行","框架","Cobra","CLI"],"content":"II. cobra-cli 命令安装 Cobra 提供了 cobra-cli 命令，用来初始化一个应用程序并为其添加命令，方便开发基于 Cobra 的应用，可用以下方法进行安装： $ go install github.com/spf13/cobra-cli@latest # ... cobra-cli 提供了 4 个子命令： init: 初始化一个 cobra 应用程序 add: 给通过 cobra init 创建的应用程序添加子命令 completion: 为指定的 shell 生成命令自动补全脚本 help: 打印任意命令的帮助信息 cobra-cli 还提供了一些全局参数： -a, --author: 指定 Copyright 版权声明中的作者 --config: 指定 cobra 配置文件的路径 -l, --license: 指定生成的应用程序所使用的开源协议，内置的有：GPLv2, GPLv3, LGPL, AGPL, MIT, 2-Clause BSD or 3-Clause BSD； --viper: 使用 viper 作为命令行参数解析工具，默认为 true。 ","date":"2024-09-21","objectID":"/posts/go-cobra/:2:0","tags":["现代化","命令行","框架","Cobra","CLI"],"title":"浅析现代化命令行框架 Cobra","uri":"/posts/go-cobra/"},{"categories":["现代化","命令行","框架","Cobra","CLI"],"content":"III. Cobra 使用 在构建 cobra 应用时，可以自行组织代码目录结构，但 cobra 建议如下目录结构： $ tree app_name app_name ├── cmd │ ├── add.go │ ├── create.go │ └── list.go └── main.go main.go 文件的目的只有一个：初始化 cobra 应用程序并注册子命令 package main import ( \"{pathtToApp}/cmd\" ) func main() { cmd.Execute() } ","date":"2024-09-21","objectID":"/posts/go-cobra/:3:0","tags":["现代化","命令行","框架","Cobra","CLI"],"title":"浅析现代化命令行框架 Cobra","uri":"/posts/go-cobra/"},{"categories":["现代化","命令行","框架","Cobra","CLI"],"content":"使用 cobra-cli 命令生成应用程序并添加子命令 可以选择使用 cobra-cli 命令行工具快速生成一个应用程序，并添加子命令，然后基于生成的代码进行二次开发，提高开发效率，具体方法如下： 1. 初始化应用程序 使用 cobra-cli init 命令初始化一个应用程序，然后就可以基于这个 Demo 进行二次开发，提高开发效率： $ mkdir -p kyden-demo \u0026\u0026 cd kydne-demo \u0026\u0026 go mod init kyden-demo $ cobra-cli init --license=MIT --viper $ ls cmd go.mod go.sum LICENSE main.go 2. 添加子命令 当一个应用程序初始化完成之后，就可以使用 cobra-cli add 命令添加一些命令： $ cobra-cli add serve $ cobra-cli add config $ cobra-cli add create -p 'configCmd' # 此命令的父命令的变量名（默认为 'rootCmd'） $ tree kyden-demo kyden-demo ├── LICENSE ├── cmd │ ├── config.go │ ├── create.go │ ├── root.go │ └── serve.go ├── go.mod ├── go.sum └── main.go 执行 cobra-cli add 命令之后，会在 cmd 目录下生成命令源码文件。 cobra-cli 不仅可以添加命令，也可以添加子命令，例如 cobra-cli add create -p 'configCmd' 给 config 命令添加了 create 子命令，-p 指定子命令的父命令：\u003c父命令\u003eCmd. 3. 编译运行 在生成命令后，可以直接执行 go build 命令编译应用程序： $ go build -v . $ ./kyden-demo -h A longer description that spans multiple lines and likely contains examples and usage of using your application. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application. Usage: kyden-demo [command] Available Commands: completion Generate the autocompletion script for the specified shell config A brief description of your command help Help about any command serve A brief description of your command Flags: --config string config file (default is $HOME/.kyden-demo.yaml) -h, --help help for kyden-demo -t, --toggle Help message for toggle Use \"kyden-demo [command] --help\" for more information about a command. 4. 配置 cobra cobra 在生成应用程序时，也会在当前目录下生成 LINCENSE 文件，并且会在生成的 Go 源码文件中中，添加 LINCENSE Header。 LINCENSE 和 LINCENSE Header 的内容可以通过 cobra 配置文进行配置，默认配置文件 ~/.cobra.yaml: $ cat ~/.cobra.yaml author: Kyden \u003ckytedance@gmail.com\u003e year: 2024 license: header: This file is part of CLI application foo. text: | {{ .copyright }} This is my license. There are many like it, but this one is mine. My license is my best friend. It is my life. I must master it as I must master my life. $ cobra-cli init Copyright © 2024 Kyden \u003ckytedance@gmail.com\u003e This is my license. There are many like it, but this one is mine. My license is my best friend. It is my life. I must master it as I must master my life. {{ .copyright }} 的具体内容会根据 author 和 year 生成，根据此配置生成的 LICENSE 文件内容. 也可以使用内建的 licenses，内建的 licenses 有：GPLv2, GPLv3, LGPL, AGPL, MIT, 2-Clause BSD or 3-Clause BSD。 ","date":"2024-09-21","objectID":"/posts/go-cobra/:3:1","tags":["现代化","命令行","框架","Cobra","CLI"],"title":"浅析现代化命令行框架 Cobra","uri":"/posts/go-cobra/"},{"categories":["现代化","命令行","框架","Cobra","CLI"],"content":"使用 cobra 库创建命令 当使用 cobra 库编码实现一个应用程序，需要首选创建一个空的 main.go 文件和一个 rootCmd 文件，然后根据需要添加其他命令。 具体步骤如下： 创建 rootCmd $ mkdir -p cobrademo \u0026\u0026 cobrademo $ go mod init cobrademo go: creating new go.mod: module cobrademo go: to add module requirements and sums: go mod tidy $ cobra-cli init Using config file: /Users/kyden/.cobra.yml Your Cobra application is ready at /tmp/cobrademo 通常情况下，会将 rootCmd 放在 cmd/root.go 文件中 /* Copyright © 2024 Kyden \u003ckytedance@gmail.com\u003e This file is part of CLI application foo. */ package cmd import ( \"os\" \"github.com/spf13/cobra\" ) // rootCmd represents the base command when called without any subcommands var rootCmd = \u0026cobra.Command{ Use: \"cobrademo\", Short: \"A brief description of your application\", Long: `A longer description that spans multiple lines and likely contains examples and usage of using your application. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application.`, Run: func(cmd *cobra.Command, args []string) { // Do stuff here }, } // Execute adds all child commands to the root command and sets flags appropriately. // This is called by main.main(). It only needs to happen once to the rootCmd. func Execute() { err := rootCmd.Execute() if err != nil { os.Exit(1) } } func init() { // Here you will define your flags and configuration settings. // Cobra supports persistent flags, which, if defined here, // will be global for your application. // rootCmd.PersistentFlags().StringVar(\u0026cfgFile, \"config\", \"\", \"config file (default is $HOME/.cobrademo.yaml)\") // Cobra also supports local flags, which will only run // when this action is called directly. rootCmd.Flags().BoolP(\"toggle\", \"t\", false, \"Help message for toggle\") } 还可以在 init() 函数中定义标志和处理配置，例如：cmd/helper.go: 创建 main.go 还需要一个 main 函数来调用 rootCmd，通常会创建一个 main.go 文件，在 main.go 中调用 rootCmd.Execute() 来执行命令： package main import ( \"{pathToApp}/cmd\" ) func main() { cmd.Execute() } 在 main.go 中不建议放太多代码，通常只需要调用 cmd.Execute() 即可 添加命令 除了 rootCmd，还可以调用 AddCommand() 来添加其他命令，通常情况下，会把其他命令的源码文件放在 cmd 目录下，例如添加一个 version 命令（cmd/version.go）： /* Copyright © 2024 Kyden \u003ckytedance@gmail.com\u003e This file is part of CLI application foo. */ package cmd import ( \"fmt\" \"github.com/spf13/cobra\" ) // versionCmd represents the version command var versionCmd = \u0026cobra.Command{ Use: \"version\", Short: \"A brief description of your command\", Long: `A longer description that spans multiple lines and likely contains examples and usage of using your command. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application.`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"version called\") }, } func init() { rootCmd.AddCommand(versionCmd) // Here you will define your flags and configuration settings. // Cobra supports Persistent Flags which will work for this command // and all subcommands, e.g.: // versionCmd.PersistentFlags().String(\"foo\", \"\", \"A help for foo\") // Cobra supports local flags which will only run when this command // is called directly, e.g.: // versionCmd.Flags().BoolP(\"toggle\", \"t\", false, \"Help message for toggle\") } 编译运行 $ go build -v . $ ./cobrademo -h A longer description that spans multiple lines and likely contains examples and usage of using your application. For example: Cobra is a CLI library for Go that empowers applications. This application is a tool to generate the needed files to quickly create a Cobra application. Usage: cobrademo [flags] cobrademo [command] Available Commands: completion Generate the autocompletion script for the specified shell help Help about any command helper A brief description of your command version A brief description of your command Flags: -h, --help help for cobrademo -t, --toggle Help message for toggle Use \"cobrademo [command] --help\" for more information about a command. ","date":"2024-09-21","objectID":"/posts/go-cobra/:3:2","tags":["现代化","命令行","框架","Cobra","CLI"],"title":"浅析现代化命令行框架 Cobra","uri":"/posts/go-cobra/"},{"categories":["现代化","命令行","框架","Cobra","CLI"],"content":"使用标志 cobra 可以跟 pflag 结合使用，实现强大的标志功能。 具体步骤如下： 使用持久化的标志 标志是可以\"持久化\"的，即该标志可用于它所分配的命令以及该命令下的每个子命令。 例如，在 rootCmd 中定义持久化标志： rootCmd.PersistentFlags().BoolVarP(\u0026Verbose, \"verbose\", \"v\", false, \"verbose output\") 使用本地标志 本地标志，只能在其所绑定的命令上使用： rootCmd.Flags().StringVarP(\u0026Source, \"source\", \"s\", \"\", \"Source directory to read from\") 上面的 --source 标志智能在 rootCmd 命令上引用，而不能在 rootCmd 的子命令上引用。 将标志绑定到 viper 可以讲标志绑定到 viper，这样就可以使用 viper.Get() 获取标志的值。 var auther string func init() { rootCmd.PersistentFlags().StringVar( \u0026auther, \"author\", \"Your Name\", \"Author name for copyright attribution\") viper.BindPFlag(\"author\", rootCmd.PersistentFlags().Lookup(\"auther\")) } 设置标志为必选 默认情况下，标志是可选的，也可以设置标志为必选。 当设置标志为必选时，若不提供标志时，cobra 会报错： rootCmd.Flags().StringVarP(\u0026Region, \"region\", \"r\", \"\", \"AWS region (required)\") rootCmd.MarkFlagRequired(\"region\") ","date":"2024-09-21","objectID":"/posts/go-cobra/:3:3","tags":["现代化","命令行","框架","Cobra","CLI"],"title":"浅析现代化命令行框架 Cobra","uri":"/posts/go-cobra/"},{"categories":["现代化","命令行","框架","Cobra","CLI"],"content":"IV. Reference cobra ","date":"2024-09-21","objectID":"/posts/go-cobra/:4:0","tags":["现代化","命令行","框架","Cobra","CLI"],"title":"浅析现代化命令行框架 Cobra","uri":"/posts/go-cobra/"},{"categories":["regex","Regular Expression","正则表达式","入门","Go"],"content":" 导语 正则表达式, 是一种小型的、高度专业化的编程语言 ","date":"2024-09-15","objectID":"/posts/regex-in-one/:0:0","tags":["regex","Regular Expression","正则表达式","入门","Go"],"title":"浅析 Regular Expression (正则表达式)","uri":"/posts/regex-in-one/"},{"categories":["regex","Regular Expression","正则表达式","入门","Go"],"content":"I. 何谓正则表达式 正则表达式(Regular Expression，常简写为 regex、regexp、RE)，又称规律表达式、模式表达式、正则表达式、常规表达式，是计算机科学概念，用简单字符串来描述、匹配文中全部匹配指定格式的字符串，现在很多文本编辑器都支持用正则表达式搜索、取代匹配指定格式的字符串。 总之, Regex 是一种小型的、高度专业化的编程语言, 它被用来检索、替换那些符合某个模式(规则)的文本。 一个正则表达式通常被称为一个模式（pattern），为用来描述或者匹配一系列匹配某个句法规则的字符串. 正则表达式是由普通字符(例如字符 a 到 z)以及特殊字符(称为 “元字符” )组成的文字模式。 模式描述在搜索文本时要匹配的一个或多个字符串。 正则表达式作为一个模板, 将某个字符模式与所搜索的字符串进行匹配。 ","date":"2024-09-15","objectID":"/posts/regex-in-one/:1:0","tags":["regex","Regular Expression","正则表达式","入门","Go"],"title":"浅析 Regular Expression (正则表达式)","uri":"/posts/regex-in-one/"},{"categories":["regex","Regular Expression","正则表达式","入门","Go"],"content":"II. 普通字符 与 元字符 模式 描述 正则表达式 匹配项 普通字符 a ~ z 匹配自身 abc abc . 匹配除换行符 \\n 以外的任意字符 a.c abc / acc / awc \\ 转义字符，使后一个字符改变原来的意思 a\\.c;a\\\\c a.c;a\\c * 匹配前一个字符 0 次或多次 a*c ac / c / aaaaac + 匹配前一个字符 1 次或多次 a+c ac / aac / aaaaac ? 匹配前一个字符 0 次或 1 次 a?c ac / c ^ 匹配字符串开头，在多行模式中匹配每一行的开头 ^ab ab $ 匹配字符串结尾，在多行模式中匹配每一行的结尾 ab$ ab | 或，匹配 | 左右任意一个表达式，从左向右匹配，若没有 | 包括在 () 中，则匹配整个表达式 abc|def abc / def {} {m} 匹配前一个字符 m 次，{m,n} 匹配前一个字符 m 到 n 次 a{2}c aac [] 字符集合，匹配方括号中包含的任意一个字符: 字符可以逐个列出，也可给出范围，所有特殊字符在字符集中都失去其原有的特殊含义（使用 \\ 转义恢复其特殊含义） [abc] a / b / c () 分组，将括号中字符作为一个整体，可以用来匹配括号中的字符 (abc) abc Tip 反斜杠 \\ 后边跟元字符去除特殊含义，即特殊字符普通化 反斜杠 \\ 后边跟普通字符实现特殊功能，即普通字符特殊化，亦称预定义字符 引用序号对应的字组成所匹配的字符串 ","date":"2024-09-15","objectID":"/posts/regex-in-one/:2:0","tags":["regex","Regular Expression","正则表达式","入门","Go"],"title":"浅析 Regular Expression (正则表达式)","uri":"/posts/regex-in-one/"},{"categories":["regex","Regular Expression","正则表达式","入门","Go"],"content":"III. 预定义字符 预定义字符集是指在正则表达式中具有特殊意义的专用字符集，如 \\d、\\w、\\s 等，可以写在方括号 [] 中，也可以单独使用。 模式 描述 正则表达式 匹配项 \\d 匹配一个数字，等价于 [0-9] a\\dc a1c / a2c / a3c \\D 匹配一个非数字，等价于 [^0-9] a\\Dc a-c / a$c \\s 匹配一个空白字符，包括空格、制表符、换页符和换行符，等价于 [ \\f\\n\\r\\t\\v] a\\sc a c / a\\tc / a\\nc \\S 匹配一个非空白字符，等价于 [^ \\f\\n\\r\\t\\v] / [^\\s] a\\Sc a$c / a-c \\w 匹配一个单字字符（字母、数字或者下划线），等价于 [A-Za-z0-9_] a\\wc a1c / abc / a_c \\W 匹配一个非单字字符，即特殊字符，等价于 [^A-Za-z0-9_] a\\Wc a$c / a-c \\A 仅匹配字符串开头，等价于 ^ \\Aabc abc \\Z 仅匹配字符串结尾，等价于 $ abc\\Z abc \\b 匹配一个单词边界，即字与空格间的位置 \\babc\\b \u003cspace\u003e \\B 匹配非单词边界，等价于 [^\\b] a\\Bbc abc ","date":"2024-09-15","objectID":"/posts/regex-in-one/:3:0","tags":["regex","Regular Expression","正则表达式","入门","Go"],"title":"浅析 Regular Expression (正则表达式)","uri":"/posts/regex-in-one/"},{"categories":["regex","Regular Expression","正则表达式","入门","Go"],"content":"IV. 特殊分组 特殊分组是指在正则表达式中具有特殊意义的专用分组，如 (?P\u003cname\u003e...)、(?P=name)、(?#...)、(?=...)、(?!...)、(?\u003c=...)、(?\u003c!...) 等，可以写在方括号 [] 中，也可以单独使用。 模式 描述 正则表达式 匹配项 (?P\u003cname\u003e...) 为分组起一个别名，匹配的字符串可以通过 \\g\u003cname\u003e 或 \\k\u003cname\u003e 引用 (?P\u003cname\u003eabc) abc (?P=name) 引用别名为 name 的分组匹配的字符串 (?P\u003cid\u003e\\d)abc(?P=id) 1abc1 / 2abc2 \\\u003cnumber\u003e 通过 \\g\u003cnumber\u003e 或 \\k\u003cnumber\u003e 引用编号为 number 的分组匹配的字符串 `(\\d)abc\\1 1abc / 2abc ","date":"2024-09-15","objectID":"/posts/regex-in-one/:4:0","tags":["regex","Regular Expression","正则表达式","入门","Go"],"title":"浅析 Regular Expression (正则表达式)","uri":"/posts/regex-in-one/"},{"categories":["regex","Regular Expression","正则表达式","入门","Go"],"content":"V. match、search与findall ","date":"2024-09-15","objectID":"/posts/regex-in-one/:5:0","tags":["regex","Regular Expression","正则表达式","入门","Go"],"title":"浅析 Regular Expression (正则表达式)","uri":"/posts/regex-in-one/"},{"categories":["regex","Regular Expression","正则表达式","入门","Go"],"content":"1. match match 方法用于查找字符串的头部（也可以指定起始位置），它是一次匹配，只要找到了一个匹配的结果就返回，而不是查找所有匹配的结果。 ","date":"2024-09-15","objectID":"/posts/regex-in-one/:5:1","tags":["regex","Regular Expression","正则表达式","入门","Go"],"title":"浅析 Regular Expression (正则表达式)","uri":"/posts/regex-in-one/"},{"categories":["regex","Regular Expression","正则表达式","入门","Go"],"content":"2. search search 方法用于查找字符串的任何位置，它也是一次匹配，只要找到了一个匹配的结果就返回，而不是查找所有匹配的结果。 ","date":"2024-09-15","objectID":"/posts/regex-in-one/:5:2","tags":["regex","Regular Expression","正则表达式","入门","Go"],"title":"浅析 Regular Expression (正则表达式)","uri":"/posts/regex-in-one/"},{"categories":["regex","Regular Expression","正则表达式","入门","Go"],"content":"3. findall findall 方法用于查找字符串所有（非重复）的匹配子串，返回一个列表，如果没有找到匹配的，则返回空列表。 ","date":"2024-09-15","objectID":"/posts/regex-in-one/:5:3","tags":["regex","Regular Expression","正则表达式","入门","Go"],"title":"浅析 Regular Expression (正则表达式)","uri":"/posts/regex-in-one/"},{"categories":["regex","Regular Expression","正则表达式","入门","Go"],"content":"VI. 贪婪匹配与惰性匹配 ","date":"2024-09-15","objectID":"/posts/regex-in-one/:6:0","tags":["regex","Regular Expression","正则表达式","入门","Go"],"title":"浅析 Regular Expression (正则表达式)","uri":"/posts/regex-in-one/"},{"categories":["regex","Regular Expression","正则表达式","入门","Go"],"content":"1. 贪婪匹配 正则表达式一般趋向于最大长度匹配，即匹配直到下一个字符不满足匹配规则为止，这被称为贪婪匹配。 例如，* 通常意味着匹配零个或多个字符（包括零个），+ 通常意味着匹配一个或多个字符（包括一个），? 通常意味着匹配零个或一个字符，{m,n} 通常意味着匹配 m 到 n 个字符。 ","date":"2024-09-15","objectID":"/posts/regex-in-one/:6:1","tags":["regex","Regular Expression","正则表达式","入门","Go"],"title":"浅析 Regular Expression (正则表达式)","uri":"/posts/regex-in-one/"},{"categories":["regex","Regular Expression","正则表达式","入门","Go"],"content":"2. 惰性匹配 惰性匹配，即匹配尽可能少的字符。在贪婪匹配符号后面加上一个问号 ? 就可以实现惰性匹配。 ","date":"2024-09-15","objectID":"/posts/regex-in-one/:6:2","tags":["regex","Regular Expression","正则表达式","入门","Go"],"title":"浅析 Regular Expression (正则表达式)","uri":"/posts/regex-in-one/"},{"categories":["regex","Regular Expression","正则表达式","入门","Go"],"content":"VII. Reference 正则表达式 wiki ","date":"2024-09-15","objectID":"/posts/regex-in-one/:7:0","tags":["regex","Regular Expression","正则表达式","入门","Go"],"title":"浅析 Regular Expression (正则表达式)","uri":"/posts/regex-in-one/"},{"categories":["make","cmake","Makefile","CMakeLists.txt"],"content":" 导语 导语内容 ","date":"2024-09-11","objectID":"/posts/make-cmake/:0:0","tags":["make","cmake","Makefile","CMakeLists.txt"],"title":"浅析 Make 与 Cmake","uri":"/posts/make-cmake/"},{"categories":["make","cmake","Makefile","CMakeLists.txt"],"content":"Makefile 特殊字符说明 $: 主要用于变量引用，$(CC) 引用名为 CC 的变量 #: 注释 :: 分隔目标和依赖，target: dependencies ;: 分隔命令，target: dependencies; command1; command2 =: 变量赋值(递归展开赋值)，CC = gcc :=: 立即赋值，VERSION := $(shell git describe) +=: 追加赋值，CFLAGS += -O3 -Wall ?=: 条件赋值（如果变量未定义），CC ?= gcc \\: 行继续符 OBJS = main.o \\ helper.o \\ utils.o %: 通配符，用于模式规则，%.o, %.c @: 禁止命令回显，@echo \"Building... $\u003c: 第一个依赖项 $@: 目标 $^: 所有依赖项 target: dep1 dep2 command $\u003c $@ $^ -: 忽略命令错误，rm temp.txt *: 通配符，匹配任意字符串，*.o wildcard、patsubst 等: 函数调用，$(wildcard *.c) ","date":"2024-09-11","objectID":"/posts/make-cmake/:1:0","tags":["make","cmake","Makefile","CMakeLists.txt"],"title":"浅析 Make 与 Cmake","uri":"/posts/make-cmake/"},{"categories":["JSON","Encoder","Decoder"],"content":" 导语 本篇主要介绍一下 JSON 相关内容 ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:0:0","tags":["JSON","Encoder","Decoder"],"title":"Json Encoder-Decoder","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"I. 何为 JSON ? JSON 源于对实时服务器到浏览器会话通信协议的需求，无需使用 Flash 或 Java 小程序等浏览器插件，这是 2000 年代初期使用的主要方法。 JSON(JavsScript Object Notation，JavsScript 对象表示法)，由美国程序员道格拉斯·克罗克福特构想和设计的一种轻量级资料交换格式。 其内容由属性和值所组成，具有易于阅读和处理的优势。 JSON是独立于编程语言的资料格式，其不仅是JavaScript的子集，也采用了C语言家族的习惯用法，目前也有许多编程语言都能够将其解析和字符串化，其广泛使用的程度也使其成为通用的资料格式。 JSON 扩展名：.json 互联网媒体类型: application/json 类型代码: TEXT 统一类型标识: public.json 格式类型: 数据交换 扩展自: JavaScript 标准: RFC 7159, ECMA-404 网站: json.org ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:1:0","tags":["JSON","Encoder","Decoder"],"title":"Json Encoder-Decoder","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"II. JSON 基本数据类型 ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:2:0","tags":["JSON","Encoder","Decoder"],"title":"Json Encoder-Decoder","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"数值 十进制数值，不能有前导0，可以为负数，可以有小数部分，不区分整数与浮点数。 也可以用 e/E 表示指数部分，不能包含非数（如 NaN）。 JSON JavaScript 用双精度浮点数表示所有数值（后来也支持 BigInt） ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:2:1","tags":["JSON","Encoder","Decoder"],"title":"Json Encoder-Decoder","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"字符串 以双引号 \"\" 括起来的零个或多个 Unicode 码位，支持反斜杠开始的转义字符序列。 ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:2:2","tags":["JSON","Encoder","Decoder"],"title":"Json Encoder-Decoder","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"布尔值 表示为 true 或 false ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:2:3","tags":["JSON","Encoder","Decoder"],"title":"Json Encoder-Decoder","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"数组 有序的零个或多个值 每个值可以为任意类型，并使用方括号[]包裹，元素之间使用逗号,分隔，例如[val, val]. ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:2:4","tags":["JSON","Encoder","Decoder"],"title":"Json Encoder-Decoder","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"对象 若干无序的\"key-value\"对（key-value pairs），其中 key 只能是字符串，并以花括号{}包裹，多个\"key-value\"之间使用逗号,分隔，key 与 value 之间使用冒号:分隔 建议但不强制要求对象中的键是独一无二的。 ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:2:5","tags":["JSON","Encoder","Decoder"],"title":"Json Encoder-Decoder","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"空值 表示为 null JSON JSON 交换时必须编码为UTF-8。 转义序列可以为: \\\\, \\\", \\/, \\b, \\f, \\n, \\r, \\t 或 Unicode16 进制转义字符序列（\\u后面跟随 4 位 16 进制数字）。 ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:2:6","tags":["JSON","Encoder","Decoder"],"title":"Json Encoder-Decoder","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"III. Example { \"firstName\": \"John\", \"lastName\": \"Smith\", \"sex\": \"male\", \"age\": 25, \"address\": { \"streetAddress\": \"21 2nd Street\", \"city\": \"New York\", \"state\": \"NY\", \"postalCode\": \"10021\" }, \"phoneNumber\": [ { \"type\": \"home\", \"number\": \"212 555-1234\" }, { \"type\": \"fax\", \"number\": \"646 555-4567\" } ] } ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:3:0","tags":["JSON","Encoder","Decoder"],"title":"Json Encoder-Decoder","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"IV. 与其他格式的比较 ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:4:0","tags":["JSON","Encoder","Decoder"],"title":"Json Encoder-Decoder","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"XML JSON与XML最大的不同，在于XML是一个完整的标记语言，而JSON不是. 这使得XML在程序判读上需要比较多的功夫。主要的原因在于XML的设计理念与JSON不同。XML利用标记语言的特性提供了绝佳的延展性（如XPath），在数据存储，扩展及高级检索方面具备对JSON的优势，而JSON则由于比XML更加小巧，以及浏览器的内置快速解析支持，使得其更适用于网络数据传输领域。 ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:4:1","tags":["JSON","Encoder","Decoder"],"title":"Json Encoder-Decoder","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"YAML 在功能和语法上，JSON 都是 YAML 语言的一个子集 特别是，YAML 1.2规范指定\"任何JSON格式的文件都是YAML格式的有效文件\"。最常见的 YAML 解析器也能够处理 JSON。 版本 1.2 之前的 YAML 规范没有完全涵盖 JSON，主要是由于 YAML 中缺乏本机 UTF-32 支持，以及对逗号分隔空格的要求；此外，JSON 规范还包括 /* */ 样式的注释。 YAML 最重要的区别是语法扩展集，它们在 JSON 中没有类似物： 关系数据支持：在 YAML 文档中，可以引用以前在文件/流中找到的锚点；通过这种方式，您可以表达递归结构。 支持除基元之外的可扩展数据类型，如字符串、数字、布尔值等。 支持带缩进的块语法； 它允许您在不使用不必要的符号的情况下描述结构化数据：各种括号、引号等。 ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:4:2","tags":["JSON","Encoder","Decoder"],"title":"Json Encoder-Decoder","uri":"/posts/json-encoder-decoder/"},{"categories":["JSON","Encoder","Decoder"],"content":"V. Reference JSON JavaScript RFC 7159 ECMA-404 json.org Unicode UTF-8 ","date":"2024-09-09","objectID":"/posts/json-encoder-decoder/:5:0","tags":["JSON","Encoder","Decoder"],"title":"Json Encoder-Decoder","uri":"/posts/json-encoder-decoder/"},{"categories":["check.rule","微服务","设计与实现"],"content":" 导语 在设计和开发微服务接口的过程中，常常会遇到接口职责不够单一、功能混杂的问题。面对这种情况，该如何有效处理呢？ 本文以资格校验服务为例，详细介绍如何通过工厂方法、流量镜像和流量回放等技术手段，来解决开发、测试和部署中遇到的此类问题。 ","date":"2024-09-07","objectID":"/posts/check-rule/:0:0","tags":["check.rule","微服务","设计与实现"],"title":"资格校验接口的微服务设计与实现","uri":"/posts/check-rule/"},{"categories":["check.rule","微服务","设计与实现"],"content":"资格服务的三层架构设计 在实现本接口的过程中，为了应对多种规则校验需求，我们设计了一个基于三层架构的系统。 该设计遵循简洁架构的原则，以确保系统的高内聚和低耦合。 具体划分为以下三层：控制层（Controller）、业务层（Service / Biz）、存储层（Store）。 其中，控制层负责处理外部请求和响应，业务层负责规则的具体逻辑校验， 另外，由于本接口不会存储用户数据，因此存储层的职责由负责数据的持久化存储 转变为了负责外部数据进行交互。 从架构上看，层与层之间的依赖关系自上而下递进，即控制层依赖业务层，业务层依赖存储层，具体代码架构如下图所示： 在各层之间的代码设计上，遵循了严格的依赖倒置原则（DIP）。 具体来说， 控制层（Controller）可以导入业务层（Service）和存储层（Store） 的包，而非直接与存储层交互。 这样设计的好处是确保业务逻辑独立于数据存储，实现更强的扩展性和维护性。 需要特别注意的是，控制层不应直接导入存储层，除非有非常特殊的需求。 所有涉及存储的操作应通过业务层来完成，从而确保系统设计的层次清晰，职责明确。 ","date":"2024-09-07","objectID":"/posts/check-rule/:1:0","tags":["check.rule","微服务","设计与实现"],"title":"资格校验接口的微服务设计与实现","uri":"/posts/check-rule/"},{"categories":["check.rule","微服务","设计与实现"],"content":"控制层（Controller） 控制层负责接收并处理来自客户端的请求， 具体操作包括：解析请求参数、进行参数校验、分发业务逻辑、整合处理结果并返回响应。 它的主要职责是将请求路由到业务层进行处理，而不直接涉及业务逻辑的实现。 在控制层中，我们通过 services.Servicer 接口将请求分发给业务层（Service）。 业务逻辑处理完成后，控制层将结果整合并返回给客户端，从而实现业务路由的功能。 FIXME 框图需要修改，应该严格按照具体操作来画 控制层结构示意图 ","date":"2024-09-07","objectID":"/posts/check-rule/:1:1","tags":["check.rule","微服务","设计与实现"],"title":"资格校验接口的微服务设计与实现","uri":"/posts/check-rule/"},{"categories":["check.rule","微服务","设计与实现"],"content":"业务层（Biz/Service） 业务层是整个系统的核心，负责处理所有的业务逻辑。 当控制层接收到请求并将其转发至业务层时，业务层将根据具体的业务规则，调用存储层（Store）进行数据的 CURD。 在此层级中，所有的业务逻辑代码应集中于此，确保业务逻辑与其他逻辑（如存储和控制）解耦。 业务层的设计目标是让代码更具扩展性和可维护性。 业务层与存储层的交互 ","date":"2024-09-07","objectID":"/posts/check-rule/:1:2","tags":["check.rule","微服务","设计与实现"],"title":"资格校验接口的微服务设计与实现","uri":"/posts/check-rule/"},{"categories":["check.rule","微服务","设计与实现"],"content":"存储层（Store） 存储层是数据交互的入口，它负责与数据库 / 第三方服务进行 CURD 操作。 由于本接口不会存储用户数据，因此存储层的职责由负责数据的持久化存储 转变为了负责外部数据进行交互，并为上层提供所需的数据。 该层不会涉及任何业务逻辑，而仅专注于数据的存储与转换。 同时，存储层也负责数据的格式转换，例如： 将数据库或第三方服务返回的数据格式转换为业务层和控制层能处理的数据格式； 将业务层和控制层的数据转换为存储系统或外部服务能够识别的格式。 ","date":"2024-09-07","objectID":"/posts/check-rule/:1:3","tags":["check.rule","微服务","设计与实现"],"title":"资格校验接口的微服务设计与实现","uri":"/posts/check-rule/"},{"categories":["check.rule","微服务","设计与实现"],"content":"层间交互 在整个系统中，各层之间通过接口进行交互，确保功能的独立性和可扩展性。 层与层之间的通信遵循依赖倒置原则，以便实现模块化和插件化的设计目标，同时大大提高了系统的测试性。 Controller 依赖于 Service 层：Controller 通过调用 Service 层接口处理业务逻辑，可利用 golang/mock 模拟 Service 层进行单元测试。 Service 依赖于 Store 层：Service 层通过 Store 层接口与存储系统/第三方服务交互，可通过 golang/mock 模拟操作。 Store 依赖于数据库和外部服务：Store 层与数据库或微服务进行直接交互，可以使用 sqlmock 模拟数据库操作，使用 httpmock 模拟外部 HTTP 请求。 ","date":"2024-09-07","objectID":"/posts/check-rule/:1:4","tags":["check.rule","微服务","设计与实现"],"title":"资格校验接口的微服务设计与实现","uri":"/posts/check-rule/"},{"categories":["check.rule","微服务","设计与实现"],"content":"资格服务代码设计 在了解了三层架构的基础后，资格服务的代码设计也基于此结构实现。 在具体实现中，我们遵循面向接口编程的原则，以提高代码的扩展性和可测试性。 Controller 在 Controller 层中，我们定义了如下的代码结构： 它持有 services.Servicer 接口，并且实现了 POST/HEAD/GET 等 HTTP 方法， 用于处理 HTTP 请求的响应、请求参数的解析与合法性校验、Service 层业务逻辑的调用执行等操作。 Service 在 Service 层中，我们定义了如下的代码结构： Server 接口定义了该服务所支持的功能，实现了接口就是规范的功能。 与此同时，在 Server 的实现类（例如，DjcRuleService） 中持有 rule.Ruler 接口的引用，用于执行资格校验规则。 Store 在存储层中，我们采用了工厂方法设计模式，以实现不同规则的动态校验。 rule.Ruler 接口定义了核心的 Check 方法，具体的校验规则类（如 DJCFFriendsRule, DJCfmVipRule 等）通过工厂方法创建，并在 service.createRuler 中创建具体规则校验实现类，用以实现具体校验逻辑。 代码结构定义如下： ","date":"2024-09-07","objectID":"/posts/check-rule/:1:5","tags":["check.rule","微服务","设计与实现"],"title":"资格校验接口的微服务设计与实现","uri":"/posts/check-rule/"},{"categories":["check.rule","微服务","设计与实现"],"content":"微服务部署 ","date":"2024-09-07","objectID":"/posts/check-rule/:2:0","tags":["check.rule","微服务","设计与实现"],"title":"资格校验接口的微服务设计与实现","uri":"/posts/check-rule/"},{"categories":["check.rule","微服务","设计与实现"],"content":"服务发现 在上游客户端向某个服务发送请求时，它首先会根据所请求的服务名称（例如check.rule）在配置管理中心（例如etcd）查找该服务对应的配置文件： 服务配置文件: /cfg/daoju/.../info/check/rule/check.rule.cfg 环境配置文件: /cfg/daoju/.../info/check/rule/check.rule.1_1.cfg 部署配置文件: /cfg/daoju/.../deployment/djc_rule_test.cfg 需要注意的是，部署配置文件的文件名是由环境部署文件中的 deployment[_number].name 配置项所确定. 服务配置 服务配置文件中通常包含以下关键消息： # /cfg/daoju/.../info/check/rule/check.rule.cfg [api] name=check.rule api=/cgi-bin/daoju/.../rule_check.cgi timeout=5000 proto=http method=post [verify] key=xxxxxxxxxxxxxxxxxxxx ... 其中: api.name 描述了该服务的名称 api.api 描述了该服务的 URL 路径 api.timeout 描述了该服务的请求超时时间 api.proto 描述了该服务采用的协议格式 api.method 描述了该服务具体采用哪种请求方法 verify.key 描述了请求数据进行校验的密钥 环境配置 环境配置文件中通常包含以下关键消息： # /cfg/daoju/.../info/check/rule/check.rule.1_1.cfg [weight] total=100 depcnt=2 weight_0=40 weight_1=60 [maintenance] status=0 [limit] qps=1000 [deployment] name=djc_rule_test [deployment_1] name=djc_check_rule_go_test ... 其中: weight.total 描述了所有部署环境的权重总和，通常是 100 weight.depcnt 描述了该服务部署在本环境下（测试环境或生产环境）的服务数量 weight.weight_\u003cnumber\u003e 描述了第 \u003cnumber\u003e 服务的获取请求数据的占比（weight_\u003cnumber\u003e / weight.total） maintenance.status 描述了当前环境是否已发布 / 正常 limit.qps 描述了该服务所支持的最大 QPS deployment[_number].name 描述了该服务的环境部署名称 部署配置 部署配置文件中通常包含以下关键消息： # /cfg/daoju/.../deployment/djc_rule_test.cfg [djc_check_rule_go_test] modid=xxxxxxx:yyyyyyy mod=xxxx cmd=xxxxx domain= ip_num=1 defaultip_0=\u003cip\u003e defaultport_0=\u003cport\u003e [polaris] namespace=Development service=gdp.aaa.bbb.ccc ... 其中: djc_check_rule_go_test 主要用于指向该部署 polaris.namespace 描述了该部署处于何种环境下，例如 Development / Production / Test polaris.service 描述了该部署所指向的北极星服务地址 一旦通过上面的流程确定了 polaris.service 就可以确定 GDP 中的具体代码，大致流程如下： ","date":"2024-09-07","objectID":"/posts/check-rule/:2:1","tags":["check.rule","微服务","设计与实现"],"title":"资格校验接口的微服务设计与实现","uri":"/posts/check-rule/"},{"categories":["check.rule","微服务","设计与实现"],"content":"【接口测试】流量回放与镜像 ","date":"2024-09-07","objectID":"/posts/check-rule/:3:0","tags":["check.rule","微服务","设计与实现"],"title":"资格校验接口的微服务设计与实现","uri":"/posts/check-rule/"},{"categories":["check.rule","微服务","设计与实现"],"content":"流量回放 (Traffic Replay) 流量回放，顾名思义，指的是通过复制线上真实流量（录制），然后在测试环境（或生产环境）进行模拟请求（回放）验证代码逻辑正确性的一种技术方法。 它通过采集线上流量在测试环境（或生产环境）回放逐一对比每个子调用差异和入口调用结果来发现接口代码是否存在问题。 通俗理解，流量回放和使用其他工具（比如 JMeter / postman）构造请求，然后根据返回的响应数据判断测试是否通过的本质相同。 两者的区别在于：流量回放是线上真实流量，而在传统的利用测试工具来发送请求的手段中，人工介入较多。 ","date":"2024-09-07","objectID":"/posts/check-rule/:3:1","tags":["check.rule","微服务","设计与实现"],"title":"资格校验接口的微服务设计与实现","uri":"/posts/check-rule/"},{"categories":["check.rule","微服务","设计与实现"],"content":"流量镜像 (Traffic Mirror) 流量镜像（Traffic Mirror） ，也称流量影子（Traffic Shadow）, 是一种强大的、无风险的测试应用版本的方法，它将实时流量的副本发送给被镜像的服务。 采用这种方法，可以轻松地测试新版本，而无需在生产环境中部署新版本。 ","date":"2024-09-07","objectID":"/posts/check-rule/:3:2","tags":["check.rule","微服务","设计与实现"],"title":"资格校验接口的微服务设计与实现","uri":"/posts/check-rule/"},{"categories":["check.rule","微服务","设计与实现"],"content":"验证资格服务的稳定性与准确性 稳定性 由于本次资格服务接口项目属于重构项目，因此在代码重构结束之后，借助了流量回放与镜像技术，验证重构后的代码逻辑是否正确，保证重构后的代码逻辑与重构前的代码逻辑一致。 另外，为了充分验证代码的正确性，我们采用了两种逐层递进的验证方式， 即首先在 CLS 日志系统中抓取线上流量，然后通过流量回放技术手段，在测试环境（或生产环境）进行模拟请求，确保代码逻辑的稳定性，如下图所示； 在进行代码稳定性验证阶段，主要关注以下几个指标： 响应时间 吞吐量 并发用户数 CPU 使用率 内存占用 磁盘 I/O 网络带宽使用情况 出现异常或错误的请求比例 准确性 在充分验证重构代码的稳定性之后，接下来就需要验证代码的准确性。 这里采用了流量镜像的强大验证技术手段，也就是说，在测试环境（或生产环境）中，直接对线上流量进行镜像，并持续监控镜像流量，确保代码逻辑的准确性。 在进行代码准确性性验证阶段，主要关注以下几个指标： 功能正确性： 输入、输出是否符合预期 边界条件 异常情况处理 Online 与 Local 数据是否一致 ","date":"2024-09-07","objectID":"/posts/check-rule/:3:3","tags":["check.rule","微服务","设计与实现"],"title":"资格校验接口的微服务设计与实现","uri":"/posts/check-rule/"},{"categories":["check.rule","微服务","设计与实现"],"content":"Reference beego sqlmock httpmock 【道聚城】微服务建设实践总结 go install github.com/jfeliu007/goplantuml/cmd/goplantuml@latest yum install graphviz ","date":"2024-09-07","objectID":"/posts/check-rule/:4:0","tags":["check.rule","微服务","设计与实现"],"title":"资格校验接口的微服务设计与实现","uri":"/posts/check-rule/"},{"categories":["VSCode","Vim","效率","最佳实践"],"content":" 导语 在 Visual Studio Code 中引入 Vim 模式，无疑可以极大程度上提高个人的编码效率。 ","date":"2024-08-25","objectID":"/posts/vscode-vim/:0:0","tags":["VSCode","Vim","效率","最佳实践"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["VSCode","Vim","效率","最佳实践"],"content":"I. VSCodeVim VSCodeVim 是一款 vim 模拟器，它将 vim 的大部分功能都集成在了 VSCode 中，即一个嵌入在 VSCode 中的 vim。 正是由于 VSCodeVim 本质上只是一个 Vim 模拟器，而非真正的 Vim，导致原生 Vim 中的有些功能并不支持，具体支持情况见 roadmap。 尽管它现在还无法完全模拟 Vim，但这依然不妨碍它的优秀。 Status Command ✅ Normal Mode ✅ Insert Mode ✅ Visual Mode ✅ Visual Line Mode ✅ Number Prefixes ✅ . Operator ✅ Searching with / and ? ✅ Correct Undo/Redo ⚠ Command Remapping ⚠️ Marks ✅ Text Objects ✅ Visual Block Mode ✅ Replace Mode ✅ Multiple Select Mode ⚠ Macros ⚠ Buffer/Window/Tab ✅ - command done ⚠️ - some variations of the command are not supported ","date":"2024-08-25","objectID":"/posts/vscode-vim/:1:0","tags":["VSCode","Vim","效率","最佳实践"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["VSCode","Vim","效率","最佳实践"],"content":"II. 安装 只需在 VSCode 的插件商店搜索 vim 就能找到该插件. 关闭 Mac 的重复键 当使用 Mac 时，需要输入以下代码，用以关闭 Mac 的重复键 # For VS Code $ defaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool false # For VS Codium $ defaults write com.vscodium ApplePressAndHoldEnabled -bool false # If necessary, reset global default $ defaults delete -g ApplePressAndHoldEnabled ","date":"2024-08-25","objectID":"/posts/vscode-vim/:2:0","tags":["VSCode","Vim","效率","最佳实践"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["VSCode","Vim","效率","最佳实践"],"content":"III. 文件配置详解 VSCodeVim 的相关配置文件是放在 settings.json 中，而不是 vimrc 文件. 对于非代码编辑区的热键将其定义在 keybindings.json 中 对于代码编辑区且属于 vim 的热键将其定义在 settings.json 文件中 个人配置参考 个人 vscode 配置文件参考：https://github.com/kydance/dotfiles ","date":"2024-08-25","objectID":"/posts/vscode-vim/:3:0","tags":["VSCode","Vim","效率","最佳实践"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["VSCode","Vim","效率","最佳实践"],"content":"1. 基础配置 // leader - prefix key \"vim.leader\": \"\u003cspace\u003e\", // To improve performance \"extensions.experimental.affinity\": { \"vscodevim.vim\": 1 }, // Easy motion \"vim.easymotion\": true, // Use system clipboard \"vim.useSystemClipboard\": true, // 由vim接管ctrl+any的按键，而不是vscode \"vim.useCtrlKeys\": true, \"vim.replaceWithRegister\": true, // 忽略大小写 \"vim.ignorecase\": true, \"vim.smartcase\": true, // 智能行号 \"vim.smartRelativeLine\": true, \"vim.foldfix\": true, // Highlight search \"vim.hlsearch\": true, \"vim.highlightedyank.enable\": true, \"vim.highlightedyank.duration\": 500, // 由vscode进行处理，而不是vscode-vim插件 \"vim.handleKeys\": { \"\u003cC-d\u003e\": true, // 向下滚动半页 \"\u003cC-f\u003e\": true, // 向下滚动一页 \"\u003cC-e\u003e\": true, // 向下滚动一行 \"\u003cC-s\u003e\": true, \"\u003cC-z\u003e\": false, \"\u003cC-a\u003e\": true, \"\u003cC-c\u003e\": true, \"\u003cC-v\u003e\": true, \"\u003cC-x\u003e\": true, }, ","date":"2024-08-25","objectID":"/posts/vscode-vim/:3:1","tags":["VSCode","Vim","效率","最佳实践"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["VSCode","Vim","效率","最佳实践"],"content":"2. 快捷键配置 NORMAL Mode \"vim.normalModeKeyBindingsNonRecursive\": [ { // 聚集 terminal \"before\": [\"\u003cC-j\u003e\"], \"commands\": [\"workbench.action.terminal.focus\"] }, { // 语义级 重命名 \"before\": [\"leader\", \"r\"], \"commands\": [ \"editor.action.rename\"] }, { // \"before\": [\"g\", \"h\"], \"commands\": [ \"editor.action.showHover\"] }, { \"before\": [\"g\", \"d\"], \"commands\": [\"editor.action.revealDefinition\"] }, { \"before\": [\"g\", \"r\"], \"commands\": [\"editor.action.goToReferences\"], }, { \"before\": [\"g\", \"i\"], \"commands\": [\"editor.action.goToImplementation\"], }, { \"before\": [\"g\", \"b\"], \"commands\": [\"workbench.action.navigateBack\"], }, { \"before\": [\"leader\", \"e\", \"f\"], \"commands\": [\"workbench.explorer.fileView.focus\"], }, { \"before\": [ \"leader\", \"leader\", \"e\", \"f\"], \"commands\": [\"workbench.action.toggleActivityBarVisibility\"] }, { \"before\": [\"leader\", \"g\", \"g\"], \"commands\": [\"workbench.action.quickOpen\"], }, { // Global find \"before\": [\"leader\", \"g\", \"f\"], \"commands\": [\"workbench.view.search\"], }, { \"before\": [\"g\", \"[\",], \"commands\": [\"editor.action.marker.prevInFiles\"], }, { \"before\": [\"g\", \"]\",], \"commands\": [\"editor.action.marker.nextInFiles\"], }, { // Source Control Git \"before\": [ \"leader\", \"g\", \"i\", \"t\" ], \"commands\": [\"workbench.scm.focus\"] }, { // Start to debug \"before\": [ \"leader\", \"d\" ], \"commands\": [\"workbench.action.debug.start\"] }, { \"before\": [\"leader\",\"w\"], \"commands\": [\":w!\" ] }, { \"before\": [\"leader\",\"q\"], \"commands\": [\":q\" ] }, { // No highlight \"before\": [\"leader\", \"n\", \"h\"], \"commands\": [\":nohl\"] }, { \"before\": [\"H\"], \"after\": [\"^\"] }, { \"before\": [\"L\"], \"after\": [\"$\"] }, { // Blockwise visual mode \"before\": [\"\\\\\"], \"commands\": [\"extension.vim_ctrl+v\"] }, { \"before\": [\"leader\", \"t\"], \"commands\": [\":terminal\"] }, { \"before\": [\"g\", \"t\"], \"commands\": [\":tabnext\"] }, { \"before\": [\"g\", \"T\"], \"commands\": [\":tabprev\"] }, { // project-manager \"before\": [\"leader\", \"p\", \"m\"], \"commands\": [{ \"command\":\"workbench.view.extension.project-manager\", \"when\":\"viewContainer.workbench.view.extension.project-manager.enabled\" }] }, ], INSERT Mode \"vim.insertModeKeyBindings\": [ { \"before\": [\"j\", \"k\"], \"after\": [\"\u003cEsc\u003e\"] }, ], VISUAL Mode \"vim.visualModeKeyBindings\": [ { \"before\": [\"H\"], \"after\": [\"^\"] }, { \"before\": [\"L\"], \"after\": [\"$\"] }, { \"before\": [\"\u003e\"], \"commands\": [ \"editor.action.indentLines\"] }, { \"before\": [\"\u003c\"], \"commands\": [ \"editor.action.outdentLines\"] }, ], COMMAND LINE Mode \"vim.commandLineModeKeyBindingsNonRecursive\": [ ], `leader` 键注意事项 leader 键只在代码编辑区域生效，它无法做到全 VSCode 生效 ","date":"2024-08-25","objectID":"/posts/vscode-vim/:3:2","tags":["VSCode","Vim","效率","最佳实践"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["VSCode","Vim","效率","最佳实践"],"content":"3. 资源管理配置 keybindings.json 定义对于非代码编辑区的热键. [ { \"key\": \"cmd+h\", \"command\": \"workbench.action.focusLeftGroup\" }, { \"key\": \"cmd+l\", \"command\": \"workbench.action.focusRightGroup\" }, { // Rename file \"key\": \"r\", \"command\": \"renameFile\", \"when\": \"explorerViewletVisible \u0026\u0026 filesExplorerFocus \u0026\u0026 !explorerResourceIsRoot \u0026\u0026 !explorerResourceReadonly \u0026\u0026 !inputFocus\" }, { // New file \"key\": \"a\", \"command\": \"explorer.newFile\", \"when\": \"explorerViewletVisible \u0026\u0026 filesExplorerFocus \u0026\u0026 !explorerResourceIsRoot \u0026\u0026 !explorerResourceReadonly \u0026\u0026 !inputFocus\" }, { // New folder \"key\": \"shift+a\", \"command\": \"explorer.newFolder\", \"when\": \"explorerViewletVisible \u0026\u0026 filesExplorerFocus \u0026\u0026 !explorerResourceIsRoot \u0026\u0026 !explorerResourceReadonly \u0026\u0026 !inputFocus\" }, { // Delete file \"key\": \"d\", \"command\": \"deleteFile\", \"when\": \"explorerViewletVisible \u0026\u0026 filesExplorerFocus \u0026\u0026 !explorerResourceIsRoot \u0026\u0026 !explorerResourceReadonly \u0026\u0026 !inputFocus\" }, { // Copy \"key\": \"y\", \"command\": \"filesExplorer.copy\", \"when\": \"explorerViewletVisible \u0026\u0026 filesExplorerFocus \u0026\u0026 !explorerResourceIsRoot \u0026\u0026 !explorerResourceReadonly \u0026\u0026 !inputFocus\" }, { // Cut \"key\": \"x\", \"command\": \"filesExplorer.cut\", \"when\": \"explorerViewletVisible \u0026\u0026 filesExplorerFocus \u0026\u0026 !explorerResourceIsRoot \u0026\u0026 !explorerResourceReadonly \u0026\u0026 !inputFocus\" }, { // Paste \"key\": \"p\", \"command\": \"filesExplorer.paste\", \"when\": \"explorerViewletVisible \u0026\u0026 filesExplorerFocus \u0026\u0026 !explorerResourceIsRoot \u0026\u0026 !explorerResourceReadonly \u0026\u0026 !inputFocus\" }, { // 全局搜索后，在输入框按回车，即可聚焦到搜索结果列表 \"key\": \"enter\", \"command\": \"search.action.focusSearchList\", \"when\": \"inSearchEditor \u0026\u0026 inputBoxFocus \u0026\u0026 hasSearchResult || inputBoxFocus \u0026\u0026 searchViewletVisible \u0026\u0026 hasSearchResult\" }, { // 在搜索结果列表，只需按 esc，就可回到搜索输入框 \"key\": \"escape\", \"command\": \"workbench.action.findInFiles\", \"when\": \"searchViewletVisible \u0026\u0026 hasSearchResult \u0026\u0026 searchViewletFocus\" }, { // 在搜索输入框，只需按 esc，就可回到编辑器 \"key\": \"escape\", \"command\": \"workbench.action.focusFirstEditorGroup\", \"when\": \"inSearchEditor \u0026\u0026 inputBoxFocus|| inputBoxFocus \u0026\u0026 searchViewletVisible\" }, { // 在文件浏览界面，只需按 esc，就可回到编辑器 \"key\": \"escape\", \"command\": \"workbench.action.focusFirstEditorGroup\", \"when\": \"explorerViewletVisible \u0026\u0026 filesExplorerFocus \u0026\u0026 !inputFocus\" }, { \"key\": \"tab\", \"command\": \"acceptSelectedSuggestion\", \"when\": \"suggestWidgetVisible \u0026\u0026 textInputFocus\" }, { // Next Suggestion \"key\": \"tab\", \"command\": \"selectNextSuggestion\", \"when\": \"editorTextFocus \u0026\u0026 suggestWidgetMultipleSuggestions \u0026\u0026 suggestWidgetVisible\" }, { // Prev Suggestion \"key\": \"shift+tab\", \"command\": \"selectPrevSuggestion\", \"when\": \"editorTextFocus \u0026\u0026 suggestWidgetMultipleSuggestions \u0026\u0026 suggestWidgetVisible\" }, { \"key\": \"cmd+k\", \"command\": \"workbench.action.focusActiveEditorGroup\", \"when\": \"terminalFocus\" } ] ","date":"2024-08-25","objectID":"/posts/vscode-vim/:3:3","tags":["VSCode","Vim","效率","最佳实践"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["VSCode","Vim","效率","最佳实践"],"content":"Reference Visual Studio Code VSCodeVim ","date":"2024-08-25","objectID":"/posts/vscode-vim/:4:0","tags":["VSCode","Vim","效率","最佳实践"],"title":"【最佳实践】VSCode + Vim = 效率之神","uri":"/posts/vscode-vim/"},{"categories":["Golang","effective go"],"content":" 导语 如何编写清晰、地道的 Go 代码 ","date":"2024-08-15","objectID":"/posts/effective-go/:0:0","tags":["Golang","effective go"],"title":"Effective Go","uri":"/posts/effective-go/"},{"categories":["Golang","effective go"],"content":"Formatting 格式化 在 Golang 中，gofmt 以包未处理对象而非源文件，它将 Go 程序按照标准风格缩进、对齐，保留注释并在需要时重新格式化。 Indentation 缩进：使用 制表符 Tab 缩进，gofmt 默认使用 Line length 行长度：Go 对行的长度没有限制 Parentheses 括号：控制结构（if, for, switch）在语法上并不需要圆括号 ","date":"2024-08-15","objectID":"/posts/effective-go/:1:0","tags":["Golang","effective go"],"title":"Effective Go","uri":"/posts/effective-go/"},{"categories":["Golang","effective go"],"content":"Commentary 注释 Go 支持 C 风格的块注释 /* */ 和 C++ 风格的单行注释 //，其中，// 注释更常用，而 /* */ 则主要用于包的注释 godoc 即使一个程序，又是一个 Web 服务器，它对 Go 的源码进行处理，并提取包中的文档内容： 出现在顶级声明之前，且与该声明之间没有空行的注释，将与该声明一起被提出来，作为该条目的说明文档。 每个包都应包含一段包注释，即放置在包子句前的一个块注释。 对于包含多个文件的包，包注释只需出现在其中的任一文件中即可。 包注释应在整体上对该包进行介绍，并提供包的相关信息。 它将出现在 godoc 页面中的最上面，并为紧随其后的内容建立详细的文档。 /* Package regex implements a simple library for regular expressions. The syntax of the regular expressions accepted is: regexp: concatenation { '|' concatenation } concatenation: { closure } closure: term [ '*' | '+' | '?' ] term: '^' '$' '.' character '[' [ '^' ] character-range ']' '(' regexp ')' */ package regex ","date":"2024-08-15","objectID":"/posts/effective-go/:2:0","tags":["Golang","effective go"],"title":"Effective Go","uri":"/posts/effective-go/"},{"categories":["Golang","effective go"],"content":"Names 命名 ","date":"2024-08-15","objectID":"/posts/effective-go/:3:0","tags":["Golang","effective go"],"title":"Effective Go","uri":"/posts/effective-go/"},{"categories":["Golang","effective go"],"content":"Package names 包名 当一个包被导入后，包名就会成为内容的访问器 import \"bytes\"，按照惯例，包应当以某个小写的单个单词命名，且不应使用下划线或驼峰记法。 例如，err 的命名就是出于简短考虑。 包名是导入时所需的唯一默认名称，它并不需要在所有源码中保持唯一，即便在少数发生冲突的情况下，也可为导入的包选择一个别名来局部使用。 另一个约定：包名应为其源码目录的基本名称。例如，src/pkg/encoding/base64 中的包应作为 encoding/basee64 导入，其包名应为 base64 而不是 encoding_base64 / encodingBase64. 长命名并不会使包更具有可读性，反而一份有用的说明文档通常比额外的长名更具价值。 ","date":"2024-08-15","objectID":"/posts/effective-go/:3:1","tags":["Golang","effective go"],"title":"Effective Go","uri":"/posts/effective-go/"},{"categories":["Golang","effective go"],"content":"Getter / Setter Go 并不对 getter 和 setter 提供自动支持。 如将 Get 放入 getter 的名字中，既不符合习惯，也没有必要，但大写字母作为字段导出的 getter 是一个不错的选择，另外 Set 放入 setter 是个不错的选择。 type Object struct { ower string } func (o *Object) Ower() string { return o.ower } func (o *Object) SetOwer(s string) { o.ower = s } ","date":"2024-08-15","objectID":"/posts/effective-go/:3:2","tags":["Golang","effective go"],"title":"Effective Go","uri":"/posts/effective-go/"},{"categories":["Golang","effective go"],"content":"Interface names 接口名 按照规定，只包含一个方法的接口应当以该方法的名称加上 er 后缀来命名，如 Reader / Writer / Formater 等。 字符串转换方法命名应为 String 而非 ToString ","date":"2024-08-15","objectID":"/posts/effective-go/:3:3","tags":["Golang","effective go"],"title":"Effective Go","uri":"/posts/effective-go/"},{"categories":["Golang","effective go"],"content":"MixedCaps 驼峰记法 Go 中约定使用驼峰记法 ","date":"2024-08-15","objectID":"/posts/effective-go/:3:4","tags":["Golang","effective go"],"title":"Effective Go","uri":"/posts/effective-go/"},{"categories":["Golang","effective go"],"content":"分号 和 C 一样，Go 的正式语法使用分号 ; 来结束语句，但 Go 的分号不一定出现在源码中，而是词法分析器会使用一条简单的规则来自动插入分号 规则：如在新行前的最后一个标记为标识符（int/float64等）、数值或字符串常量之类的基本字面或break、continue、fallthrough、return、++、--、)、} 之一，则词法分析器将始终在该标记后面插入分号，即如果新行前的标记为语句的末尾，则插入分号;。 通常，Go 程序只在诸如 for 循环子句这样的地方使用分号，来以此将初始化器、条件及增量元素分开； ","date":"2024-08-15","objectID":"/posts/effective-go/:4:0","tags":["Golang","effective go"],"title":"Effective Go","uri":"/posts/effective-go/"},{"categories":["Golang","effective go"],"content":"Control structures 控制结构 Go 不再使用 do / while 循环，只有一个更为通用的 for， // C: for for init; condition; post { } // C: while for condition { } // C: for(;;) for { } // [12]aT, []vT, map[sting]any mT for key, value := range aT/vT/mT { } for key := range aT/vT/mT { } for _, value := range aT/vT/mT { } Go 没有逗号操作符，且 ++/-- 是语句而非表达式 for i, j := 0, len(aT) - 1; i \u003c j; i, j = i + 1, j - 1 { // Not: i++, j-- a[i], a[j] = a[j], a[i] } switch 更加灵活，其表达式无需为常量或整数，case 语句会自上而下逐一进行求值直至匹配为止，它不会自动下溯，但 case 可通过逗号分隔来列举相同的处理条件 break 语句会使 switch 提前终止 func unhex(c byte) byte { switch { case '0' \u003c= c \u0026\u0026 c \u003c= '9': return c - '0' case 'a' \u003c= c \u0026\u0026 c \u003c= 'f': return c - 'a' + 10 case 'A' \u003c= c \u0026\u0026 c \u003c= 'F': return c - 'A' + 10 } return 0 } func shouldEscape(c byte) bool { switch c { case ' ', '?', '\u0026', '=', '#', '+', '%': return true } return false } if 强制使用大括号，并且接受初始化语句 if err := file.Chmod(0664); err != nil { return err } ","date":"2024-08-15","objectID":"/posts/effective-go/:5:0","tags":["Golang","effective go"],"title":"Effective Go","uri":"/posts/effective-go/"},{"categories":["Golang","effective go"],"content":"Function 函数 Go 与众不同的特性之一，就是函数和方法可以返回多个值，返回值或结果“形参”可被命名，并作常规变量使用。 Go 的 defer 语句用于预设一个函数调用（即延迟执行函数），该函数会在执行 defer 的函数返回之前立即执行。 被推迟的多个函数，会按照后进先出（LIFO）的顺序执行。 func Contents(filename string) (string, error) { f, err := os.Open(filename) if err != nil { return \"\", err } defer f.Close() var result []byte buf := make([]byte, 100) for { n, err := f.Read(buf[0:]) result = append(result, buf[0:n]...) if err != nil { if err == io.EOF { break } return \"\", err } } return string(result), nil } ","date":"2024-08-15","objectID":"/posts/effective-go/:6:0","tags":["Golang","effective go"],"title":"Effective Go","uri":"/posts/effective-go/"},{"categories":["Golang","effective go"],"content":"Data 数据 new(T) 会为类型为 T 的新项分配已置零的内存空间， 并返回它的地址，也就是一个类型为 *T 的值(返回一个指针， 该指针指向新分配的，类型为 T 的零值)。 内建函数 make(T, args) 的目的不同于 new(T)。它只用于创建切片、映射和信道，并返回类型为 T（而非 *T ）的一个已初始化 （而非置零）的值。 出现这种用差异的原因在于，这三种类型本质上为引用数据类型，它们在使用前必须初始化。 // Allocates slice structure; *p == nil; rarely useful var p *[]int = new([]int) // The slice v now refers to a new array of 100 ints var v []int = make([]int, 100) // 惯用法 v := make([]int, 100) ","date":"2024-08-15","objectID":"/posts/effective-go/:7:0","tags":["Golang","effective go"],"title":"Effective Go","uri":"/posts/effective-go/"},{"categories":["Golang","effective go"],"content":"Array 数组 数组主要用作切片的构件，主要特点： 数组是值，讲一个数组赋值给另一个数组会复制其所有元素 如将数组作为参数传入某个函数，则会收到该数组的一份副本而非指针 数组的大小是其类型的一部分 func Sum(a *[3]float64) (sum float64) { for _, v := range *a { sum += v } return } aV := [...]float64{1, 2, 0.7} fmt.Println(Sum(\u0026aV)) ","date":"2024-08-15","objectID":"/posts/effective-go/:7:1","tags":["Golang","effective go"],"title":"Effective Go","uri":"/posts/effective-go/"},{"categories":["Golang","effective go"],"content":"Slice 切片 切片通过对数组进行封装，为数据序列提供了更通用、强大而方便的接口。 slice 保存了对底层数组的引用，如将某个 slice 赋值给另一个 slice，则他们会引用同一个数组。 若某个函数将一个切片作为参数传入，则它对该切片元素的修改对调用者而言同样可见， 这可以理解为传递了底层数组的指针 只要切片不超出底层数组的限制，它的长度就是可变的，只需将它赋予其自身的切片即可。切片的容量可通过内建函数 cap 获得，它将给出该切片可取得的最大长度。 若数据超出其容量，则会重新分配该切片，返回值即为所得的切片。 尽管 Append 可修改 slice 的元素，但切片自身（其运行时数据结构包含指针、长度和容量）是通过值传递的. 二维数组 一种是独立地分配每一个切片；而另一种就是只分配一个数组， 将各个切片都指向它 // 独立地分配每一个切片 pic := make([][]uint8, YSize) for i := range pic { // 一次一行 pic[i] = make([]uint8, XSize) } // 顶层 slice pic := make([][]uint8, YSize) // 分配一个大的切片来保存所有像素 pixels := make([]uint8, XSize*YSize) // 遍历行，从剩余像素切片的前面切出每一行 for i := range pic { pic[i], pixels = picxels[:XSize], pixels[XSize:] } ","date":"2024-08-15","objectID":"/posts/effective-go/:7:2","tags":["Golang","effective go"],"title":"Effective Go","uri":"/posts/effective-go/"},{"categories":["Golang","effective go"],"content":"Map 可以关联不同类型的值。其键可以是任何相等性操作符支持的类型， 如整数、浮点数、复数、字符串、指针、接口（只要其动态类型支持相等性判断）、结构以及数组。 切片不能用作映射键，因为它们的相等性还未定义。与切片一样， 映射也是引用类型。 若将映射传入函数中，并更改了该映射的内容，则此修改对调用者同样可见。 若试图通过映射中不存在的键来取值，就会返回与该映射中项的类型对应的零值 要删除 map 中的某项，可使用内建函数 delete，它以映射及要被删除的键为实参。 即便对应的键不在该 map 中，此操作也是安全的。 ","date":"2024-08-15","objectID":"/posts/effective-go/:7:3","tags":["Golang","effective go"],"title":"Effective Go","uri":"/posts/effective-go/"},{"categories":["Golang","effective go"],"content":"Reference Effective Go ","date":"2024-08-15","objectID":"/posts/effective-go/:8:0","tags":["Golang","effective go"],"title":"Effective Go","uri":"/posts/effective-go/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":" 导语 设计模式: 在特定环境下人们解决某类重复出现的一套成功或有效的解决方案. ","date":"2024-07-28","objectID":"/posts/design-pattern/:0:0","tags":["Design Patten","Golang","C++","最佳实践"],"title":"Design Pattern","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"I. 前言 软件设计模式（Design Pattern），是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。 简单来说，设计模式就是在一定环境下，用固定套路解决问题。 设计模式的基础：多态 ","date":"2024-07-28","objectID":"/posts/design-pattern/:1:0","tags":["Design Patten","Golang","C++","最佳实践"],"title":"Design Pattern","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"面向对象设计原则 \u003e 目的：高内聚、低耦合 如何同时提⾼⼀个软件系统的可维护性和可复⽤性是⾯向对象设计需要解决的核⼼问题之⼀。 ⾯向对象设计原则为⽀持可维护性复⽤⽽诞⽣，这些原则蕴含在很多设计模式中，它们是从许多设计⽅案中总结出的指导性原则。 单一职责原则: 类的职责单⼀，对外只提供⼀种功能，⽽引起类变化的原因都应该只有⼀个 开闭原则: 类的改动是通过增加代码进⾏的，⽽不是修改源代码 里式代换原则: 任何抽象类出现的地⽅都可以⽤他的实现类进⾏替换，实际就是虚拟机制，语⾔级别实现⾯向对象功能 依赖倒转原则: 依赖于抽象(接⼝)，不要依赖具体的实现(类)，也就是针对接⼝编程 接口隔离原则: 不应该强迫⽤户的程序依赖他们不需要的接⼝⽅法。⼀个接⼝应该只提供⼀种对外功能，不应该把所有操作都封装到⼀个接⼝中去 合成复用原则: 如果使⽤继承，会导致⽗类的任何变换都可能影响到⼦类的⾏为。如果使⽤对象组合，就降低了这种依赖关系。对于继承和组合，优先使⽤组合 迪米特法则: ⼀个对象应当对其他对象尽可能少的了解，从⽽降低各个对象之间的耦合，提⾼系统的可维护性 ","date":"2024-07-28","objectID":"/posts/design-pattern/:1:1","tags":["Design Patten","Golang","C++","最佳实践"],"title":"Design Pattern","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"II. 分类 创建型（Creational）模式：如何创建对象 模式名称 用途 单例模式 🌟🌟🌟🌟 保证一个类仅有一个实例，并提供一个访问它的全局访问点 简单工厂方法 🌟🌟🌟 通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的基类 抽象工厂方法 🌟🌟🌟🌟🌟 提供一个创建一系列相关或相互依赖的接口，而无需指定它们具体的类 原型模式 ⽤原型实例指定创建对象的种类，并且通过拷⻉这些原型创建新的对象 建造者模式 将⼀个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示 结构型（Structural）模式：如何实现类或对象的组合 模式名称 用途 适配器模式 🌟🌟🌟🌟 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 桥接模式 将抽象部分与实际部分分离，使它们可以独立的变化 组合模式 🌟🌟🌟🌟 将对象组合成树形结构以表示 “部分 - 整体” 的层次结构，使得用户对单个对象和组合对象的使用具有一致性 装饰模式 🌟🌟🌟 动态地给一个对象添加一些额外的职责：就增加功能来说，此模式比生成子类更加灵活 外观模式 🌟🌟🌟🌟🌟 为子系统的一组接口提供一个一致的界面，此模式定义了一个高层次接口，使得这一子系统更容易使用 享元模式 以共享的方式高效的支持大量的细粒度的对象 代理模式 为其他对象提供一种代理以控制这个对象的访问 行为型（Behavioral）模式：类或对象如何交互以及如何分配指责 ","date":"2024-07-28","objectID":"/posts/design-pattern/:2:0","tags":["Design Patten","Golang","C++","最佳实践"],"title":"Design Pattern","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"III. 创建型设计模式 ","date":"2024-07-28","objectID":"/posts/design-pattern/:3:0","tags":["Design Patten","Golang","C++","最佳实践"],"title":"Design Pattern","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"1. 单例模式（Singleton Pattern） 意图：它是一种创建型设计模式，限制了实例化类的对象个数，确保一个类只有一个实例，并且提供一个全局访问点。 warning Singleton Pattern 同时解决了两个问题，因此违法了单一职责原则: 保证一个类只用一个实例。 为该实例提供一个全局访问节点。 应用场景 配置管理器：在应用程序中，配置信息通常需要一个实例来管理，如此可以保证配置信息的一致性 连接池：数据库连接池需要限制数据库连接的数量，以避免过多的连接消耗资源 日志记录器：日志系统通常只需要一个实例来记录应用程序的日志信息，以避免日志信息的冗余和混乱 硬件管理器：对于某些硬件设备，如打印机 / 扫描仪等，可能只需要一个管理器来控制对它们的访问 应用状态管理：在某些应用中，需要全局的管理状态，如用户会话管理或权限验证状态 解决方案 将默认构造函数设为私有，防止其他对象使用单例类的 new 运算符 新建一个静态构建方法作为构造函数：该函数会“偷偷”调用私有构造函数来创建对象，并将其保存到一个静态成员变量中，之后所有对于该函数的调用都将返回这一缓存对象。 单例模式结构 与其他模式的关系 外观模式类通常可以转化为单例模式类，因为在大部分情况下一个外观对象就足够啦 如果能将对象的所有共享状态简化为一个享元对象，那么享元模式就和单例类似，但二者有两个根本性的不同： 单例只有一个单例实体，但享元类可以有多个实体，各实体的内在状态也可以不同 单例对象可以是可变的，享元对象不可变 抽象工厂模式、生成器模式和原型模式都可以用单例来实现 应用示例 // singleton.go package designpattern import \"sync\" var once sync.Once type Singleton struct { str string } var instance *Singleton func GetInstance() *Singleton { if instance != nil { return instance } once.Do(func() { instance = \u0026Singleton{} }) return instance } ","date":"2024-07-28","objectID":"/posts/design-pattern/:3:1","tags":["Design Patten","Golang","C++","最佳实践"],"title":"Design Pattern","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"2. 简单工厂模式 亦称：虚拟构造函数、Virtual Constructor、Factory Method 意图：它是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型 NOTE: 由于 Golang 中缺少类和继承等 OOP 特性，因此，无法使用 Go 来实现经典的工厂方法模式，但我们仍能实现基础版本，即简单工厂。 ","date":"2024-07-28","objectID":"/posts/design-pattern/:3:2","tags":["Design Patten","Golang","C++","最佳实践"],"title":"Design Pattern","uri":"/posts/design-pattern/"},{"categories":["Design Patten","Golang","C++","最佳实践"],"content":"3. 观察者模式（Observer） 亦称：事件订阅者、监听者、Event-Subscriber、Listener 意图：它是一种行为型设计模式，允许定义一种订阅机制，可在对象事件发生时通知多个 “观察” 该对象的其他对象。 拥有一些值得关注的对象通常被称为目标，由于它要将自身状态的变化通知给其他对象，因此也被称为发布者(publisher)，而其他关注发布者状态变化的对象被称为订阅者(subscriber) Observer 核心机制 Observer 模式建议为发布者类添加订阅机制，让每个对象都能订阅或取消订阅发布者事件流。 实际上，该机制包括： 一个用于存储订阅者对象引用的列表成员变量 几个用于添加或删除该列表中订阅者的公有方法 ","date":"2024-07-28","objectID":"/posts/design-pattern/:3:3","tags":["Design Patten","Golang","C++","最佳实践"],"title":"Design Pattern","uri":"/posts/design-pattern/"},{"categories":["Golang","Project Layout","Stardard"],"content":" 导语 Go 应用程序项目的基本布局介绍 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:0:0","tags":["Golang","Project Layout","Stardard"],"title":"Golang Project Stardard Layout","uri":"/posts/golang-project-layout/"},{"categories":["Golang","Project Layout","Stardard"],"content":"Go Module 从 Go 1.14 版本开始，除非存在特定不使用 Go Modules 的理由，否则请使用，并且一旦使用，就无需再担心 $GOPATH 以及项目的存放位置。 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:1:0","tags":["Golang","Project Layout","Stardard"],"title":"Golang Project Stardard Layout","uri":"/posts/golang-project-layout/"},{"categories":["Golang","Project Layout","Stardard"],"content":"Go 目录 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:0","tags":["Golang","Project Layout","Stardard"],"title":"Golang Project Stardard Layout","uri":"/posts/golang-project-layout/"},{"categories":["Golang","Project Layout","Stardard"],"content":"/cmd /cmd，本项目的主干，其中每一个应用程序的目录名应该与你想要的可执行程序的名称相对应，例如 /cmd/myApp。 在 /cmd 目录下，不应该放置太多代码： 如果认为代码可以导入并可在其他项目中使用，那么它应该位于 /pkg 目录中. 如果代码不是可重用的，或者不希望其他人重用它，那么应该位于 /internal 目录中. 该目录下，通常有一个小的 main 函数，从 /internal 和 pkg 目录中导入和调用代码，除此之外没有别的东西. 微服务中的 app 服务类型分为4类：interface、service、job、admin |---cmd | |---kydenapp-admin | |---kydenapp-interface | |---kydenapp-job | |---kydenapp-service | |---kydenapp-task interface: 对外的 BFF 服务，接受来自用户的请求，比如暴露了 HTTP/gRPC 接口 service: 对内的微服务，仅接受来自内部其他服务或网关的请求，比如暴露了 gRPC 接口只对内服务 admin: 区别于 service，更多是面向运营测的服务，通常数据权限更高，隔离带来更好的代码级别安全 job: 流式任务处理的服务，上游一般依赖 message broker task: 定时任务，类似 cronjob，部署到 task 托管平台中 /cmd 应用目录负责程序的: 启动、关闭、配置初始化等 DTO(Data Transfer Object)，数据传输对象，这个概念来源于 J2EE 的设计模式， 但这里泛指用于展示层/API层与服务层（业务逻辑层）之间的数据传输对象。 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:1","tags":["Golang","Project Layout","Stardard"],"title":"Golang Project Stardard Layout","uri":"/posts/golang-project-layout/"},{"categories":["Golang","Project Layout","Stardard"],"content":"internal internal，私有应用程序和库代码，它是不希望其他人在其应用程序或库中导入的代码。 该目录由 Go 强制执行，确保私有包不可导入。 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:2","tags":["Golang","Project Layout","Stardard"],"title":"Golang Project Stardard Layout","uri":"/posts/golang-project-layout/"},{"categories":["Golang","Project Layout","Stardard"],"content":"pkg /pkg，外部应用程序可以使用的库代码（例如 /pkg/mypubliclib）. 如果应用程序项目真的很小，并且额外的嵌套并不能增加多少价值(除非你真的想要:-)，那就不要使用它。 当它变得足够大时，根目录会变得非常繁琐时(尤其是当你有很多非 Go 应用组件时)，请考虑使用。 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:3","tags":["Golang","Project Layout","Stardard"],"title":"Golang Project Stardard Layout","uri":"/posts/golang-project-layout/"},{"categories":["Golang","Project Layout","Stardard"],"content":"api /api，协议定义目录，(xxapi.proto) protobuf 文件，以及生成的 go 文件。 通常把 api 文档直接在 proto 文件中描述。 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:4","tags":["Golang","Project Layout","Stardard"],"title":"Golang Project Stardard Layout","uri":"/posts/golang-project-layout/"},{"categories":["Golang","Project Layout","Stardard"],"content":"configs 配置文件模版或默认配置 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:5","tags":["Golang","Project Layout","Stardard"],"title":"Golang Project Stardard Layout","uri":"/posts/golang-project-layout/"},{"categories":["Golang","Project Layout","Stardard"],"content":"scripts 执行各种构建、安装、分析等操作的脚本，是的根级别的 Makefile 变得小而简单 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:6","tags":["Golang","Project Layout","Stardard"],"title":"Golang Project Stardard Layout","uri":"/posts/golang-project-layout/"},{"categories":["Golang","Project Layout","Stardard"],"content":"test 额外的外部测试应用程序和测试数据 Go 会忽略以 . 或 _ 开头的目录和文件 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:7","tags":["Golang","Project Layout","Stardard"],"title":"Golang Project Stardard Layout","uri":"/posts/golang-project-layout/"},{"categories":["Golang","Project Layout","Stardard"],"content":"docs 设计和用户文档（godoc 生成的文档除外） ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:8","tags":["Golang","Project Layout","Stardard"],"title":"Golang Project Stardard Layout","uri":"/posts/golang-project-layout/"},{"categories":["Golang","Project Layout","Stardard"],"content":"tools 项目的支持工具，可以从 /pkg 和 /internal 目录导入代码 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:9","tags":["Golang","Project Layout","Stardard"],"title":"Golang Project Stardard Layout","uri":"/posts/golang-project-layout/"},{"categories":["Golang","Project Layout","Stardard"],"content":"examples 应用程序和/或公共库的示例 ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:10","tags":["Golang","Project Layout","Stardard"],"title":"Golang Project Stardard Layout","uri":"/posts/golang-project-layout/"},{"categories":["Golang","Project Layout","Stardard"],"content":"third_party 外部辅助工具，分叉代码和其他第三方工具（例如 Swagger UI） ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:11","tags":["Golang","Project Layout","Stardard"],"title":"Golang Project Stardard Layout","uri":"/posts/golang-project-layout/"},{"categories":["Golang","Project Layout","Stardard"],"content":"assets 与存储库一起使用的其他资源（图像、徽标等） 按理来说我们不应该 src 目录，但有些 Go 项目拥有一个 src 文件夹，这通常发生在开发人员具有 Java 背景 $GOPATH 环境变量指向你的(当前)工作空间(默认情况下，它指向非 windows 系统上的 $HOME/go)，这个工作空间包括顶层 /pkg, /bin 和 /src 目录，而实际项目最终是 /src 下的一个子目录，即 /xxx/workspace/src/proj/src/xxx.go（Go 1.11 之后，项目 proj 可以放在 GOPATH 之外）. ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:2:12","tags":["Golang","Project Layout","Stardard"],"title":"Golang Project Stardard Layout","uri":"/posts/golang-project-layout/"},{"categories":["Golang","Project Layout","Stardard"],"content":"Reference https://talks.golang.org/2014/names.slide https://golang.org/doc/effective_go.html#names https://blog.golang.org/package-names https://go.dev/wiki/CodeReviewComments Style guideline for Go packages (rakyll/JBD) ","date":"2024-07-13","objectID":"/posts/golang-project-layout/:3:0","tags":["Golang","Project Layout","Stardard"],"title":"Golang Project Stardard Layout","uri":"/posts/golang-project-layout/"},{"categories":["Golang","Context"],"content":" 导语 当需要在多个 Goroutine 中传递上下文信息时，可以使用 Context 实现 ","date":"2024-06-01","objectID":"/posts/golang-context/:0:0","tags":["Golang","Context"],"title":"浅析 Golang Context","uri":"/posts/golang-context/"},{"categories":["Golang","Context"],"content":"Context Context 除了用来传递上下文信息，还可以用来传递终结执行子任务的相关信号，终止多个执行子任务的 Goroutine。 context.Context 接口数据结构： // A Context carries a deadline, a cancellation signal, and other values across // API boundaries. // // Context's methods may be called by multiple goroutines simultaneously. type Context interface { // Deadline returns the time when work done on behalf of this context // should be canceled. Deadline returns ok==false when no deadline is // set. Successive calls to Deadline return the same results. Deadline() (deadline time.Time, ok bool) // Done returns a channel that's closed when work done on behalf of this // context should be canceled. Done may return nil if this context can // never be canceled. Successive calls to Done return the same value. // The close of the Done channel may happen asynchronously, // after the cancel function returns. // // WithCancel arranges for Done to be closed when cancel is called; // WithDeadline arranges for Done to be closed when the deadline // expires; WithTimeout arranges for Done to be closed when the timeout // elapses. // // Done is provided for use in select statements: // // // Stream generates values with DoSomething and sends them to out // // until DoSomething returns an error or ctx.Done is closed. // func Stream(ctx context.Context, out chan\u003c- Value) error { // for { // v, err := DoSomething(ctx) // if err != nil { // return err // } // select { // case \u003c-ctx.Done(): // return ctx.Err() // case out \u003c- v: // } // } // } // // See https://blog.golang.org/pipelines for more examples of how to use // a Done channel for cancellation. Done() \u003c-chan struct{} // If Done is not yet closed, Err returns nil. // If Done is closed, Err returns a non-nil error explaining why: // Canceled if the context was canceled // or DeadlineExceeded if the context's deadline passed. // After Err returns a non-nil error, successive calls to Err return the same error. Err() error // Value returns the value associated with this context for key, or nil // if no value is associated with key. Successive calls to Value with // the same key returns the same result. // // Use context values only for request-scoped data that transits // processes and API boundaries, not for passing optional parameters to // functions. // // A key identifies a specific value in a Context. Functions that wish // to store values in Context typically allocate a key in a global // variable then use that key as the argument to context.WithValue and // Context.Value. A key can be any type that supports equality; // packages should define keys as an unexported type to avoid // collisions. // // Packages that define a Context key should provide type-safe accessors // for the values stored using that key: // // // Package user defines a User type that's stored in Contexts. // package user // // import \"context\" // // // User is the type of value stored in the Contexts. // type User struct {...} // // // key is an unexported type for keys defined in this package. // // This prevents collisions with keys defined in other packages. // type key int // // // userKey is the key for user.User values in Contexts. It is // // unexported; clients use user.NewContext and user.FromContext // // instead of using this key directly. // var userKey key // // // NewContext returns a new Context that carries value u. // func NewContext(ctx context.Context, u *User) context.Context { // return context.WithValue(ctx, userKey, u) // } // // // FromContext returns the User value stored in ctx, if any. // func FromContext(ctx context.Context) (*User, bool) { // u, ok := ctx.Value(userKey).(*User) // return u, ok // } Value(key any) any } Deadline：返回 Context 被取消的时间，也就是完成工作的截至日期； Done：返回一个 channel，这个 channel 会在当前工作完成或者上下文被取消之后关闭，多次调用 Done 方法会返回同一个 channel； Err：放回 Context 结束的原因，只会在 Done 返回的 channel 被关闭时才会返回非空的值，如果 Context 被取消，会返回 Canceled 错误；如果 Context 超时，会返回 DeadlineExceeded 错误； Value：可用于从 Context 中获取传递的键值信息； ","date":"2024-06-01","objectID":"/posts/golang-context/:1:0","tags":["Golang","Context"],"title":"浅析 Golang Context","uri":"/posts/golang-context/"},{"categories":["Golang","Context"],"content":"Example 在 Web 请求的处理过程中，一个请求可能启动多个 goroutine 协同工作，这些 goroutine 之间可能需要共享请求的信息，且当请求被取消或者执行超时时，该请求对应的所有 goroutine 都需要快速结束，释放资源，Context 就是为了解决上述场景而开发的。 package main import ( \"context\" \"fmt\" \"time\" ) const DB_ADDRESS = \"db_address\" const CALCULATE_VALUE = \"calculate_value\" func readDB(ctx context.Context, cost time.Duration) { fmt.Println(\"DB address is \", ctx.Value(DB_ADDRESS)) select { case \u003c-time.After(cost): fmt.Println(\"read data from db\") case \u003c-ctx.Done(): fmt.Println(ctx.Err()) } } func calculate(ctx context.Context, cost time.Duration) { fmt.Println(\"calculate value is\", ctx.Value(CALCULATE_VALUE)) select { case \u003c-time.After(cost): // 模拟数据计算 fmt.Println(\"calculate finish\") case \u003c-ctx.Done(): fmt.Println(ctx.Err()) // 任务取消的原因 // 一些清理工作 } } func main() { ctx := context.Background() // Add Context info ctx = context.WithValue(ctx, DB_ADDRESS, \"localhost:3306\") ctx = context.WithValue(ctx, CALCULATE_VALUE, \"123\") ctx, cancel := context.WithTimeout(ctx, time.Second*2) defer cancel() go readDB(ctx, time.Second*4) go calculate(ctx, time.Second*4) time.Sleep(time.Second * 5) } 使用 Context，能够有效地在一组 goroutine 中传递共享值、取消信号、deadline 等信息，及时关闭不需要的 goroutine。 ","date":"2024-06-01","objectID":"/posts/golang-context/:2:0","tags":["Golang","Context"],"title":"浅析 Golang Context","uri":"/posts/golang-context/"},{"categories":["Golang","Context"],"content":"Reference Go Context ","date":"2024-06-01","objectID":"/posts/golang-context/:3:0","tags":["Golang","Context"],"title":"浅析 Golang Context","uri":"/posts/golang-context/"},{"categories":["Golang","逃逸分析","Escape Analysis","Heap","Stack"],"content":" 导语 深入理解 Golang Escape Analysis：变量何时逃逸？ ","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/:0:0","tags":["Golang","逃逸分析","Escape Analysis","Heap","Stack"],"title":"深入探讨 Golang Escape Analysis","uri":"/posts/golang-escape-analysis/"},{"categories":["Golang","逃逸分析","Escape Analysis","Heap","Stack"],"content":"I. Golang Escape Ananlysis Golang 编译器会自动决定把一个变量放在堆栈还是栈上，即逃逸分析（Escape Analysis）. Go 声称逃逸分析可以释放程序员关于内存的使用限制，更多地关注程序逻辑本身。 ","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/:1:0","tags":["Golang","逃逸分析","Escape Analysis","Heap","Stack"],"title":"深入探讨 Golang Escape Analysis","uri":"/posts/golang-escape-analysis/"},{"categories":["Golang","逃逸分析","Escape Analysis","Heap","Stack"],"content":"II. 逃逸规则 众所周知，当变量需要使用堆（heap）空间时，那么变量就应该进行逃逸。 一般情况下，一个引用对象中的引用类成员进行赋值，可能出现逃逸现象：可以理解为访问一个引用对象实际上底层就是通过一个指针来间接的访问，但如果再访问里面的引用成员就会有第二次间接访问，这样操作这部分对象的话，极大可能会出现逃逸的现象。 Golang 中的引用类型有函数类型 func()，接口类型 interface，切片类型 slice，字典类型 map，管道类型 channel，指针类型 * 等。 ","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/:2:0","tags":["Golang","逃逸分析","Escape Analysis","Heap","Stack"],"title":"深入探讨 Golang Escape Analysis","uri":"/posts/golang-escape-analysis/"},{"categories":["Golang","逃逸分析","Escape Analysis","Heap","Stack"],"content":"逃逸场景I： []interface{} 使用 [] 赋值 []interface{} 数据类型，必定逃逸 package main import \"fmt\" func main() { data := []interface{}{1, 2} val := data[0] fmt.Printf(\"%v\\n\", val) data[0] = 3 } $ go build -v -gcflags='-m' ./main.go command-line-arguments # command-line-arguments ./main.go:8:12: inlining call to fmt.Printf ./main.go:6:23: []interface {}{...} does not escape ./main.go:6:24: 1 escapes to heap ./main.go:6:27: 2 escapes to heap ./main.go:8:12: ... argument does not escape ./main.go:9:12: 3 escapes to heap ","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/:2:1","tags":["Golang","逃逸分析","Escape Analysis","Heap","Stack"],"title":"深入探讨 Golang Escape Analysis","uri":"/posts/golang-escape-analysis/"},{"categories":["Golang","逃逸分析","Escape Analysis","Heap","Stack"],"content":"逃逸场景II： map[string]interface{} 使用 [] 赋值 map[string]interface{} 数据类型，必定逃逸 package main import \"fmt\" func main() { dat := make(map[string]interface{}) dat[\"BlogName\"] = \"Kyden's Blog\" val := dat[\"BlogName\"] fmt.Printf(\"%v\\n\", val) } $ go build -v -gcflags='-m' ./main.go command-line-arguments # command-line-arguments ./main.go:9:12: inlining call to fmt.Printf ./main.go:6:13: make(map[string]interface {}) does not escape ./main.go:7:20: \"Kyden's Blog\" escapes to heap ./main.go:9:12: ... argument does not escape ","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/:2:2","tags":["Golang","逃逸分析","Escape Analysis","Heap","Stack"],"title":"深入探讨 Golang Escape Analysis","uri":"/posts/golang-escape-analysis/"},{"categories":["Golang","逃逸分析","Escape Analysis","Heap","Stack"],"content":"逃逸场景 III： map[interface{}]interface{} 使用 [] 赋值 map[interface{}]interface{} 数据类型，必定逃逸 package main import ( \"fmt\" ) func main() { dat := make(map[interface{}]interface{}) dat[\"BlogName\"] = \"Kyden's Blog\" val := dat[\"BlogName\"] fmt.Printf(\"%v\\n\", val) } $ go build -v -gcflags='-m' ./main.go command-line-arguments # command-line-arguments ./main.go:11:12: inlining call to fmt.Printf ./main.go:8:13: make(map[interface {}]interface {}) does not escape ./main.go:9:6: \"BlogName\" escapes to heap ./main.go:9:20: \"Kyden's Blog\" escapes to heap ./main.go:10:13: \"BlogName\" does not escape ./main.go:11:12: ... argument does not escape ","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/:2:3","tags":["Golang","逃逸分析","Escape Analysis","Heap","Stack"],"title":"深入探讨 Golang Escape Analysis","uri":"/posts/golang-escape-analysis/"},{"categories":["Golang","逃逸分析","Escape Analysis","Heap","Stack"],"content":"逃逸场景 IV：map[string][]string map[string][]string 数据类型，赋值会发生 []string 逃逸 package main import ( \"fmt\" ) func main() { dat := make(map[string][]string) dat[\"BlogName\"] = []string{\"Kyden's Blog\"} val := dat[\"BlogName\"] fmt.Printf(\"%v\\n\", val) } $ go build -v -gcflags='-m' ./main.go command-line-arguments # command-line-arguments ./main.go:11:12: inlining call to fmt.Printf ./main.go:8:13: make(map[string][]string) does not escape ./main.go:9:28: []string{...} escapes to heap ./main.go:11:12: ... argument does not escape ./main.go:11:21: val escapes to heap ","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/:2:4","tags":["Golang","逃逸分析","Escape Analysis","Heap","Stack"],"title":"深入探讨 Golang Escape Analysis","uri":"/posts/golang-escape-analysis/"},{"categories":["Golang","逃逸分析","Escape Analysis","Heap","Stack"],"content":"逃逸场景 V：[]*int []*int 数据类型，赋值的右值会发生逃逸 package main import \"fmt\" func main() { dat := []*int{nil} a := 10 dat[0] = \u0026a fmt.Printf(\"%v\\r\\n\", *dat[0]) fmt.Printf(\"%v\\r\\n\", dat[0]) } $ go build -v -gcflags='-m' ./main.go command-line-arguments # command-line-arguments ./main.go:9:12: inlining call to fmt.Printf ./main.go:10:12: inlining call to fmt.Printf ./main.go:7:2: moved to heap: a ./main.go:6:15: []*int{...} does not escape ./main.go:9:12: ... argument does not escape ./main.go:9:23: *dat[0] escapes to heap ./main.go:10:12: ... argument does not escape ","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/:2:5","tags":["Golang","逃逸分析","Escape Analysis","Heap","Stack"],"title":"深入探讨 Golang Escape Analysis","uri":"/posts/golang-escape-analysis/"},{"categories":["Golang","逃逸分析","Escape Analysis","Heap","Stack"],"content":"逃逸场景 VI：func(*int) func(*int) 数据类型，进行函数赋值，会使传递的形参逃逸 package main import \"fmt\" func f(a *int) { fmt.Printf(\"%v\\n\", *a) return } func main() { a := 10 fn := f fn(\u0026a) fmt.Printf(\"a = %v\\n\", a) } $ go build -v -gcflags='-m' ./main.go # command-line-arguments ./main.go:6:12: inlining call to fmt.Printf ./main.go:14:12: inlining call to fmt.Printf ./main.go:5:8: a does not escape ./main.go:6:12: ... argument does not escape ./main.go:6:21: *a escapes to heap ./main.go:14:12: ... argument does not escape ./main.go:14:25: a escapes to heap ","date":"2024-05-19","objectID":"/posts/golang-escape-analysis/:2:6","tags":["Golang","逃逸分析","Escape Analysis","Heap","Stack"],"title":"深入探讨 Golang Escape Analysis","uri":"/posts/golang-escape-analysis/"},{"categories":["Golang","GMP","Goroutine","Machine","Process"],"content":" 导语 Go 的调度流程本质上是一个生产-消费流程. ","date":"2024-05-15","objectID":"/posts/golang-gmp/:0:0","tags":["Golang","GMP","Goroutine","Machine","Process"],"title":"深入理解 Golang GMP","uri":"/posts/golang-gmp/"},{"categories":["Golang","GMP","Goroutine","Machine","Process"],"content":"I. Process、Thread、Co-routine ","date":"2024-05-15","objectID":"/posts/golang-gmp/:1:0","tags":["Golang","GMP","Goroutine","Machine","Process"],"title":"深入理解 Golang GMP","uri":"/posts/golang-gmp/"},{"categories":["Golang","GMP","Goroutine","Machine","Process"],"content":"进程 Process 在操作系统中，进程使用进程控制块 (PCB, Process Control Block) 数据结构 task_struct 来描述，PCB 是进程存在的唯一标识。 进程是指在系统中正在运行的一个应用程序，程序一旦运行就是进程； 进程可以认为是程序执行的一个实例，进程是系统进行资源分配的最小单位，且每个进程拥有独立的地址空间； 一个进程无法直接访问到另一个进程的变量和数据结构，如果希望一个进程去访问另一个进程的资源，需要使用进程间的通信，如fifo、pipe、signal、socket 等； 进程调度算法：先来先服务调度算法、短作业优先调度算法、最短剩余作业优先调度算法、最高响应比优先调度算法、最高优先级优先调度算法、时间片轮转算法（公平调度，$20 - 50 ms$）、多级反馈队列调度算法($最高优先级 + 时间片轮转$)； ","date":"2024-05-15","objectID":"/posts/golang-gmp/:1:1","tags":["Golang","GMP","Goroutine","Machine","Process"],"title":"深入理解 Golang GMP","uri":"/posts/golang-gmp/"},{"categories":["Golang","GMP","Goroutine","Machine","Process"],"content":"线程 Thread 用户态线程，是基于用户态的线程管理库来实现的，线程控制块 (Thread Control Block) 也是在库里实现，操作系统只能看到整个进程的PCB，即进程与用户线程属于多对一的模型。 内核态线程(Thread)，是由操作系统管理，对应的 TCB 存储在操作系统里，且其创建、销毁、调度都由操作系统完成； 轻量级线程 LWP(Light-weight process)，是由内核支持的用户线程，一个进程可以有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，即 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度。 在大多数系统中，LWP 和 普通进程的区别在于，LWP 只有一个最小的执行上下文和调度程序所需的统计信息。 线程是进程的一个实体，是进程的一条执行路径； 线程是比进程更小的独立运行的基本单位 一个程序至少存在一个进程，一个进程可以有多个($\u003e=1$)线程 进程与线程的区别 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位； 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈； 同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间； 同一进程内的线程共享本地的资源，但是进程之间的资源是独立的； 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程崩溃，即多进程比多线程健壮； 进程切换，消耗的资源大（主要是虚拟地址空间的切换开销），线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系； 多进程、多线程都可以并发执行，线程能减少并发执行的时间和空间开销； 每个独立的进程有一个程序入口、程序出口；线程不能独立运行，必须依存于应用程序中，有应用程序提供多个线程执行控制； ","date":"2024-05-15","objectID":"/posts/golang-gmp/:1:2","tags":["Golang","GMP","Goroutine","Machine","Process"],"title":"深入理解 Golang GMP","uri":"/posts/golang-gmp/"},{"categories":["Golang","GMP","Goroutine","Machine","Process"],"content":"协程 Co-routine 协程，又称 “微线程”，表现为一个可以 suspend 和 resume 的函数。 实现协程的关键点：在于如何保存、恢复和切换上下文，协程切换只涉及基本的CPU上下文切换（CPU寄存器）. 所有的协程共用的都是一个栈，即系统栈，也就也不必我们自行去给协程分配栈，因为是函数调用，我们当然也不必去显示的保存寄存器的值； Co-routine 分类 有栈 (stackful) 协程：实现类似于内核态线程的实现，不同协程的切换还是要切换对应的栈上下文，只是不用陷入内核，例如 goroutine、libco 无栈 (stackless) 协程：无栈协程的上下文都会放到公共内存中，在协程切换时使用状态机来切换，而不用切换对应的上下文（都已经在堆中），相比有栈协程更轻量，例如 C++20、Rust、JavaScript；==本质就是一个状态机（state machine），即同一协程协程的切换本质不过是指令指针寄存器的改变== Co-routine 特点 一个线程可以有多个协程；协程不是被操作系统内核管理，而是完全由程序控制； 协程的开销远远小于线程；协程拥有自己的寄存器上下文和栈，在进行协程调度时，将寄存器上下文和栈保存到其他地方，在切换回来时恢复先前保存的寄存器上下文和栈； 每个协程表示一个执行单元，有自己的本地数据，与其他协程共享全局数据和其他资源； 跨平台、跨体系架构、无需线程上下文切换的开销、方便切换控制流，简化编程模型； 协程的执行效率极高，和多线程相比，线程数量越多，协程的性能优势越明显； ","date":"2024-05-15","objectID":"/posts/golang-gmp/:1:3","tags":["Golang","GMP","Goroutine","Machine","Process"],"title":"深入理解 Golang GMP","uri":"/posts/golang-gmp/"},{"categories":["Golang","GMP","Goroutine","Machine","Process"],"content":"II. GMP Golang 为提供更加容易使用的并发工具，基于 GMP 模型实现了 goroutine 和 channel。 Goroutine 属于 Co-routine 的概念，非常轻量，一个 goroutine 初始空间只占几 KB 且可伸缩，使得在有限空间内支持大量 goroutine 并发。 Channel 可以独立创建和存取，在不同的 Goroutine 中传递使用，作为队列，遵循 FIFO 原则，同时保证同一时刻只能有一个 goroutine 访问。 channel 作为一种引用类型，声明时需要指定传输数据类型，声明形式如下(T 是 channel 可传输的数据类型)： // 声明 channel var ch chan T // 双向 channel var ch chan\u003c- T // 只能发送 msg 的 channel var ch \u003c-chan T // 只能接收 msg 的 channel // 创建 channel ch := make(chan T, capicity) // 双向 channel ch := make(chan\u003c- T, capicity) // 只能发送 msg 的 channel ch := make(\u003c-chan T, capicity) // 只能接收 msg 的 channel // 访问 channel ch \u003c- msg // 发送 msg msg := \u003c-ch // 接收 msg msg, ok := \u003c-ch // 接收 msg，同时判断 channel 是否接收成功 close(ch) // 关闭 channel ","date":"2024-05-15","objectID":"/posts/golang-gmp/:2:0","tags":["Golang","GMP","Goroutine","Machine","Process"],"title":"深入理解 Golang GMP","uri":"/posts/golang-gmp/"},{"categories":["Golang","GMP","Goroutine","Machine","Process"],"content":"Golang 调度 调度组件 G：Goroutine，一个计算任务. 由需要执行的代码和其上下文组成，上下文包括：当前代码位置、栈空间(初始2K，可增长)、状态等。 M：Machine，系统线程，执行实体。与 C 语言中的线程相同，通过 clone 创建。 P: Processor，虚拟处理器，包含了 G 运行所需的资源，因此 M 必须获得 P 才能执行代码，否则必须陷入休眠（后台监控线程除外）。可理解为一种 token，有这个 token，才有在物理 CPU 核心上执行的权限。 相关数据结构定义如下： g 的数据结构： type g struct { // Stack parameters. // stack describes the actual stack memory: [stack.lo, stack.hi). // stackguard0 is the stack pointer compared in the Go stack growth prologue. // It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption. // stackguard1 is the stack pointer compared in the //go:systemstack stack growth prologue. // It is stack.lo+StackGuard on g0 and gsignal stacks. // It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash). stack stack // offset known to runtime/cgo stackguard0 uintptr // offset known to liblink stackguard1 uintptr // offset known to liblink _panic *_panic // innermost panic - offset known to liblink _defer *_defer // innermost defer m *m // current m; offset known to arm liblink sched gobuf syscallsp uintptr // if status==Gsyscall, syscallsp = sched.sp to use during gc syscallpc uintptr // if status==Gsyscall, syscallpc = sched.pc to use during gc stktopsp uintptr // expected sp at top of stack, to check in traceback // param is a generic pointer parameter field used to pass // values in particular contexts where other storage for the // parameter would be difficult to find. It is currently used // in four ways: // 1. When a channel operation wakes up a blocked goroutine, it sets param to // point to the sudog of the completed blocking operation. // 2. By gcAssistAlloc1 to signal back to its caller that the goroutine completed // the GC cycle. It is unsafe to do so in any other way, because the goroutine's // stack may have moved in the meantime. // 3. By debugCallWrap to pass parameters to a new goroutine because allocating a // closure in the runtime is forbidden. // 4. When a panic is recovered and control returns to the respective frame, // param may point to a savedOpenDeferState. param unsafe.Pointer atomicstatus atomic.Uint32 stackLock uint32 // sigprof/scang lock; TODO: fold in to atomicstatus goid uint64 schedlink guintptr waitsince int64 // approx time when the g become blocked waitreason waitReason // if status==Gwaiting preempt bool // preemption signal, duplicates stackguard0 = stackpreempt preemptStop bool // transition to _Gpreempted on preemption; otherwise, just deschedule preemptShrink bool // shrink stack at synchronous safe point // asyncSafePoint is set if g is stopped at an asynchronous // safe point. This means there are frames on the stack // without precise pointer information. asyncSafePoint bool paniconfault bool // panic (instead of crash) on unexpected fault address gcscandone bool // g has scanned stack; protected by _Gscan bit in status throwsplit bool // must not split stack // activeStackChans indicates that there are unlocked channels // pointing into this goroutine's stack. If true, stack // copying needs to acquire channel locks to protect these // areas of the stack. activeStackChans bool // parkingOnChan indicates that the goroutine is about to // park on a chansend or chanrecv. Used to signal an unsafe point // for stack shrinking. parkingOnChan atomic.Bool // inMarkAssist indicates whether the goroutine is in mark assist. // Used by the execution tracer. inMarkAssist bool coroexit bool // argument to coroswitch_m raceignore int8 // ignore race detection events nocgocallback bool // whether disable callback from C tracking bool // whether we're tracking this G for sched latency statistics trackingSeq uint8 // used to decide whether to track this G trackingStamp int64 // timestamp of when the G last started being tracked runnableTime int64 // the amount of time spent runnable, cleared when running, only used when tracking lockedm muintptr sig uint32 writebuf []byte sigcode0 uintptr sigcode1 uintptr sigpc uintptr parentGoid uint64 // goid of g","date":"2024-05-15","objectID":"/posts/golang-gmp/:2:1","tags":["Golang","GMP","Goroutine","Machine","Process"],"title":"深入理解 Golang GMP","uri":"/posts/golang-gmp/"},{"categories":["Golang","GMP","Goroutine","Machine","Process"],"content":"Goroutine 切换成本 gobuf 描述了一个 Goroutine 所有现场，从一个 g 切换到另一个 g，只要把这几个现场字段保存下来，再将 g 入队，M 就可以执行其他 g 了，无需进入内核态。 gobuf 数据结构如下 type gobuf struct { // The offsets of sp, pc, and g are known to (hard-coded in) libmach. // // ctxt is unusual with respect to GC: it may be a // heap-allocated funcval, so GC needs to track it, but it // needs to be set and cleared from assembly, where it's // difficult to have write barriers. However, ctxt is really a // saved, live register, and we only ever exchange it between // the real register and the gobuf. Hence, we treat it as a // root during stack scanning, which means assembly that saves // and restores it doesn't need write barriers. It's still // typed as a pointer so that any other writes from Go get // write barriers. sp uintptr pc uintptr g guintptr ctxt unsafe.Pointer ret uintptr lr uintptr bp uintptr // for framepointer-enabled architectures } ","date":"2024-05-15","objectID":"/posts/golang-gmp/:2:2","tags":["Golang","GMP","Goroutine","Machine","Process"],"title":"深入理解 Golang GMP","uri":"/posts/golang-gmp/"},{"categories":["Golang","GMP","Goroutine","Machine","Process"],"content":"runtime 可拦截 goroutine 阻塞场景解析 Goroutine 属于协程的一种，因此存在运行态、阻塞态等各种状态。 那么 goroutine 什么情况下会发生阻塞？ 当 goroutine 发生阻塞时，GMP 模型如何应对？ 显然，当 goroutine 发生可被 runtime 拦截的阻塞时，GMP 模型并不会阻塞调度循环， 而是把 goroutine 挂起，即让 g 先进某个数据结构，待 ready 后在继续执行，并不会占用线程， 同时线程会进入 schedule，继续消费队列，执行其他的 g. 场景 I: 延迟 package main import ( \"fmt\" \"time\" ) func main() { fmt.Println(\"Before: \", time.Now()) time.Sleep(30 * time.Minute) fmt.Println(\"After: \", time.Now()) } 函数调用链如下： time.Sleep -\u003e runtime.timeSleep { ... gp := getg() t := gp.timer ... t.arg = gp ... } -\u003e gopark(resetForSleep, unsafe.Pointer(t), waitReasonSleep, traceBlockSleep, 1) 显然，在 runtime.timeSleep 函数中，获取到的当前 g 被挂在 runtime.timer.arg 上，然后被挂起。 场景 II: Channel send / recv (chan / select) package main import ( \"fmt\" \"sync\" \"time\" ) func main() { var ch = make(chan int) var wg = sync.WaitGroup{} wg.Add(2) go func(ch chan\u003c- int) { defer close(ch) defer wg.Done() time.Sleep(time.Second) ch \u003c- 1 }(ch) go func(ch \u003c-chan int) { defer wg.Done() val := \u003c-ch fmt.Println(val) }(ch) wg.Wait() } 函数 ch\u003c- 调用链如下： ch\u003c- -\u003e runtime.chansend1 -\u003e runtime.chansend { ... gp := getg() mysg := acquireSudog() ... gp.waiting = mysg gp.param = nil c.sendq.enqueue(mysg) // Signal to anyone trying to shrink our stack that we're about // to park on a channel. The window between when this G's status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. gp.parkingOnChan.Store(true) gopark(chanparkcommit, unsafe.Pointer(\u0026c.lock), waitReasonChanSend, traceBlockChanSend, 2) ... } -\u003e gopark 函数 ch\u003c- 调用链如下： \u003c-ch -\u003e runtime.chanrecv1(c *hchan, elem unsafe.Pointer) -\u003e runtime.chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { ... // no sender available: block on this channel. gp := getg() mysg := acquireSudog() ... gp.waiting = mysg mysg.g = gp ... c.recvq.enqueue(mysg) // Signal to anyone trying to shrink our stack that we're about // to park on a channel. The window between when this G's status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. gp.parkingOnChan.Store(true) gopark(chanparkcommit, unsafe.Pointer(\u0026c.lock), waitReasonChanReceive, traceBlockChanRecv, 2) } -\u003e runtime.gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceReason traceBlockReason, traceskip int) 根据调用链可知，g 被封装进 sudog 中，然后挂在了 hchan.sendq 链表上。 相关数据结构 sudog, sendq 如下： sudog 的数据结构： // sudog (pseudo-g) represents a g in a wait list, such as for sending/receiving // on a channel. // // sudog is necessary because the g ↔ synchronization object relation // is many-to-many. A g can be on many wait lists, so there may be // many sudogs for one g; and many gs may be waiting on the same // synchronization object, so there may be many sudogs for one object. // // sudogs are allocated from a special pool. Use acquireSudog and // releaseSudog to allocate and free them. type sudog struct { // The following fields are protected by the hchan.lock of the // channel this sudog is blocking on. shrinkstack depends on // this for sudogs involved in channel ops. g *g next *sudog prev *sudog elem unsafe.Pointer // data element (may point to stack) // The following fields are never accessed concurrently. // For channels, waitlink is only accessed by g. // For semaphores, all fields (including the ones above) // are only accessed when holding a semaRoot lock. acquiretime int64 releasetime int64 ticket uint32 // isSelect indicates g is participating in a select, so // g.selectDone must be CAS'd to win the wake-up race. isSelect bool // success indicates whether communication over channel c // succeeded. It is true if the goroutine was awoken because a // value was delivered over channel c, and false if awoken // because c was closed. success bool // waiters is a count of semaRoot waiting list other than head of list, // clamped to a uint16 to fit in unused space. // Only meaningful at the head of the list. // (If we wanted to be overly clever, we could store a high 16 bits // in the se","date":"2024-05-15","objectID":"/posts/golang-gmp/:2:3","tags":["Golang","GMP","Goroutine","Machine","Process"],"title":"深入理解 Golang GMP","uri":"/posts/golang-gmp/"},{"categories":["Golang","GMP","Goroutine","Machine","Process"],"content":"runtime 不可拦截 goroutine 阻塞场景解析 time.Sleep / channel send / channel recv / select / net read / net write / sync.Mutex 等阻塞场景可被 runtime 拦截，然而仍存在一些阻塞情况是 runtime 无法拦截的，例如：在执行 C 代码或阻塞在 syscall 上时，必须占用一个线程。 ","date":"2024-05-15","objectID":"/posts/golang-gmp/:2:4","tags":["Golang","GMP","Goroutine","Machine","Process"],"title":"深入理解 Golang GMP","uri":"/posts/golang-gmp/"},{"categories":["Golang","GMP","Goroutine","Machine","Process"],"content":"III. Sysmon system monitor，高优先级，在专有线程中执行，不需要绑定 p. ","date":"2024-05-15","objectID":"/posts/golang-gmp/:3:0","tags":["Golang","GMP","Goroutine","Machine","Process"],"title":"深入理解 Golang GMP","uri":"/posts/golang-gmp/"},{"categories":["Golang","GMP","Goroutine","Machine","Process"],"content":"IV. Summary Runtime 构成：Scheduler、Netpoll、内存管理、垃圾回收 GMP：M - 任务消费者；G - 计算任务；P - 可以使用 CPU 的 token GMP 中的队列抽象：P 的本地 runnext 字段 –» P 的 local run queue –» global run queue；采用多级队列减少锁竞争 调度循环：线程 M 在持有 P 的情况下不断消费运行队列中的 G 的过程 处理阻塞： runtime 可以接管的阻塞： channel send / recv，sync.Mutex，net read / write，select，time.Sleep 所有 runtime 可接管的阻塞都是通过 gopark / goparkunlock 挂起，goready 恢复 runtime 不可接管的阻塞：syscall，cgo，长时间运行需要剥离 P 执行； sysmon： 一个后台高级优先级循环，执行时不需要绑定任何的 P 负责： 检查是否已经没有活动线程，如果是则崩溃 轮询 netpoll 剥离在 syscall 上阻塞的 M 的 P 发信号，抢占已经执行时间过长的 G ","date":"2024-05-15","objectID":"/posts/golang-gmp/:4:0","tags":["Golang","GMP","Goroutine","Machine","Process"],"title":"深入理解 Golang GMP","uri":"/posts/golang-gmp/"},{"categories":["Golang","GMP","Goroutine","Machine","Process"],"content":"V. Q \u0026 A 为什么阻塞等待的 goroutine，有时表现为 g 有时表现为 sudog ？ sudog (pseudo-g) 表示等待列表中的 g，例如用于在 channel 上的 send/recv. g 与同步对象是多对多的关系: 一个 g 可以出现在多个等待列表中，因此一个 g 可能有多个 sudog； 很多 g 可能在等待同一个同步对象，因此一个对象可能有很多 sudog 一个 g 可能对应多个 sudog，比如一个 g 会同时 select 多个 channel ","date":"2024-05-15","objectID":"/posts/golang-gmp/:5:0","tags":["Golang","GMP","Goroutine","Machine","Process"],"title":"深入理解 Golang GMP","uri":"/posts/golang-gmp/"},{"categories":["Golang","GMP","Goroutine","Machine","Process"],"content":"VI. Reference Golang的协程调度器原理及GMP设计思想 Golang 生产-消费调度流程: Producer Golang 生产-消费调度流程: Consumer 极端情况下收缩 Go 的线程数 Go Scheduler 变更史 internal/poll/fd_poll_runtime.go internal/poll/fd_unix.go net/fd_unix.go runtime/runtime2.go runtime/time.go runtime/proc.go runtime/netpoll.go runtime/netpoll_epoll.go runtime/sema.go sync/mutex.go time/sleep.go ","date":"2024-05-15","objectID":"/posts/golang-gmp/:6:0","tags":["Golang","GMP","Goroutine","Machine","Process"],"title":"深入理解 Golang GMP","uri":"/posts/golang-gmp/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":" 导语 深入剖析 Golang 网络编程之 Netpoll，主要涉及 Linux 环境下的 Epoll 初始化、 Go 网络编程基本流程（Listen、Accept、Read、Write）以及netpoll 执行流程 Golang 源码版本 本文所涉及的源码版本：v1.22.3 ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:0:0","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Golang Netpoll","uri":"/posts/golang-netpoll/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"I. 基础概念 网络编程，是允许不同计算机上的程序通过网络通信的开发过程，涉及多种协议（HTTP、TCP/IP等）以及不同编程语言的应用。 ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:1:0","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Golang Netpoll","uri":"/posts/golang-netpoll/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"同步、异步、并发模型 IO 模型 读写操作和阻塞阶段 阻塞 IO 程序阻塞于读写函数 IO 复用 程序阻塞于 IO 复用系统调用，但可同时监听多个 IO 事件；对 IO 本身的读写操作是非阻塞的 SIGIO 信号 信号触发读写就绪事件，用户程序执行读写操作；程序本身没有阻塞阶段 异步 IO 内核执行读写操作并触发读写完成事件；程序没有阻塞阶段 主要用于区分内核向应用程序通知的是何种 IO 事件（就绪事件 or 完成事件），以及由谁来完成 IO 读写（应用程序 or 内核） IO模型中的同步 同步 IO 模型，指的是应用程序发起 IO 操作后，必须等待 IO 操作完成后才能继续执行后续的操作，即 IO 操作的结果需要立即返回给应用程序；在此期间，应用程序处于阻塞状态，无法做其他操作。 优点：编程模型简单 缺点：效率较低（应用程序的执行速度被 IO 操作所限制） 对于操作系统内核来说，同步 IO 操作是指在内核处理 IO 请求时需要等待 IO 模型中的异步 异步 IO 模型，指的是应用程序发起 IO 操作后，无须等待 IO 操作完成，可以立即进行后续的操作；在此期间，操作系统负责把 IO 操作的结果返回给应用程序； 优点：可以充分利用系统资源，提高 IO 操作的效率 缺点：编程模型相对复杂 对于操作系统内核来说，异步 IO 操作指的是，在内核处理 IO 请求时无需等待，立即返回 并发模式 并发模式，指的是 I/O 处理单元和多个逻辑单元之间协调完成任务的方法 ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:1:1","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Golang Netpoll","uri":"/posts/golang-netpoll/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"Linux Epoll epoll 在内核里使用红黑树(Red-black tree)来跟踪进程所有待检测的文件描述字 fd，把需要监控的 socket 通过 epoll_ctl() 函数加入内核中的红黑树里（红黑树是个高效的数据结构，增删改一般时间复杂度是 O(logn)） epoll 使用事件驱动的机制，在内核里维护了一个链表(List)来记录就绪事件。 当某个 socket 有事件发生时，内核通过回调函数将其加入到这个就绪事件列表中。 当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率 两种触发模式 Level trigger：服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束 Edge trigger：服务器端只会从 epoll_wait 中苏醒一次 事件宏 EPOLLIN 表示对应的文件描述符可读（包括对端 socket 正常关闭） EPOLLOUT 表示对应的文件描述符可写 EPOLLPRI 表示对应的文件描述符有紧急的数据可读（带外数据） EPOLLERR 表示对应的文件描述符发生错误 EPOLLHUP 表示对应的文件描述符被挂断 EPOLLET 将 EPOLL 设为边缘触发模式（默认电平触发） EPOLLONESHOT 只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 socket 的话，需要再次把这个 socket 加入到内核中的事件注册表中 ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:1:2","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Golang Netpoll","uri":"/posts/golang-netpoll/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"II. 应用示例 package main import \"net\" func main() { l, _ := net.Listen(\"tcp\", \"127.0.0.1:2333\") for { conn, _ := l.Accept() go func() { defer conn.Close() buf := make([]byte, 4096) _, _ = conn.Read(buf) conn.Write(buf) }() } } ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:2:0","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Golang Netpoll","uri":"/posts/golang-netpoll/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"III. 相关数据结构 // src/net/fd_fake.go // Network file descriptor. type netFD struct { pfd poll.FD // immutable until Close family int sotype int isConnected bool // handshake completed or use of association with peer net string laddr Addr raddr Addr // The only networking available in WASI preview 1 is the ability to // sock_accept on a pre-opened socket, and then fd_read, fd_write, // fd_close, and sock_shutdown on the resulting connection. We // intercept applicable netFD calls on this instance, and then pass // the remainder of the netFD calls to fakeNetFD. *fakeNetFD } // poll.FD`: `src/internal/poll/fd_unix.go // FD is a file descriptor. The net and os packages use this type as a // field of a larger type representing a network connection or OS file. type FD struct { // Lock sysfd and serialize access to Read and Write methods. fdmu fdMutex // System file descriptor. Immutable until Close. Sysfd int // Platform dependent state of the file descriptor. SysFile // I/O poller. pd pollDesc // Semaphore signaled when file is closed. csema uint32 // Non-zero if this file has been set to blocking mode. isBlocking uint32 // Whether this is a streaming descriptor, as opposed to a // packet-based descriptor like a UDP socket. Immutable. IsStream bool // Whether a zero byte read indicates EOF. This is false for a // message based socket connection. ZeroReadIsEOF bool // Whether this is a file rather than a network socket. isFile bool } // Addr represents a network end point address. // // The two methods [Addr.Network] and [Addr.String] conventionally return strings // that can be passed as the arguments to [Dial], but the exact form // and meaning of the strings is up to the implementation. type Addr interface { Network() string // name of the network (for example, \"tcp\", \"udp\") String() string // string form of address (for example, \"192.0.2.1:25\", \"[2001:db8::1]:80\") } // fdMutex is a specialized synchronization primitive that manages // lifetime of an fd and serializes access to Read, Write and Close // methods on FD. type fdMutex struct { state uint64 rsema uint32 wsema uint32 } type SysFile struct { // Writev cache. iovecs *[]syscall.Iovec } type pollDesc struct { runtimeCtx uintptr } 通过源码可以看到，Golang 网络编程涉及到的 netFD, poll.FD, Addr, SysFile 以及 pollDesc 之间的关系如下： fdmu 是为了保证对同一个文件的读、写操作能分别被序列化 Sysfd 就是操作系统中 syscall 返回的 fd 值 pd，pollDesc I/O poller，是 Go 对 poll 过程的一个抽象，所有平台的抽象都是一样的 csema，当文件被关闭时会被触发 isBlocking 表明 FD 是否为 blocking 模式 IsStream 标志该 FD 是否是流式，与流式相反的是基于 packet 的，即 UDP socket ZeroReadIsEOF，当连接读到 0 长度时，用来区分是否代表 EOF. 如果是基于 packet 的 socket 连接，则始终是 false isFile 标志该 FD 是否代表文件，还是网络连接 netFD 结构中包含一个 poll.FD 类型的成员 pfd，以及 Addr 接口类型的 laddr 和 raddr poll.FD 结构含有 SysFile 和 pollDesc 类型的成员，以及 fdMutex 类型的 fdmu ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:3:0","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Golang Netpoll","uri":"/posts/golang-netpoll/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"IV. TCP 网络编程基本流程 本部分涉及众多函数调用，为了描述清晰，采用了图的形式，其中，每一块第一行表示该块所表示的函数名称，其他部分表示该函数中关键函数调用。 ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:4:0","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Golang Netpoll","uri":"/posts/golang-netpoll/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"创建 TCP socket 并监听: net.Listen NOTE 需要注意的是，在执行 net.(*netFD).listenStream 之前，由于 maxListenerBacklog 函数调用了 open(\"/proc/sys/net/core/somaxconn\")，则会导致 epoll 底层红黑树的提前创建: runtime.netpollinit -\u003e syscall.EpollCreate1 -\u003e Syscall6(SYS_EPOLL_CREATE1, uintptr(flags), 0, 0, 0, 0, 0). 另外，当启用 Timer 时，也存在提前初始化 netpoll 的可能，原因： Timers rely on the network poller time.NewTimer -\u003e runtime.startTimer -\u003e runtime.addtimer -\u003e runtime.doaddtimer -\u003e netpollGenericInit() // doaddtimer adds t to the current P's heap. // The caller must have locked the timers for pp. func doaddtimer(pp *p, t *timer) { // Timers rely on the network poller, so make sure the poller // has started. if netpollInited.Load() == 0 { netpollGenericInit() } ... } ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:4:1","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Golang Netpoll","uri":"/posts/golang-netpoll/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"获取 TCP 连接: net.(*TCPListener).Accept ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:4:2","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Golang Netpoll","uri":"/posts/golang-netpoll/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"TCP 连接读数据: net.(*TCPConn).Read ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:4:3","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Golang Netpoll","uri":"/posts/golang-netpoll/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"TCP 连接写数据: net.(*TCPConn).Write ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:4:4","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Golang Netpoll","uri":"/posts/golang-netpoll/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"V. netpoll 执行流程: netpoll 在调度和 GC 的关键点上都会检查一次 netpoll，确定是否存在 ready 状态的 FD： startTheWorldWithSema // reason is the same STW reason passed to stopTheWorld. start is the start // time returned by stopTheWorld. // // now is the current time; prefer to pass 0 to capture a fresh timestamp. // // stattTheWorldWithSema returns now. func startTheWorldWithSema(now int64, w worldStop) int64 { assertWorldStopped() mp := acquirem() // disable preemption because it can be holding p in a local var if netpollinited() { list, delta := netpoll(0) // non-blocking injectglist(\u0026list) netpollAdjustWaiters(delta) } lock(\u0026sched.lock) procs := gomaxprocs if newprocs != 0 { procs = newprocs newprocs = 0 } p1 := procresize(procs) sched.gcwaiting.Store(false) if sched.sysmonwait.Load() { sched.sysmonwait.Store(false) notewakeup(\u0026sched.sysmonnote) } unlock(\u0026sched.lock) worldStarted() ... } findrunnable // Finds a runnable goroutine to execute. // Tries to steal from other P's, get g from local or global queue, poll network. // tryWakeP indicates that the returned goroutine is not normal (GC worker, trace // reader) so the caller should try to wake a P. func findRunnable() (gp *g, inheritTime, tryWakeP bool) { ... // Poll network until next timer. if netpollinited() \u0026\u0026 (netpollAnyWaiters() || pollUntil != 0) \u0026\u0026 sched.lastpoll.Swap(0) != 0 { sched.pollUntil.Store(pollUntil) if mp.p != 0 { throw(\"findrunnable: netpoll with p\") } if mp.spinning { throw(\"findrunnable: netpoll with spinning\") } delay := int64(-1) if pollUntil != 0 { if now == 0 { now = nanotime() } delay = pollUntil - now if delay \u003c 0 { delay = 0 } } if faketime != 0 { // When using fake time, just poll. delay = 0 } list, delta := netpoll(delay) // block until new work is available ... } ... } pollWork // pollWork reports whether there is non-background work this P could // be doing. This is a fairly lightweight check to be used for // background work loops, like idle GC. It checks a subset of the // conditions checked by the actual scheduler. func pollWork() bool { if sched.runqsize != 0 { return true } p := getg().m.p.ptr() if !runqempty(p) { return true } if netpollinited() \u0026\u0026 netpollAnyWaiters() \u0026\u0026 sched.lastpoll.Load() != 0 { if list, delta := netpoll(0); !list.empty() { injectglist(\u0026list) netpollAdjustWaiters(delta) return true } } return false } sysmon // Always runs without a P, so write barriers are not allowed. // //go:nowritebarrierrec func sysmon() { ... lock(\u0026sched.sysmonlock) // Update now in case we blocked on sysmonnote or spent a long time // blocked on schedlock or sysmonlock above. now = nanotime() // trigger libc interceptors if needed if *cgo_yield != nil { asmcgocall(*cgo_yield, nil) } // poll network if not polled for more than 10ms lastpoll := sched.lastpoll.Load() if netpollinited() \u0026\u0026 lastpoll != 0 \u0026\u0026 lastpoll+10*1000*1000 \u003c now { sched.lastpoll.CompareAndSwap(lastpoll, now) list, delta := netpoll(0) // non-blocking - returns list of goroutines if !list.empty() { // Need to decrement number of idle locked M's // (pretending that one more is running) before injectglist. // Otherwise it can lead to the following situation: // injectglist grabs all P's but before it starts M's to run the P's, // another M returns from syscall, finishes running its G, // observes that there is no work to do and no other running M's // and reports deadlock. incidlelocked(-1) injectglist(\u0026list) incidlelocked(1) netpollAdjustWaiters(delta) } } ... } 根据 ready 的事件时 Read 或 Write，分别从 poolDesc 的 rg、wg 上获取该唤醒的 goroutine. 然后将已经 ready 的 goroutine push 到 toRun 链表，并且 toRun 链表最终会从 netpoll() 返回，通过 injectglist 进入全局队列. 相当于每次调度循环都要执行 netpoll，检查频率还是比较高的 // netpoll checks for ready network connections. // Returns list of goroutines that become runnable. // delay \u003c 0: blocks indefinitely // delay == 0: does not block, just polls // delay \u003e 0: block for up to that many nanoseconds func netpoll(delay int64) (gList, int32) { if epfd == -1 { return gList{}, 0 } var waitms int32 if delay \u003c 0 { waitms = -1 } else if ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:5:0","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Golang Netpoll","uri":"/posts/golang-netpoll/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"VI. 总结 Golang 通过对 Linux 内核提供的 epoll 实现进行封装，实现了同步编程异步执行的效果，其核心数据结构是 netFD，并将 Sysfd 与 pollDesc 结构绑定。 当某个 netFD 产生 EAGAIN 错误时，则当前 Goroutine 将会被存储到其对应的 pollDesc 中，同时 Goroutine 会 gopark()，直至这个 netFD 再次发生读写事件，会将此 Goroutine 设置为 ready 并放入 toRun 队列等待重新运行，而底层事件通知机制就是 epoll. Golang 中 netpoll 的创建与初始化的可能来源：Timer、读文件、TCP Listen. 如下的调度和 GC 关键函数 startTheWorldWithSema、findrunnable、pollWork、sysmon 都会进行 netpoll 执行流程，检查是否存在 ready 状态的 FD. ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:6:0","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Golang Netpoll","uri":"/posts/golang-netpoll/"},{"categories":["Netpoll","Epoll","Network Program","Golang","Linux"],"content":"VII. Reference runtime/netpoll.go runtime/netpoll_epoll.go runtime/proc.go net/fd_unix.go internal/poll/fd_poll_runtime.go internal/poll/fd_unix.go ","date":"2024-05-08","objectID":"/posts/golang-netpoll/:7:0","tags":["Netpoll","Epoll","Network Program","Golang","Linux"],"title":"Golang Netpoll","uri":"/posts/golang-netpoll/"},{"categories":["Golang","Profile","Optimize"],"content":" 导语 Golang 常见的性能剖析 (Profile) 与优化 (Optimize) ","date":"2024-04-20","objectID":"/posts/golang-profile/:0:0","tags":["Golang","Profile","Optimize"],"title":"Golang Profile and Optimize","uri":"/posts/golang-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"I. Profile 在进行 API 压测、全链路压测、线上生产环境被高峰流量打爆的过程中随时可能发生故障等问题，例如： CPU 占用过高，超过 90%； 内存爆掉，OOM(Out of memory)； Goroutine 数量过多，80W； 线程数超高； 延迟过高； 在发生以上故障时，一般需要结合 pprof 寻找故障原因，并根据不同的情况选择不同的方案； 线上一定要具有开启 pprof 的能力，如果考虑安全性，也要具有通过配置开启的能力； ","date":"2024-04-20","objectID":"/posts/golang-profile/:1:0","tags":["Golang","Profile","Optimize"],"title":"Golang Profile and Optimize","uri":"/posts/golang-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"压测时需要关注的服务指标 Request rate: The number of service requests per second. Errors: The number of request that failed. Duration: The time for requests to complete. Goroutine / Thread 数量: 如果 Goroutine 数量很多，需要关注这些 Goroutine 的执行情况. GC 频率 gctrace 的内容: GC 的 STW 时间 还有一些其他 Memstats 相关的其他指标，可以参考 Prometheus. ","date":"2024-04-20","objectID":"/posts/golang-profile/:1:1","tags":["Golang","Profile","Optimize"],"title":"Golang Profile and Optimize","uri":"/posts/golang-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"压测手段 wrk: a HTTP benchmarking tool wrk2: a HTTP benchmarking tool based mostly on wrk HEY: a tiny program that sends some load to a web application. Vegate: a versatile HTTP load testing tool built out of a need to drill HTTP services with a constant request rate. h2load: HTTP/2 benchmarking tool ghz: gRPC benchmarking and load testing tool ","date":"2024-04-20","objectID":"/posts/golang-profile/:1:2","tags":["Golang","Profile","Optimize"],"title":"Golang Profile and Optimize","uri":"/posts/golang-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"pprof 应用实例 package main import ( \"net/http\" _ \"net/http/pprof\" ) var quit chan struct{} = make(chan struct{}) func f() { \u003c- quit } func main() { go func() { http.ListenAndServe(\":8080\", nil) }() for i := 0; i \u003c 10000; i++ { go f() } for {} // Test } go tool pprof -http=:9999 localhost:8080/debug/pprof/heap 注意事项 测试代码中引入 net/http/pprof 包： _ \"net/http/pprof\" 单独启动一个 Goroutine 开启监听(端口自定，例如这里是 8080)：go func() { http.ListenAndServe(\":8080\", nil) }() $ go tool pprof -http=:9999 localhost:8080/debug/pprof/heap ","date":"2024-04-20","objectID":"/posts/golang-profile/:1:3","tags":["Golang","Profile","Optimize"],"title":"Golang Profile and Optimize","uri":"/posts/golang-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"II. Optimize ","date":"2024-04-20","objectID":"/posts/golang-profile/:2:0","tags":["Golang","Profile","Optimize"],"title":"Golang Profile and Optimize","uri":"/posts/golang-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"优化方向 在分析上图的应用程序运行过程，可以发现进行程序优化时，一般从可以从以下方面入手： 应用层优化: 主要指的是逻辑优化、内存使用优化、CPU 使用优化、阻塞优化等，并且本层优化效果可能优于底层优化； 底层优化：GC优化、Go 标准库优化、Go runtime 优化等 ","date":"2024-04-20","objectID":"/posts/golang-profile/:2:1","tags":["Golang","Profile","Optimize"],"title":"Golang Profile and Optimize","uri":"/posts/golang-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"基本优化流程 外部依赖：在监控系统中查看是否存在问题，例如依赖的上游服务 (DB/redis/MQ) 延迟过高； CPU 占用：通过查看 CPU profile 检查是否存在问题，优化占用 CPU 较多的部分逻辑； 内存占用：看 Prometheus，内存 RSS / Goroutine 数量 / Goroutine 栈占用 –» 如果 Goroutine 数量不多，则重点关注 heap profile 中的 inuse –» 定时任务类需要看 alloc Goroutine 数量过多 –» 从 profile 网页进去看看 Goroutine 的执行情况（在干什么？） –» 检查死锁、阻塞等问题 –» 个别不在意延迟的选择第三方库优化 ","date":"2024-04-20","objectID":"/posts/golang-profile/:2:2","tags":["Golang","Profile","Optimize"],"title":"Golang Profile and Optimize","uri":"/posts/golang-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"常见优化场景 字符串拼接 package main import ( \"fmt\" \"testing\" ) func BenchmarkConcat0(b *testing.B) { var str string for i := 0; i \u003c b.N; i++ { str = \"\" str += \"userid : \" + \"1\" str += \"localtion : \" + \"ab\" } } func BenchmarkConcat1(b *testing.B) { var str string for i := 0; i \u003c b.N; i++ { str = \"\" str += fmt.Sprintf(\"userid : %v\", \"1\") str += fmt.Sprintf(\"localtion : %v\", \"ab\") } } $ go test -bench=. -benchmem goos: linux goarch: amd64 pkg: github.com/lutianen/go-test/bench0 cpu: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz BenchmarkConcat0-16 35702518 32.86 ns/op 24 B/op 1 allocs/op BenchmarkConcat1-16 8105732 140.9 ns/op 56 B/op 3 allocs/op PASS ok github.com/lutianen/go-test/bench0 2.506s 逃逸分析 用户声明的对象，被放在栈上还是堆上？ 可以通过编译器的 escape analysis 来决定 go build -gcflags=\"-m\" xxx.go package main func main() { var sl = make([]int, 1024) println(sl[0]) var sl0 = make([]int, 10240) println(sl0[0]) } $ go build -gcflags=\"-m\" main.go # command-line-arguments ./main.go:3:6: can inline main ./main.go:4:15: make([]int, 1024) does not escape ./main.go:7:16: make([]int, 10240) escapes to heap TODO: 各种逃逸分析的可能性有哪些？ Trasval 2-D Matrix package bench1 import \"testing\" func BenchmarkHorizontal(b *testing.B) { arrLen := 10000 arr := make([][]int, arrLen, arrLen) for i := 0; i \u003c arrLen; i++ { arrInternal := make([]int, arrLen) for j := 0; j \u003c arrLen; j++ { arrInternal[j] = 0 } arr[i] = arrInternal } for i := 0; i \u003c b.N; i++ { for x := 0; x \u003c len(arr); x++ { for y := 0; y \u003c len(arr); y++ { arr[x][y] = 1 } } } } func BenchmarkVertical(b *testing.B) { arrLen := 10000 arr := make([][]int, arrLen, arrLen) for i := 0; i \u003c arrLen; i++ { arrInternal := make([]int, arrLen) for j := 0; j \u003c arrLen; j++ { arrInternal[j] = 0 } arr[i] = arrInternal } for i := 0; i \u003c b.N; i++ { for x := 0; x \u003c len(arr); x++ { for y := 0; y \u003c len(arr); y++ { arr[y][x] = 1 } } } } $ go test -bench=. -benchmem goos: linux goarch: amd64 pkg: github.com/lutianen/go-test/bench1 cpu: 11th Gen Intel(R) Core(TM) i7-11800H @ 2.30GHz BenchmarkHorizontal-16 15 71020410 ns/op 54629717 B/op 666 allocs/op BenchmarkVertical-16 1 1059649022 ns/op 819445856 B/op 10002 allocs/op PASS ok github.com/lutianen/go-test/bench1 3.676s Zero Garbage / Allocation Zero Grabage 一般指的是通过利用 sync.Pool 将堆分配完全消灭的优化技术。 例如，在 http router 框架 fasthttp 中应用较多. False Sharing CPU 运行过程中修改数据是一个 cache line为单位，当两个变量A/B满足以下条件： 在内存中相邻 并发修改频繁 那么，当 CPU0 修改变量 A 时，会导致 CPU1 中的变量 B 缓存失效。 解决方法，在定义数据结构中，填充一些 padding 用以满足该数据结构正好是 cache line 的整数倍； type NoPad struct { x uint64 y uint64 } type WithPad struct { x uint64 _ [6]uint64 y uint64 } 查看 cache line 大小：cat /sys/devices/system/cpu/cpu\u003ccore-num\u003e/cache/index0/coherency_line_size 降低外部命令调用频次 优化前： func f(wr http.ResponseWriter, r *http.Request) { uuid, _ := exec.Command(\"uuidgen\").Output() // Use exec.Command wr.Header()[\"Content-Type\"] = []string{\"application/text\"} io.WriteString(wr, string(uuid)) } 优化后： import uuid \"github.com/satori/go.uuid\" func f(wr http.ResponseWriter, r *http.Request) { uuid, _ := uuid.NewV4() // Replace exec.Command with existing library wr.Header()[\"Content-Type\"] = []string{\"application/text\"} io.WriteString(wr, uuid.String()) } 总结： 线上使用 exec 命令是非常危险的 采用第三方库代替外部命令 阻塞导致高延迟 锁阻塞 var mtx sync.Mutex var data = map[string]string{ \"hint\": \"hello wold\", } func f(wr http.ResponseWriter, r *http.Request) { mtx.Lock() defer mtx.Unlock() buf := data[\"hint\"] time.Sleep(time.Millisecond * 10) // 临界区内的慢操作 wr.Header()[\"Content-Type\"] = []string{\"application/json\"} io.WriteString(wr, buf) } 减小临界区 - 优化后： var mtx sync.Mutex var data = map[string]string{ \"hint\": \"hello wold\", } func f(wr http.ResponseWriter, r *http.Request) { mtx.Lock() buf := data[\"hint\"] mtx.Unlock() time.Sleep(time.Millisecond * 10) // 慢操作放置于临界区之外 wr.Header()[\"Content-Type\"] = []string{\"application/json\"} io.WriteString(wr, buf) } 在后端系统开发中，锁瓶颈是较常见的问题，例如文件锁 双 Buffer 完全干掉锁阻塞 使用双 Buffer / RCU 完全消除读阻塞：全量更新，直接替换原 config func updateConfig() { var newConfig = \u0026MyConfig { WhiteList: make(map[int]struct{}), } // Do a lot of compulation ","date":"2024-04-20","objectID":"/posts/golang-profile/:2:3","tags":["Golang","Profile","Optimize"],"title":"Golang Profile and Optimize","uri":"/posts/golang-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"III. Coutinuous Profiling 压测是一个蹲点行为，然而真实场景并不美好，它们通常是难以发现的偶发问题： 该到吃饭的时候，CPU 使用尖刺 凌晨四点半，系统发生 OOM 刚睡着的时候，Goroutine 数量爆炸 产品被部署到客户那里，想登陆客户的环境并不方便 此时 Coutinuout Profiling 就派上用场了. 自省式的 Profile Dumper，可以根据 CPU 利用率、Memory 利用率、Goroutine 数量等多个指标检测系统，设置定时周期进行检测，当发现某个指标异常时，自动 Dump file. ","date":"2024-04-20","objectID":"/posts/golang-profile/:3:0","tags":["Golang","Profile","Optimize"],"title":"Golang Profile and Optimize","uri":"/posts/golang-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"IV. Summary _pad 优化，针对多个线程更新同一个结构体内不同的字段场景有效，而针对一个线程同时更新整个结构体的场景意义不大； 第三方接口出现问题，如何保护自己的服务？ 对外部调用必须有超时 ==\u003e 熔断 goroutine 初始化栈空间为 2KB，最大 1GB，那么 heap 为什么不爆栈？ 在 Go 语言中，goroutine 和 heap 使用单独的内存空间：Goroutine 有自己的堆栈空间，用于存储局部变量、函数帧和其他运行时信息；heap 则是一个共享内存空间，用于存储动态分配的对象，例如 slice、map 和 strings。 当 Goroutine 需要分配的内存多于起堆栈上的可用内存时，它将自动从 stack 中分配内存，采用的是 stack 分配机制完成，运行 goroutine 分配任何数量的内存，而不用担心 stack 空间耗尽； 除了堆分配之外，goroutine 还可以使用一种称为堆栈复制的技术来在它们之间共享数据，堆栈复制比堆分配更有效，但它只能用于共享足够小以适合堆栈的数据。 ","date":"2024-04-20","objectID":"/posts/golang-profile/:4:0","tags":["Golang","Profile","Optimize"],"title":"Golang Profile and Optimize","uri":"/posts/golang-profile/"},{"categories":["Golang","Profile","Optimize"],"content":"V. Reference Benchmarks Game Go Web Frame Benchmarks Go HTTP Router Benchmark Web 场景跨语言性能对比 《Systems Performance》 Dave 分享的 High Performance Go Workshop go-perfbook: best practices for writing high-performance Go code Delve What is Continuous Profiling? Google-Wide Profiling: A Continuous Profiling Infrastructure for Data Centers ","date":"2024-04-20","objectID":"/posts/golang-profile/:5:0","tags":["Golang","Profile","Optimize"],"title":"Golang Profile and Optimize","uri":"/posts/golang-profile/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":" 导语 在 Golang 生态系统中，Linter 工具是开发者提升代码质量的关键。 本文将深入介绍几款常用的 Linter 工具及其最佳实践，帮助您在开发中避免常见错误并提高代码的可维护性。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:0:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"目录 说明 何为 Linter？ Gocyclo bodyclose sqlrows funlen goconst ineffassign lll errcheck whitespace GolangCI-Lint reviewdog Summary Reference ","date":"2024-04-19","objectID":"/posts/golang-linter/:1:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"O. 说明 如特殊说明，文中代码已在在 Mac 和 Linux 系统下进行测试 ","date":"2024-04-19","objectID":"/posts/golang-linter/:2:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"I. 何为 Linter？ Linter 是一种静态代码分析工具，用于在编译前检查代码中的错误、风格问题及潜在的 Bug。 在 Golang 生态中，Linter 工具帮助开发者在早期阶段就发现问题，从而避免后期修复的高成本。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:3:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"II. Gocyclo Gocyclo 是一款用于分析 Go 代码中函数圈复杂度的 Linter 工具，帮助开发者识别需要重构的复杂函数。 通过降低圈复杂度，代码变得更加简洁、易读且更易维护。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:4:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"函数圈复杂度(cyclomatic complexities) 圈复杂度，是一种衡量代码复杂性的指标，通过计算代码中的决策点（如if语句、循环等）来评估函数的复杂度，具体计算方法如下： 一个函数的基本圈复杂度为 1 当函数中存在的每一个 if, for, case, \u0026\u0026 or ||，都会使得该函数的圈复杂度加 1 在 Go 语言中，由于 if err != nil 的特殊情况存在，因此，其圈复杂度阈值默认为 15，而其他编程语言中圈复杂度阈值一般默认为 10。 在 Go 语言中，switch 中的 default 并不会增加函数的圈复杂度； Gocyclo 可以作为单独的命令行工具使用，也可以与其他 Linter 工具(如 golangci-lint)集成使用，提供更全面的代码质量检查。 同时，它也可以集成到 CI/CD 流程中，帮助团队持续改善代码质量。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:4:1","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"安装 go install github.com/fzipp/gocyclo/cmd/gocyclo@latest ","date":"2024-04-19","objectID":"/posts/golang-linter/:4:2","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"如何使用 Gocyclo linter ？ Calculate cyclomatic complexities of Go functions. Usage: gocyclo [flags] \u003cGo file or directory\u003e ... Flags: -over N show functions with complexity \u003e N only and return exit code 1 if the set is non-empty -top N show the top N most complex functions only -avg, -avg-short show the average complexity over all functions; the short option prints the value without a label -ignore REGEX exclude files matching the given regular expression The output fields for each line are: \u003ccomplexity\u003e \u003cpackage\u003e \u003cfunction\u003e \u003cfile:line:column\u003e 使用示例 // gocyclo-test/main.go package main import ( \"fmt\" \"strconv\" ) func main() { var a = 10 if a == 10 { f() } else { fmt.Printf(\"%s\", strconv.Itoa(a)) } switch a{ case 10: fmt.Println(a) default: fmt.Println(\"default\") } } func f() { a := 10 b := 12 if a != b { // do something fmt.Println(\"a != b\") } } $ gocyclo gocyclo-test/main.go 3 main main gocyclo-test/main.go:8:1 2 main f gocyclo-test/main.go:24:1 ","date":"2024-04-19","objectID":"/posts/golang-linter/:4:3","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"III. bodyclose 在 Go 中，即使读取了所有的响应内容，也需要显式关闭响应体以释放资源，否则可能导致资源泄漏、连接池耗尽，进而影响应用性能。 bodyclose 主要关注于 HTTP 响应体的正确关闭，通过检查 resp.Body 是否被正确关闭。 它既可以单独使用，也可以集成到其他 linter 工具（例如 golangci-lint）中。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:5:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"安装 go install github.com/timakin/bodyclose@latest ","date":"2024-04-19","objectID":"/posts/golang-linter/:5:1","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"如何使用 bodyclose ? $ bodyclose bodyclose is a tool for static analysis of Go programs. Usage of bodyclose: bodyclose unit.cfg # execute analysis specified by config file bodyclose help # general help, including listing analyzers and flags bodyclose help name # help on specific analyzer and its flags 使用示例 这里展示借助 golangci-lint 的方式使用 bodyclose. // main.go package kyden import ( \"fmt\" \"io\" \"net/http\" ) func f() error{ resp, err := http.Get(\"http://example.com/\") if err != nil { return err } // defer resp.Body.Close() // \u003c\u003c\u003c body, err := io.ReadAll(resp.Body) fmt.Println(body) return nil } $ golangci-lint run --disable-all -E bodyclose main.go main.go:11:26: response body must be closed (bodyclose) resp, err := http.Get(\"http://example.com/\") 避免使用 http 库中 body 忘记 close 的更优方案是: 对 Go 官方提供的 http 进行封装，使调用方（Caller）不用显示调用 close 函数. package httpclient import ( \"io/ioutil\" \"net/http\" ) // Client 是一个自定义的 HTTP 客户端结构体 type Client struct { http.Client } // Get 封装了 http.Get 方法 func (c *Client) Get(url string) (string, error) { resp, err := c.Client.Get(url) if err != nil { return \"\", err } // 确保在函数返回时关闭响应体 defer resp.Body.Close() // 读取响应内容 body, err := ioutil.ReadAll(resp.Body) if err != nil { return \"\", err } return string(body), nil } ","date":"2024-04-19","objectID":"/posts/golang-linter/:5:2","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"IV. sqlrows 在 Go 的 database/sql 包中，sql.Rows 是一个 struct，用于表示从数据库查询中返回的多行结果。 它提供了一组方法，允许开发者逐行读取查询结果。 迭代结果：使用 Next() 方法逐行遍历结果集。 扫描数据：使用 Scan() 方法将当前行的列值复制到指定的变量中。 关闭结果集：使用 Close() 方法释放与结果集相关的资源。 sqlrows 的官方介绍： sqlrows is a static code analyzer which helps uncover bugs by reporting a diagnostic for mistakes of sql.Rows usage. ","date":"2024-04-19","objectID":"/posts/golang-linter/:6:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"安装 go install github.com/gostaticanalysis/sqlrows@latest ","date":"2024-04-19","objectID":"/posts/golang-linter/:6:1","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"如何使用 sqlrows ? $ sqlrows sqlrows is a tool for static analysis of Go programs. Usage of sqlrows: sqlrows unit.cfg # execute analysis specified by config file sqlrows help # general help sqlrows help name # help on specific analyzer and its flags Go 源码【注意 Not Good(NG) 处】 // main.go package kyden import ( \"context\" \"database/sql\" ) func f(ctx context.Context, db *sql.DB) (interface{}, error) { rows, err := db.QueryContext(ctx, \"SELECT * FROM users\") defer rows.Close() // NG: using rows before checking for errors if err != nil { return nil, err } // defer rows.Close() // NG: this return will not release a connection. for rows.Next() { err = rows.Scan() if err != nil { return nil, err } } return nil, nil } 针对两种 NG 的不同输出： go vet -vettool=$(which sqlrows) main.go # command-line-arguments ./main.go:10:11: using rows before checking for errors go vet -vettool=$(which sqlrows) main.go # command-line-arguments ./main.go:9:33: rows.Close must be called ","date":"2024-04-19","objectID":"/posts/golang-linter/:6:2","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"V. funlen funlen，用于检查函数的长度，确保函数的可读性和可维护性。 默认情况下，funlen 将函数的最大行数限制(lines)为 60 行，最大语句数(statements)限制为 40 条。 通常，funlen 会结合 golangci-lint 使用， 并集成到开发工作流中，提升代码质量. ","date":"2024-04-19","objectID":"/posts/golang-linter/:7:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"安装 funlen 可以通过 golangci-lint 安装: go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest ","date":"2024-04-19","objectID":"/posts/golang-linter/:7:1","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"如何使用 funlen ？ linters: disable-all: true enable: - funlen linters-settings: funlen: lines: 60 statements: 40 使用示例 // main.go package main import ( \"fmt\" ) func main() { f() } func f () { fmt.Println(\"Test funlen\") a := 1 fmt.Println(a) b := 1 fmt.Println(b) c := 1 fmt.Println(c) } 下面的 .golangci.yml 仅用于展示 funlen 的用法，具体参数请根据实际项目自行调整。 # .golangci.yml linters: disable-all: true enable: - funlen linters-settings: funlen: lines: 6 statements: 4 $ golangci-lint run main.go:12: Function 'f' has too many statements (7 \u003e 4) (funlen) ","date":"2024-04-19","objectID":"/posts/golang-linter/:7:2","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"VI. goconst goconst 会扫描代码，识别出在多个地方重复出现的字符串。 这些字符串通常是相同的文本，开发者通过将重复的字符串提取为常量，代码变得更加清晰，减少了硬编码的出现，降低了出错的可能性。 可以根据项目需求自定义 goconst 的行为，例如设置字符串的最小长度、最小出现次数等。 goconst 通常作为 golangci-lint 的一部分使用。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:8:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"如何使用 goconst ? linters: disable-all: true enable: - goconst linters-settings: goconst: min-len: 3 min-occurrences: 3 使用示例 // main.go package main import \"fmt\" func f() { a := \"Hello\" fmt.Println(a) b := \"Hello\" fmt.Println(b) c := \"Hello\" fmt.Println(c) } 下面的 .golangci.yml 仅用于展示 funlen 的用法，具体参数请根据实际项目自行调整。 # .golangci.yml linters: disable-all: true enable: - goconst linters-settings: goconst: min-len: 3 min-occurrences: 3 $ golangci-lint run main.go:7:10: string `Hello` has 3 occurrences, make it a constant (goconst) a := \"Hello\" ^ ","date":"2024-04-19","objectID":"/posts/golang-linter/:8:1","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"VII. ineffassign ineffassign，主要用于检测代码中对现有变量的赋值操作是否未被使用。 这种未使用的赋值通常是代码中的潜在错误，可能导致逻辑上的混乱或资源的浪费。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:9:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"如何使用 ineffassign ? 通常作为 golangci-lint 的一部分使用。 linters: disable-all: true enable: - ineffassign 使用示例 // main.go package main import \"fmt\" func f() { a := \"Hello\" // ... // Not assign a value to `a` // ... a = \"kyden\" fmt.Println(a) } $ golangci-lint run main.go:7:5: ineffectual assignment to a (ineffassign) a := \"Hello\" ^ ","date":"2024-04-19","objectID":"/posts/golang-linter/:9:1","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"VIII. lll 通过限制行的长度，lll 有助于确保代码在查看时不会横向滚动，提升代码的可读性。 lll，主要用于检查代码行的长度，检查每一行的长度是否超过指定的最大值。 默认情况下，lll 将最大行长度限制为 120 个字符。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:10:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"如何使用 lll ? lll 通常作为 golangci-lint 的一部分使用。 linters: disable-all: true enable: - lll linters-settings: lll: line-length: 80 使用示例 // main.go package kyden func f() int { a := \"This is a very long line that exceeds the maximum line length set by the linter and should be broken up into smaller, more manageable lines.\" return len(a) } golangci-lint run main.go:5: the line is 151 characters long, which exceeds the maximum of 80 characters. (lll) a := \"This is a very long line that exceeds the maximum line length set by the linter and should be broken up into smaller, more manageable lines.\" 解决方案 使用反引号（`）定义多行字符串，允许字符串跨越多行而不需要使用连接符 ","date":"2024-04-19","objectID":"/posts/golang-linter/:10:1","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"IX. errcheck errcheck，专门检查未处理的错误，确保开发者在调用可能返回错误的函数时，正确地检查和处理这些错误，从而提高代码的健壮性和可靠性。 errcheck 会扫描 Go 代码，查找未检查错误的地方 除了检查函数返回的错误,还可以检查类型断言是否被忽略 可以检查是否将错误赋值给了空白标识符 ","date":"2024-04-19","objectID":"/posts/golang-linter/:11:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"如何使用 ? errcheck 通常作为 golangci-lint 的一部分使用 linters-settings: errcheck: check-type-assertions: true # 检查类型断言是否被忽略,默认为 false check-blank: true # 检查是否将错误赋值给空白标识符,默认为 false disable-default-exclusions: true # 禁用默认的忽略函数列表,默认为 false exclude-functions: # 指定要忽略检查的函数列表 # ... 使用示例 // main.go package main import ( \"fmt\" ) func main() { hello(\"Kyden\") // err Not Check _ = hello(\"Kyden\") // err assign to _ err := hello(\"Go\") if err != nil { return } } func hello(str string) error { fmt.Printf(\"Hello, %s\", str) return nil } 下面的 .golangci.yml 仅用于展示 errcheck 的用法，具体参数请根据实际项目自行调整。 # .golangci.yml linters: disable-all: true enable: - errcheck linters-settings: errcheck: check-type-assertions: true check-blank: true golangci-lint run main.go:9:10: Error return value is not checked (errcheck) hello(\"Kyden\") // err Not Check ^ main.go:11:5: Error return value is not checked (errcheck) _ = hello(\"Kyden\") // err assign to _ ^ ","date":"2024-04-19","objectID":"/posts/golang-linter/:11:1","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"X. whitespace whitespace 是一个 Go 语言的 linter，主要用于检查代码中不必要的空行，即检查函数、条件语句（如 if、for）等开头和结尾的多余空行。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:12:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"如何使用 whitespace ? whitespace 也包含在 golangci-lint 中，只需在配置中启用即可。 linters: disable-all: true enable: - whitespace 使用示例 // main.go package main import ( \"fmt\" ) func main() { err := hello(\"Kyden\") if err != nil { return } } func hello(str string) error { if len(str) \u003c= 0 { return fmt.Errorf(\"str len \u003c= 0\") } fmt.Printf(\"Hello, %s\", str) return nil } $ gosrc golangci-lint run main.go:15:31: unnecessary leading newline (whitespace) ^ main.go:25:1: unnecessary trailing newline (whitespace) ^ main.go:17:23: unnecessary leading newline (whitespace) ^ ","date":"2024-04-19","objectID":"/posts/golang-linter/:12:1","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"XI. GolangCI-Lint 生产级静态分析工具 golangci-lint is a fast Go linters runner. It runs linters in parallel, uses caching, supports YAML configuration, integrates with all major IDEs, and includes over a hundred linters. golangci-lint 是一款快速的 Go 语言 linter，它并行运行多个 linter 程序，使用缓存，支持 YAML 配置，与所有主流集成开发环境集成，并包含一百多个 linter 程序。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:13:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"安装 go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest # Verify golangci-lint --version ","date":"2024-04-19","objectID":"/posts/golang-linter/:13:1","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"如何使用 golangci-lint ? 在不进行任何配置的情况下，GolangCI-Lint 将默认采用启动以下 Linters: errcheck, gosimple, govet, ineffassign, staticcheck, unused. 也可以通过传递 -E(--enable) 参数来启动 Linter，传递 -D(--disable) 来禁用 Linter. golangci-lint run --disable-all -E errcheck ","date":"2024-04-19","objectID":"/posts/golang-linter/:13:2","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"Visual Studio Code 集成 由于个人一直使用 VSCode 开发各种程序，这里只展示其如何集成 GolangCI-Lint。 Step 1. settings.json 启用 golangci-lint \"go.lintTool\": \"golangci-lint\", \"go.lintFlags\": [ \"--fast\" // Using it in an editor without --fast can freeze your editor. ] Step 2. 配置 .golangci.yml 当使用 Golangci-lint 时，它会自动在编辑的 Go 文件所在的目录或父目录中查找 .golangci.yml 配置文件。 如果找到了配置文件，Golangci-lint 就会根据该配置文件的设置来运行 linter。 因此，在 VS Code 的设置中，不需要专门配置 Golangci-lint。 只需要在项目根目录或相应的目录下创建 .golangci.yml 配置文件，并在其中指定需要启用的 linter 和相关选项即可。 Step 3. Enjoy your coding time 🥂 Golangci-lint 同样支持 GoLang、NeoVim 等流行 IDE 集成. ","date":"2024-04-19","objectID":"/posts/golang-linter/:13:3","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":".golangci.yml 参考配置 这里给出一个个人在用的 golangci-lint 完整配置文件，以供参考： run: timeout: 5m go: 1.21 linters-settings: funlen: lines: 150 statements: 100 goconst: min-len: 3 min-occurrences: 3 lll: line-length: 80 govet: # 对于linter govet，这里手动开启了它的某些扫描规则 shadow: true check-unreachable: true check-rangeloops: true check-copylocks: true # 启动nilness检测 enable: - nilness linters: disable-all: true enable: - bodyclose - errcheck - funlen - goconst - gocyclo - gofmt - goimports - gosimple - govet - ineffassign - lll - misspell # Go 静态分析工具，专注于检查代码中的拼写错误 - nilerr - rowserrcheck - staticcheck - typecheck - unconvert - unparam - unused - whitespace issues: skip-dirs: - test exclude-files: - _test.go 更多详细信息，请参考官方文档 ","date":"2024-04-19","objectID":"/posts/golang-linter/:13:4","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"XII. reviewdog A code review dog who keeps your codebase healthy. reviewdog 是一个用于自动化代码审查的工具，旨在通过集成各种 linter 工具来简化代码质量检查。它能够将 lint 工具的输出结果作为评论发布到代码托管服务（如 GitHub、GitLab 等），从而提高代码审查的效率和准确性。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:14:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"功能 自动发布评论：reviewdog 可以将 lint 工具的结果自动发布为评论，帮助开发者快速识别代码中的问题。 支持多种 linter：它支持多种静态分析工具，包括 golangci-lint、eslint、pylint 等，可以方便地集成到现有的开发流程中。 过滤输出：支持根据 diff 过滤 lint 工具的输出，只报告在当前变更中出现的问题。 多种报告模式：支持多种报告模式，如 GitHub PR 评论、GitHub Checks、GitLab 合并请求讨论等。 本地运行：除了在 CI/CD 环境中运行外，reviewdog 也可以在本地环境中使用，方便开发者在提交代码前进行检查。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:14:1","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"安装 # Install the latest version. (Install it into ./bin/ by default). $ curl -sfL https://raw.githubusercontent.com/reviewdog/reviewdog/master/install.sh | sh -s # Specify installation directory ($(go env GOPATH)/bin/) and version. $ curl -sfL https://raw.githubusercontent.com/reviewdog/reviewdog/master/install.sh | sh -s -- -b $(go env GOPATH)/bin [vX.Y.Z] # In alpine linux (as it does not come with curl by default) $ wget -O - -q https://raw.githubusercontent.com/reviewdog/reviewdog/master/install.sh | sh -s [vX.Y.Z] 推荐使用第二种安装方式 curl -sfL https://raw.githubusercontent.com/reviewdog/reviewdog/master/install.sh | sh -s -- -b $(go env GOPATH)/bin，具体安装实例如下： $ curl -sfL https://raw.githubusercontent.com/reviewdog/reviewdog/master/install.sh | sh -s -- -b $(go env GOPATH)/bin reviewdog/reviewdog info checking GitHub for latest tag reviewdog/reviewdog info found version: 0.20.1 for v0.20.1/Darwin/arm64 reviewdog/reviewdog info installed /Users/kyden/go/bin/reviewdog ","date":"2024-04-19","objectID":"/posts/golang-linter/:14:2","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"如何使用 reviewdog ? 本地使用 golangci-lint run ./... 2\u003e\u00261 | reviewdog -f=golangci-lint -reporter=local 官方示例 ","date":"2024-04-19","objectID":"/posts/golang-linter/:14:3","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"Github Action 1. 创建 GitHub Actions 工作流 在项目根目录下创建一个 GitHub Actions 工作流文件，.github/workflows/reviewdog.yml 2. 配置 .golangci.yml 在项目根目录下创建一个 .golangci.yml 配置文件，配置需要启用的 linter 3. 提交代码 当你提交代码并创建拉取请求时，GitHub Actions 会自动运行 reviewdog，并根据 lint 工具的输出在拉取请求中添加评论，指出代码中的问题。 更多内容请参考官方示例 ","date":"2024-04-19","objectID":"/posts/golang-linter/:14:4","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"XIII. Summary 综上所述，Golang 生态中有众多优秀的 Linter 工具，它们能够有效地检查代码质量，提高项目的可维护性和可靠性。 开发者可以根据项目需求，选择合适的 Linter 工具，并将其集成到 CI/CD 流程中，持续改善代码质量。 未来，随着 Golang 社区的不断发展，相信会有更多优秀的 Linter 工具问世，为 Golang 开发者提供更加强大的代码分析能力。 ","date":"2024-04-19","objectID":"/posts/golang-linter/:15:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Golang","Linter","Static Check","CI/CD"],"content":"XIV. Reference Cyclomatic complexity Gocyclo bodyclose sqlrows GolangCI-Lint static analysis reviewdog ","date":"2024-04-19","objectID":"/posts/golang-linter/:16:0","tags":["Golang","Linter","Static Check","CI/CD"],"title":"深入解读 Golang 常用 Linter 工具及最佳实践","uri":"/posts/golang-linter/"},{"categories":["Typora","Theme","Markdown","Software"],"content":" 导语 分享一个好看的 Typora 主题 ","date":"2024-04-18","objectID":"/posts/typora-theme/:0:0","tags":["Typora","Theme","Markdown","Software"],"title":"Typora Theme","uri":"/posts/typora-theme/"},{"categories":["Typora","Theme","Markdown","Software"],"content":"效果 本 Typora 软件主题是在 Purple 之上修改而来，具体效果如下： ","date":"2024-04-18","objectID":"/posts/typora-theme/:1:0","tags":["Typora","Theme","Markdown","Software"],"title":"Typora Theme","uri":"/posts/typora-theme/"},{"categories":["Typora","Theme","Markdown","Software"],"content":"Source 由于实现源码太长，给出下载连接：kyden.css @include-when-export url(https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400\u0026subset=latin,latin-ext); /* open-sans-regular - latin-ext_latin */ @font-face { font-family: \"Open Sans\"; font-style: normal; font-weight: normal; src: local(\"Open Sans Regular\"), local(\"OpenSans-Regular\"), url(\"./github/open-sans-v17-latin-ext_latin-regular.woff2\") format(\"woff2\"); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD, U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF; } /* open-sans-italic - latin-ext_latin */ @font-face { font-family: \"Open Sans\"; font-style: italic; font-weight: normal; src: local(\"Open Sans Italic\"), local(\"OpenSans-Italic\"), url(\"./github/open-sans-v17-latin-ext_latin-italic.woff2\") format(\"woff2\"); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD, U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF; } /* open-sans-700 - latin-ext_latin */ @font-face { font-family: \"Open Sans\"; font-style: normal; font-weight: bold; src: local(\"Open Sans Bold\"), local(\"OpenSans-Bold\"), url(\"./github/open-sans-v17-latin-ext_latin-700.woff2\") format(\"woff2\"); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD, U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF; } /* open-sans-700italic - latin-ext_latin */ @font-face { font-family: \"Open Sans\"; font-style: italic; font-weight: bold; src: local(\"Open Sans Bold Italic\"), local(\"OpenSans-BoldItalic\"), url(\"./github/open-sans-v17-latin-ext_latin-700italic.woff2\") format(\"woff2\"); unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD, U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF; } :root { --title-color: #8064a9; --text-color: #444444; --light-text-color: #666666; --lighter-text-color: #888888; /* --link-color: #2aa899; */ /* --code-color: #745fb5; */ --link-color: #745fb5; /* --code-color: #2aa899; */ --code-color: #ec71b7; --shadow-color: #eee; --border-quote: rgba(116, 95, 181, 0.2); --border-quote-grey: #c8c8c8; --border: #e7e7e7; --link-bottom: #bbb; --shadow: 3px 3px 10px var(--shadow-color); --inline-code-bg: #f4f2f9; --header-weight: normal; --side-bar-bg-color: #fafafa; --control-text-color: var(var(--light-text-color)); --active-file-text-color: var(--title-color); --active-file-bg-color: var(--shadow-color); --item-hover-bg-color: var(--shadow-color); --active-file-border-color: var(var(--title-color)); --base-font: \"Open Sans\", \"Clear Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif; --title-font: \"EB Garamond\", \"Source Sans Pro\", serif; --monospace: Courier, Monospace !important; } /* 打印 */ @media print { html { font-size: 0.9rem; } table, pre { page-break-inside: avoid; } pre { word-wrap: break-word; } #write { max-width: 100%; } @page { size: A2; font-size: 0.2rem; /* PDF output size */ margin-left: 0; margin-right: 0; } } html { font-size: 16px; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; text-rendering: optimizelegibility; -webkit-font-smoothing: initial; } body { color: var(--text-color); -webkit-font-smoothing: antialiased; line-height: 1.6; letter-spacing: 0; overflow-x: hidden; } /* 页边距 和 页面大小 */ #write { font-family: var(--base-font); /* max-width: 914px; */ margin: 0 auto; padding: 1rem 4rem; padding-bottom: 100px; } #write p { line-height: 1.6rem; word-spacing: 0.05rem; } body\u003e*:first-child { margin-top: 0 !important; } body","date":"2024-04-18","objectID":"/posts/typora-theme/:2:0","tags":["Typora","Theme","Markdown","Software"],"title":"Typora Theme","uri":"/posts/typora-theme/"},{"categories":["Typora","Theme","Markdown","Software"],"content":"Reference Typora Purple ","date":"2024-04-18","objectID":"/posts/typora-theme/:3:0","tags":["Typora","Theme","Markdown","Software"],"title":"Typora Theme","uri":"/posts/typora-theme/"},{"categories":[],"content":"Kyden 源起 奥地利心理学家阿德勒曾说，幸福的人用童年治愈一生，不幸的人用一生治愈童年。 本人来自于华中地区的小农村，毋庸置疑拥有一个非常轻松加愉快的童年，而“纸鸢飞舞”属于童年中的记忆深刻的事物，故以此为作为昵称。 Kyden (纸鸢飞舞，鸢舞) 来自 “kite” 和“dance” 组合的变体 “KiteDance、KyteDance”。 ","date":"2024-04-18","objectID":"/about/:1:0","tags":[],"title":"About KyteDance (鸢舞)","uri":"/about/"},{"categories":[],"content":"经典 幸福的人用童年治愈一生,不幸的人用一生治愈童年. –阿德勒 我本可以忍受黑暗, 如果我不曾见过太阳. 可是那阳光, 刺破了我内心的荒凉. – 艾米莉·狄金森 ","date":"2024-04-18","objectID":"/about/:2:0","tags":[],"title":"About KyteDance (鸢舞)","uri":"/about/"},{"categories":[],"content":"Special Thanks Thanks to the authors of following resources included in the theme: Hugo LoveIt Gitalk ","date":"2024-04-18","objectID":"/about/:3:0","tags":[],"title":"About KyteDance (鸢舞)","uri":"/about/"},{"categories":["Linux","Software"],"content":" 导语 详细介绍日常使用 Arch Linux 的各种问题与解决方案，包括 Arch 安装、常用软件推荐、系统优化等. ","date":"2024-04-17","objectID":"/posts/arch-linux/:0:0","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"I. Install Arch ","date":"2024-04-17","objectID":"/posts/arch-linux/:1:0","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"1. Download Arch Linux ISO archlinux-x86_64.iso ","date":"2024-04-17","objectID":"/posts/arch-linux/:1:1","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"2. U 盘 ventoy 准备 ventory 过程：略 选择 Arch Linux install medium (x86_64, UEFI) 启动安装环境 进入 root@archiso 后，需要设置互联网，推荐使用网线连接 检查网络接口是否已经启用 ip link # ... 2: enp0s3: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 ... # ... 尖括号内的“UP”，表示接口已经启用，否则使用以下命令：ip link set enp0s3 up 请使用 ping 命令测试网络: ping www.baidu.com ","date":"2024-04-17","objectID":"/posts/arch-linux/:1:2","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"3. 更新系统时钟 在互联网连接之后，systemd-timesyncd 服务将自动校准系统时间，便于安装软件包时验证签名 $ timedatectl ","date":"2024-04-17","objectID":"/posts/arch-linux/:1:3","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"4. 分区设置 $ mkfs.ext4 /dev/nvme1n1p7 #用作根分区，挂载到 / # mkfs.fat -F32 /dev/nvme1n1p3 #用作EFI分区 ，挂载到 /boot/efi # 如果安装Windows时已经有个EFI分区，就把上面的 /dev/nvme1n1p3 换成已有的EFI分区 $ mkfs.ext4 /dev/nvme1n1p8 # 挂载到 /home 目录 # mount $ mount /dev/nvme1n1p7 /mnt $ mkdir -p /mnt/boot/efi $ mount /dev/nvme1n1p1 /mnt/boot/efi $ mount --mkdir /dev/nvme1n1p8 /mnt/home ","date":"2024-04-17","objectID":"/posts/arch-linux/:1:4","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"5. 选择软件镜像仓库 手动修改 /etc/pacman.d/mirrorlist，添加相关镜像 $ vim /etc/pacman.d/mirrorlist Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch $ pacman -Sy archlinuxcn-keyring $ pacman -Syyu ","date":"2024-04-17","objectID":"/posts/arch-linux/:1:5","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"6. 安装基础包 $ pacstrap /mnt bash base base-devel linux linux-headers linux-firmware neovim xsel # fstab $ genfstab -U -p /mnt \u003e\u003e /mnt/etc/fstab ","date":"2024-04-17","objectID":"/posts/arch-linux/:1:6","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"7. chroot -\u003e 设置系统属性 切换系统 $ arch-chroot /mnt 设置时区 $ ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime $ hwclock --systohc 修改 hostname $ vim /etc/hostname arch 设置 locale $ vim /etc/locale.conf `LANG_en_US.UTF-8` $ vim /etc/locale.gen en_US.UTF-8 UTF-8 # 取消注释 zh_CN.UTF-8 UTF-8 # 取消注释 $ locale-gen 网络管理器，蓝牙 $ pacman -S networkmanager bluez bluez-utils pulseaudio-bluetooth alsa-utils pulseaudio pulseaudio-alsa sof-firmware $ systemctl enable NetworkManager.service $ systemctl enable bluetooth.service 设置 password $ passwd 引导相关 # ucode $ cat /proc/cpuinfo | grep \"model name\" $ pacman -S intel-ucode # amd-ucode # 安装引导加载程序 $ pacman -S grub efibootmgr os-prober $ grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB # 配置 os-prober $ vim /etc/default/grub GRUB_DISABLE_OS_PROBER=false # 取消注释 $ grub-mkconfig -o /boot/grub/grub.cfg Create user and usergroup $ useradd -m -G wheel kyden # 为新用户 kyden 设置 passwd # 修改权限 $ pacman -S sudo man-pages man-db $ vim /etc/sudoers %wheel ALL=(ALL:ALL) ALL # 取消注释 # 切换至 kyden 用户 $ su - kyden 桌面程序 - KDE # KDE $ sudo pacman -S plasma xorg nvidia dolphin konsole fish noto-fonts-cjk noto-fonts-emoji $ sudo systemctl enable sddm # reboot $ exit $ swapoff /mnt/swapfile $ umount -R /mnt $ reboot ","date":"2024-04-17","objectID":"/posts/arch-linux/:1:7","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"II. Software ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:0","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"NetworkManager $ ping baidu.com $ systemctl enable NetworkManager ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:1","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"pacman 镜像修改 $ sudo vim /etc/pacman.conf # Misc options Color ParallelDownloads = 5 [multilib] Include = /etc/pacman.d/mirrorlist # 键入： [archlinuxcn] Server = https://mirrors.utsc.edu.cn/archlinuxcn/$arch $ sudo pacman -Syyu $ sudo pacman -S archlinuxcn-keyring ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:2","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"常见通用软件 $ yay -S fish # curl -L https://get.oh-my.fish | fish $ fish_config # 取消问候语 $ set -U fish_greeting \"\" $ sudo vim /etc/systemd/system/clash.service $ sudo systemctl daemon-reload $ sudo systemctl enable clash $ sudo systemctl start clash $ sudo systemctl status clash $ sudo pacman -S obs-studio 输入法 fcitx5 $ sudo pacman -S fcitx5 fcitx5-configtool fcitx5-qt fcitx5-gtk fcitx5-chinese-addons fcitx5-material-color fcitx5-pinyin-moegirl fcitx5-pinyin-zhwiki $ sudo vim /etc/environment GTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=\\@im=fcitx # 为了让一些使用特定版本 SDL2 库的游戏能正常使用输入法 SDL_IM_MODULE=fcitx $ yay -S clash-verge-rev-bin $ yay -Sy neofetch google-chrome obs-studio baidunetdisk \\ nutstore-experimental xunlei-bin telegram-desktop \\ gitkraken visual-studio-code-bin typora-free redis \\ net-tools pot-translation translate-shell okular \\ snipaste gwenview kcalc wemeet-bin vlc wget ark \\ shotcut inkscape ninja gnu-netcat tcpdump cmake \\ clang tree python-pip caj2pdf-qt ttf-hack-nerd \\ transmission-gtk gpick speedcrunch drawio-desktop \\ zeal electronic-wechat-uos-bin \\ linuxqq lx-music-desktop gpick: 可以从桌面任何地方取色，并且它还提供一些其它的高级特性 SpeedCrunch: 一个漂亮，开源，高精度的科学计算器 Snipaste: 截图工具，如不可用可选用spectacle drawio-desktop: Security-first diagramming for teams zeal：离线文档浏览器 trans-shell 基础用法 # 翻译到locale语言 $ trans [Words] # 翻译到指定语言 $ trans :zh [word] # 翻译到多种目标语言 $ trans :zh+ja word # 翻译句子和短语 $ trans en:zh \"word processor\" $ trans :zh \"To-morrow, and to-morrow, and to-morrow,\" # 简洁模式：默认情况下，Translate Shell 尽可能多的显示翻译信息。如果你希望只显示简要信息，只需要加上 -b选项。 $ trans -b :zh \"Saluton, Mondo\" $ trans -b :@ja \"Saluton, Mondo\" #显示发音符号，如果有的话，如日语罗马音，汉语拼音 # 翻译文件或网页 $ trans :zh file://\u003cinput.txt\u003e $ trans :zh https://github.com/kydance/ # 进入交互模式 $ trans -shell $ trans -shell en:fr Alais tsbz 'trans -b :zh' tsz 'trans :zh' tsbe 'trans -b :en' tse 'trans :en' office $ yay -S wps-office wps-office-mui-zh-cn ttf-wps-fonts ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:3","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"远程工具 - Remmina $ yay -S remmina freerdp 使用教程 安装 freerdp 插件后，可以走 RDP 协议远程 Win10（Win10 不需要其他任何设置） ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:4","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"Git 配置 git 设置user.name和user.emal $ git config --global user.name \"kyden\" $ git config --global user.email xxxxxx@gmail.com # Verify $ git config --list 生成密钥 # 要求多次输入密码，可不要输入密码 $ ssh-keygen -t rsa -C 'xxxxxx@gmail.com' GitHub 配置 SSH Keys 打开生成的 Key 文件 ~/.ssh/id_rsa.pub: cat ~/.ssh/id_rsa.pub 复制全部内容，在 Key 中粘贴 Git 常用命令 git status git clone git pull git push git commit -m 'commits' or git commit -m 'commits' kyden.go git add . or git kyden.go git reflog Git实现从本地添加项目到远程仓库 Steps: GitHub 上创建一个新的远程仓库 - Create a new repo -\u003e Create repository 本地仓库：创建并初始化 -\u003e 添加待上传到远程仓库的项目文件 git init 远程仓库和本地仓库关联 git remote add origin git@github.com:kydance/\u003crepository name\u003e 项目文件添加、提交、推送 由于远程库是空的，我们第一次 push master 分支时，加上了 -u 参数，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来 在以后的 push 或者 pull 时就可以简化命令 git add file $ git commit -m '\u003ccommit statements\u003e' file $ git push -u origin master 用 SSH 密钥在一台机器上管理多个账户 1. 检查一下我们是否有任何现有的 SSH 密钥 ls -al ~/.ssh 这将列出所有现有的公钥和私钥对，如果 ~/.ssh/id_rsa 是可用的，我们可以重新使用它，否则 ssh-keygen -t rsa 生成一个默认 ~/.ssh/id_rsa 的密钥. 通过以上方法，我们可以得到两个不同的密钥： id_rsa id_rsa.pub id_rsa_kyden id_rsa_kyden.pub 2. 将不同 SSH 密钥添加到相应的 GitHub 账户中 复制公钥 ~/.ssh/id_rsa.pub 的内容，将密钥粘贴在 Settings -\u003e SSH and GPG keys -\u003e New SSH key 的方框中即可 3. 在 ssh-agent 上注册新的 SSH 密钥 创建并编辑 SSH 配置文件 ~/.ssh/config Host kyden HostName github.com User git IdentityFile ~/.ssh/id_rsa_kyden Host github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa 注意更换 `Host` 当你克隆一个仓库或为本地仓库设置 remote origin 时，确保与你使用的主机名记号一致 (@ 和 : 之间的字符串应该与我们在 SSH 配置文件中给出的内容相匹配): # git clone git@github.com:kydance/dotfiles.git git clone git@kyden:kydance/dotfiles.git 4. 为本地仓库设置 user GitHub 会根据提交（commit）描述所附的电子邮件 ID 来识别任何提交的作者. 一旦我们克隆/创建了本地的 Git 仓库，确保 Git 配置的 user.name 和 user.email 正是你想要的 ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:5","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"Golang # Download and install go $ sudo pacman -S go $ vim .config/fish/config.sh # Set environment variable in `.config/fish/config.sh` or `/etc/profile` or `~/.profile` GOROOT /usr/lib/go GOPATH /home/kyden/goProj GOBIN /home/kyden/goProj/bin PATH $GOPATH/bin $GOROOT/bin $GOBIN $PATH GOROOT，设置 Golang 的安装位置 GOBIN，执行 go install 后生成可执行文件的目录 GOPATH，工作目录，一般设置到用户目录下 ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:6","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"MySQL 很多 Linux 发行版都放弃了对 MySQL 的支持（原因自行 Google）转而支持 mariadb（MySQL的另一个分支），Arch Linux就是其中之一，mariadb 具有和 MySQL 一模一样的操作命令，所以完全不用考虑迁移兼容的问题 安装mariadb: $ sudo pacman -Sy mariadb 配置 mariadb 命令，创建数据库都在 /var/lib/mysql/ 目录下面: $ sudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql 开启mariadb 服务: $ systemctl start mariadb 初始化密码，期间有让你设置密码的选项，设置你自己的密码就行了，然后根据自己需要 y/n 就可，因为很多后面可以再修改: $ sudo /usr/bin/mysql_secure_installation 登录mariadb 和mysql命令是一样的: $ mysql -u root -p 设置开机自启动服务: $ systemctl enable mariadb ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:7","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"挂载其他硬盘分区 # Get UUID and TYPE $ sudo blkid # eg: # /dev/nvme1n1p3: LABEL=\"Document\" BLOCK_SIZE=\"512\" UUID=\"111915F1111915F1\" TYPE=\"ntfs\" PARTLABEL=\"Basic data partition\" PARTUUID=\"666266ba-233b-11ed-95be-00e04c3656eb\" # Write UUID TYPE ... $ sudo vim /etc/fstab # \u003cdevice\u003e \u003cdir\u003e \u003ctype\u003e \u003coptions\u003e \u003cdump\u003e \u003cfsck\u003e UUID=111915F1111915F1 /home/kyden/doc ntfs3 defaults 0 0 \u003cdevice\u003e 描述要挂载的特定块设备或远程文件系统 \u003cdir\u003e 描述挂载目录 \u003ctype\u003e 文件系统类型 \u003coptions\u003e 相关的挂载选项 \u003cdump\u003e 会被 dump(8) 工具检查。该字段通常设置为 0, 以禁用检查 \u003cfsck\u003e 设置引导时文件系统检查的顺序; 对于 root 设备该字段应该设置为 1。对于其它分区该字段应该设置为 2,或设置为 0 以禁用检查 NOTE: TYPE 为 ntfs 时导致启动失败，修改为 ntfs3 后成功挂载 ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:8","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"Present Windows ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:9","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"scp: 文件上传、下载 上传 $ scp ./cifar-10-python.tar.gz kyden@\u003cip\u003e:/home/kyden/ 下载 $ scp kyden@\u003cip\u003e:/var/tmp/a.txt /var ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:10","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"picgo picgo-core Download and Install PigGo-Core Get token with GitHub Configure NOTE：使用时，将注释删掉，以免产生不必要的麻烦 // ~/.picgo/config.json { \"picBed\": { \"current\": \"github\", \"github\": { \"repo\": \"\u003cuserName\u003e/PicBed\", // 设定仓库名：上文在 GitHub 创建的仓库 `\u003cuserName\u003e/PicBed` \"branch\": \"master\", // 设定分支名：`master` \"token\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\", // 设定 Token：上文生成的 toke \"path\": \"\", // 指定存储路径：为空的话会上传到根目录，也可以指定路径 \"customUrl\": \"\" // 设定自定义域名：可以为空 }, \"uploader\": \"github\", \"transformer\": \"path\" }, \"picgoPlugins\": { \"picgo-plugin-github-plus\": true } } ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:11","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"CUDA \u0026 cuDNN $ yay -S cuda-11.7 cudnn8-cuda11.0 Arch Linux 会将 CUDA 相关档案安装至 /opt/cuda，有需要的话可以将 CUDA 的 PATH 加到 ~/bashrc，此路径永远指向最新版CUDA # ~/.fish_config set PATH /opt/cuda-11.7/bin $PATH set LD_LIBRARY_PATH /opt/cuda-11.7/lib64/ $PATH pip install torch==1.13.1+cu117 torchvision==0.14.1+cu117 torchaudio==0.13.1 --extra-index-url https://download.pytorch.org/whl/cu117 ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:12","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"Clash Verge DNS 泄露问题 DNS 泄露其实并没有一个明确的定义，也不存在一个官方解释。 大概就是说你访问YouTube等黑名单网站的时候，使用中国大陆的DNS服务器进行了解析，这可能导致隐私问题的。 如果在 DNS Leak Test 、ipleak这种网站的列表中看到了中国国旗，就要意识到可能发生了DNS泄露。 虽然没有人知道具体的探测机制是什么，但很可能是从网络层面获取的。在一般的家庭网络拓扑中，wireshark可以看到什么内容，运营商就能看见什么内容，所以你使用114.114.114.114、223.5.5.5这样的DNS解析去访问了什么网站是很清晰的。 Clash开启TUN模式，关闭系统代理去使用：与普通的系统代理模式区别在于，TUN模式下Clash会创建一张虚拟网卡，从网络层面接管所有的网络流量。 开启TUN模式 使用稳定的DNS DNS这部分有人会教使用运营商的DNS，运营商的DNS只适合小白用户，因为他可能连反诈，所以建议使用国内大厂的。 [Optional] 关闭浏览器的QUIC, 中国大陆的isp是限速udp的, 所以导致QUIC这个优秀的协议, 到了中国大陆的网络下成了个负面增益效果。 about://flags/#enable-quic 设置为Disabled (点下方弹出的重启浏览器生效) 关闭浏览器中的“安全DNS” chrome://settings/security 在Clash Verge的【Profiles】中，点右上角的\"NEW\" -\u003e Type选择\"Script\" -\u003e Name随意填写(例如，“修改DNS”) 右击新建的文件，然后\"Edit File\"，输入以下内容后启用： function main(content) { const isObject = (value) =\u003e { return value !== null \u0026\u0026 typeof value === 'object' } const mergeConfig = (existingConfig, newConfig) =\u003e { if (!isObject(existingConfig)) { existingConfig = {} } if (!isObject(newConfig)) { return existingConfig } return { ...existingConfig, ...newConfig } } const cnDnsList = [ 'tls://223.5.5.5', 'tls://1.12.12.12', ] const trustDnsList = [ 'https://doh.apad.pro/dns-query', 'https://dns.cooluc.com/dns-query', 'https://1.0.0.1/dns-query', ] const notionDns = 'tls://dns.jerryw.cn' const notionUrls = [ 'http-inputs-notion.splunkcloud.com', '+.notion-static.com', '+.notion.com', '+.notion.new', '+.notion.site', '+.notion.so', ] const combinedUrls = notionUrls.join(','); const dnsOptions = { 'enable': true, 'default-nameserver': cnDnsList, // 用于解析DNS服务器 的域名, 必须为IP, 可为加密DNS 'nameserver-policy': { [combinedUrls]: notionDns, 'geosite:geolocation-!cn': trustDnsList, }, 'nameserver': trustDnsList, // 默认的域名解析服务器, 如不配置fallback/proxy-server-nameserver, 则所有域名都由nameserver解析 } // GitHub加速前缀 const githubPrefix = 'https://ghproxy.lainbo.com/' // GEO数据GitHub资源原始下载地址 const rawGeoxURLs = { geoip: 'https://github.com/MetaCubeX/meta-rules-dat/releases/download/latest/geoip-lite.dat', geosite: 'https://github.com/MetaCubeX/meta-rules-dat/releases/download/latest/geosite.dat', mmdb: 'https://github.com/MetaCubeX/meta-rules-dat/releases/download/latest/country-lite.mmdb', } // 生成带有加速前缀的GEO数据资源对象 const accelURLs = Object.fromEntries( Object.entries(rawGeoxURLs).map(([key, githubUrl]) =\u003e [key, `${githubPrefix}${githubUrl}`]), ) const otherOptions = { 'unified-delay': true, 'tcp-concurrent': true, 'profile': { 'store-selected': true, 'store-fake-ip': true, }, 'sniffer': { enable: true, sniff: { TLS: { ports: [443, 8443], }, HTTP: { 'ports': [80, '8080-8880'], 'override-destination': true, }, }, }, 'geodata-mode': true, 'geox-url': accelURLs, } content.dns = mergeConfig(content.dns, dnsOptions) return { ...content, ...otherOptions } } 设置完成后，验证DNS解析结果是否都是来自国外的Cloudflare和Google的DNS, 这时节点服务器不管拿到了你传过去的真ip还是假ip地址, 他都会再去请求一次Cloudflare/Google的DNS服务, 确保解析的正确性。 重要的是没有中国大陆的DNS服务器了，如果还是有，那你应该往当前设备的更上层寻找问题所在，比如路由器的设置等。 GEOIP，CN问题 目前市面上绝大多数的代理工具都依赖于 GeoIP2 数据库判断地址所属地。它们的规则结尾部分一般都会有一条类似 GEOIP, CN，用来查询目的 IP 地址是否属于中国大陆，从而判断是否直连。 这些代理工具通常使用的 GeoIP2 数据库是来自于 MaxMind 的 GeoLite2 免费数据库。这个数据库目前存在一下几个问题： 获取不便：从 2019 年 12 月 30 日起，必须注册后才能下载 数据量大：数据库庞大，包含全球的 IP 地址段，约 10 MB 准确度低：对中国大陆的 IP 地址判定不准，如：香港阿里云的 IP 被判定为新加坡、中国大陆等。 庞大的数据量对于大多数中国大陆的用户来说是没有意义的，因为只仅需要去判断 IP 的地理位置是否属于中国大陆境内，其他国家的 IP 一律代理/直连。过多的数据量会增加载入时间，降低查询效率。 我们在之前创建的Script中已经包含了下载更精简合适中国大陆的IP数据库链接, 现在只需要手动操作下载和替换即可: Update GeoData: Clash Verge Rev的设置菜单中点击Update GeoData 验证下载: 打开Clash Verge托盘中的APP Dir，找到geoip.dat文件，验证其大小是否为几百KB 重启Clash Verge：确保数据库被正确应用 ","date":"2024-04-17","objectID":"/posts/arch-linux/:2:13","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"III. 内核更换 Install The Desired Kernel $ sudo pacman -S linux-lts linux-lts-headers Editing GRUB Config File $ sudo vim /etc/default/grub GRUB_DISABLE_SUBMENU=y # disables the GRUB submenu, i.e., it enables all the available kernels to be listed on the main GRUB Menu itself instead of the “Advanced option for Arch Linux” option. GRUB_DEFAULT=saved # saves the last kernel used GRUB_SAVEDEFAULT=true # makes sure that grub uses the last selected kernel is used as default Re-Generate GRUB Configuration file $ sudo grub-mkconfig -o /boot/grub/grub.cfg Choose Kernel From GRUB During Boot. 🥂 ","date":"2024-04-17","objectID":"/posts/arch-linux/:3:0","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"IV. System optimization ","date":"2024-04-17","objectID":"/posts/arch-linux/:4:0","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"SSD 优化 TRIM, 会帮助清理SSD中的块，从而延长SSD的使用寿命 $ sudo systemctl enable fstrim.timer $ sudo systemctl start fstrim.timer ","date":"2024-04-17","objectID":"/posts/arch-linux/:4:1","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"SWAP 设置 https://wiki.archlinux.org/title/Swap#Swappiness 查看 swap 使用率，一般是 60 ，意思是 60% 的概率将内存整理到 swap: cat /proc/sys/vm/swappiness 修改 swap 使用策略为 10%，即 10% 的概率将内存整理到 swap: sudo sysctl -w vm.swappiness=10 修改配置文件：sudo vim /etc/sysctl.d/99-swappiness.conf 在文件末尾加上下面这行内容：vm.swappiness=10 重启后可查看 swappiness 的值 ","date":"2024-04-17","objectID":"/posts/arch-linux/:4:2","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"Systemd journal size limit 控制日志最大可使用多少磁盘空间，修改/etc/systemd/journald.conf 中的SystemMaxUse参数 SystemMaxUse=50M ","date":"2024-04-17","objectID":"/posts/arch-linux/:4:3","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"V. Problem And Solution ","date":"2024-04-17","objectID":"/posts/arch-linux/:5:0","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"1. clear command - terminals database is inaccessible 解决方案： Path for Anaconda3 is set in .bashrc. It is interfering with the clear command. Removing Anaconda path from path solved the issue. $ echo $CONDA_PREFIX /opt/miniconda $sudo mv $CONDA_PREFIX/bin/clear $CONDA_PREFIX/bin/clear_old ","date":"2024-04-17","objectID":"/posts/arch-linux/:5:1","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"2. tput: unknown terminal \"xterm-256color\" 解决方案： $ setenv TERMINFO /usr/lib/terminfo ","date":"2024-04-17","objectID":"/posts/arch-linux/:5:2","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"3. 更新内核后，双屏显示时，某一个屏幕黑屏，但鼠标能够移动过去并显示，另一屏幕正常 解决方案： xrandr --output HDMI-1-0 --right-of eDP1 --auto 命令解释：配置 HDMI-1-0 输出，使其位于 eDP1 输出的右侧，并自动选择最佳的分辨率和刷新率设置 $ xrandr --listmonitors Monitors: 2 0: +*eDP1 2560/360x1440/200+0+0 eDP1 1: +HDMI-1-0 1920/479x1080/260+2560+0 HDMI-1-0 $ xrandr --output HDMI-1-0 --right-of eDP1 --auto ","date":"2024-04-17","objectID":"/posts/arch-linux/:5:3","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"4. zip 压缩包解压乱码 产生这种情况的原因是，zip 格式本身的缺陷导致的： zip 格式没有指定文件名的编码格式，因此在压缩和解压时都会采用操作系统本地编码， Windows 下简体中文采用的是 GBK/GB312 编码，而 Linux 采用的是 UTF-8 编码，两者不一致导致了乱码的产生。 解决方案: $ unzip -O GBK xxx.zip ","date":"2024-04-17","objectID":"/posts/arch-linux/:5:4","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"5. wps-office大部分字体粗体出现过粗无法正常显示问题 问题: freetype2 更新至 2.13.0 以上版本后出现的问题，导致 wps-office 文档编辑文字大部分字体设置粗体出现过粗无法正常显示。 解决方案： freetype2 降级至 2.13.0 Download freetype2.13.0 降级 sudo pacman -U freetype2-2.13.0-1-x86_64.pkg.tar.zst 修改 /etc/pacman.conf -\u003e IgnorePkg = freetype2，排除掉这个包（不让它更新） freetype2: ignoring package upgrade (2.13.0-1 =\u003e 2.13.2-1) $ env LD_LIBRARY_PATH=/usr/local/freetype2-2.13.0-1-x86_64/usr/lib $ update-desktop-database ~/.local/share/applications ","date":"2024-04-17","objectID":"/posts/arch-linux/:5:5","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"6. wpspdf 无法打开 PDF 文件 wpspdf 依赖于 libtiff5.so.5 以支撑其 PDF 功能。 而系统更新后，Arch Linux 提供的是 libtiff.so.6 或更新版本，导致其无法正常工作。 解决方案： 安装 libtiff5 ","date":"2024-04-17","objectID":"/posts/arch-linux/:5:6","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"7. WPS 无法输入中文 解决方案 - wpp wpspdf wpp et ","date":"2024-04-17","objectID":"/posts/arch-linux/:5:7","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Linux","Software"],"content":"8. lx-music 数据同步失败 解决方案 确保PC端的同步服务已启用成功: 若连接码、同步服务地址没有内容，则证明服务启动失败，此时看启用同步功能复选框后面的错误信息自行解决 在手机浏览器地址栏输入http://x.x.x.x:5963/hello后回车，若此地址可以打开并显示 Hello~::^-^::v4，则证明移动端与PC端网络已互通， 若移动端无法打开第2步的地址，则在PC端的浏览器地址栏输入并打开该地址，若可以打开，则可能性如下： LX Music PC端被电脑防火墙拦截 PC端与移动端不在同一个网络下， 路由器开启了AP隔离（一般在公共网络下会出现这种情况） 要验证双方是否在同一个网络或是否开启AP隔离，可以在电脑打开cmd使用ping命令ping移动端显示的ip地址，若可以通则说明网络正常 ","date":"2024-04-17","objectID":"/posts/arch-linux/:5:8","tags":["Arch","Linux","Software"],"title":"Arch Linux 指南","uri":"/posts/arch-linux/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":" 导语 借助于 Github Pages 提供的静态网站托管服务，并采用了 Hugo 这一开源项目，加快了建站流程，而且有多种开源网站主题可供选择. ","date":"2024-04-17","objectID":"/posts/build-blog/:0:0","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"I. 前言 在博客网站搭建完成之后，有充分的理由相信，自己在未来很长一段时间内将不会再次重复建站。 常言道天有不测风云，为了防止各种意外情况发生，导致本博客网站无法正常使用，同时防止自己忘记搭建流程，记录于此。 ","date":"2024-04-17","objectID":"/posts/build-blog/:1:0","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"II. 效果 ","date":"2024-04-17","objectID":"/posts/build-blog/:2:0","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"III. 相关知识简介 ","date":"2024-04-17","objectID":"/posts/build-blog/:3:0","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"Github Pages GitHub Pages 是一个免费的静态网站托管服务，它允许用户通过 GitHub 存储库来托管和发布网页，可以使用它来展示项目文档、博客或个人简历。 现阶段，Github Pages 支持公共存储库的免费的托管；对于私有仓库，需要进行缴费。 ","date":"2024-04-17","objectID":"/posts/build-blog/:3:1","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"Hugo 官方号称，Hugo 是世界上最快的网站建设框架(The world’s fastest framework for building websites)。 ","date":"2024-04-17","objectID":"/posts/build-blog/:3:2","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"IV. Steps ","date":"2024-04-17","objectID":"/posts/build-blog/:4:0","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"1. Github 仓库创建 需要创建两个仓库，一个用于网站源码管理(A)，一个用于网站部署(B): A 可以是 public，也可以是 private； B 仓库的名称必须是 \u003cusername\u003e.github.io（username 是 Github Accout 中username，不是 profile 中的 Name），同时还需要添加 README.md，例如：kydance.github.io. ","date":"2024-04-17","objectID":"/posts/build-blog/:4:1","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"2. 使用 Hugo 创建网站 首先，使用 Git 将 A 拉取下来: $ git clone git@github.com:kydance/blog.git 然后，进入本地的 A 目录（即，blog）下，使用 hugo 建站： # Linux: Install Hugo $ sudo pacman -S hugo # Verify $ hugo version # 建站，然后将生成的内容复制到 `A` 仓库中 $ hugo new blog $ mv blog/ . $ rm -rf blog ","date":"2024-04-17","objectID":"/posts/build-blog/:4:2","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"3. Hugo 设置网站主题 可以从 Hugo Themes 挑选合适的主题进行应用： $ cd themes $ git clone https://github.com/kakawait/hugo-tranquilpeak-theme.git tranquilpeak 安装 Hugo 主题后，根据个人情况修改相应的配置文件即可； ","date":"2024-04-17","objectID":"/posts/build-blog/:4:3","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"4. 文章管理 启动 Hugo server 启动本地 server： $ hugo server -D 浏览器打开 http://localhost:1313/ 进行预览； 新建文章 # `post/Golang/Go.md` 表明 markdown 的路径 $ hugo new content `post/Golang/Go.md` 一键创建文章: ./new-blog.sh \u003cname\u003e #!/bin/bash CONTENT_PATH=posts/ # Welcome to the new-blog.sh script! echo -e \"\\033[0;32mCreating new blog post...\\033[0m\" # Check if the user has provided an argument if [ $# -ne 1 ] then echo -e \"\\033[0;31mMissing one argument, Usage: new-blog.sh \u003cblog-name\u003e\\033[0m\"; exit; fi # Get the blog name from the user CONTENT_PATH=$CONTENT_PATH$1/$1.md echo -e \"\\033[0;32mBlog path: $CONTENT_PATH\\033[0m\" # Create the new blog post hugo new content $CONTENT_PATH # Success echo -e \"\\033[0;32mCreate new blog post $CONTENT_PATH successful.\\033[0m\" 部署文章 构建 Hugo 网站相关静态文件 Hugo 将构建完成的静态内容保存到 A 仓库中的 public 文件夹中； $ hugo 部署 进入 public 目录，利用 Git 进行管理该文件夹，并推送到远程 B 仓库中： $ git init $ git commit -m \"first commit\" $ git branch -M master $ git remote add origin https://github.com/kydance/kydance.github.io.git $ git push -u origin master 自动化一键部署：deploy.sh #!/bin/bash echo -e \"\\033[0;32mDeploying updates to GitHub...\\033[0m\" # Build the project. hugo # if using a theme, replace with hugo -t # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\"rebuilding site `date` \" echo -e \"\\033[0;32m$msg\\033[0m\" if [ $# -eq 1 ] then msg=\"$1\" fi git commit -m \"$msg\" # Push source and build repos. git push origin master # Come Back up to the Project Root cd .. 删除文章 进入 blog/posts/ 目录中，删除，目标文件夹（包含相关文章资源）即可； NOTE：blog/public 中相关文件可以删除，也可以不删除，推荐删除； ","date":"2024-04-17","objectID":"/posts/build-blog/:4:4","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"5. 网站图标 把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 realfavicongenerator 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. avatar头像 在 gavatar 网站注册并上传图片即可 ","date":"2024-04-17","objectID":"/posts/build-blog/:4:5","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"6. Google Analytics 首先，在 Google Analytics 网站中注册、设置完成相应选项，即可获取 ID：G-XXXXXXXXXX； 然后在 layout/_default/baseof.html 文件中添加以下代码即可： \u003c!-- Google tag (gtag.js) --\u003e \u003cscript async src=\"https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX\"\u003e\u003c/script\u003e \u003cscript\u003e window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-XXXXXXXXXX'); \u003c/script\u003e 该段代码获取方法如下： Google Analytics -\u003e 管理 -\u003e “媒体资源设置\"列中的数据流 -\u003e 网站 -\u003e 对应的数据流 -\u003e “Google 代码” 下的查看代码说明 -\u003e “安装说明” 选择手动添加. 建议添加完成后，在 Google Analytics 分析中进行测试，确保生效 ","date":"2024-04-17","objectID":"/posts/build-blog/:4:6","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"7. Gitalk 评论系统 Gitalk 的评论采用的是 PR/Issue 的方式存储评论，因此，一般需要新建一个专门的 Repo，例如kydance/gitalk. GitHub 申请注册新应用，并填写以下相关内容： Application name: 随意 Homepage URL: 包含 http/https 前缀，例如https://kydance.github.io Authorization callback URL: 和上面 Homepage URL 保持一致就行 注册完成后，手动生成 Client secrets(只会出现一次)，同时获得 Client ID. 最后，在主题设置中填写相应信息即可，例如 LoveIt 中的 config.toml: [params.page.comment] enable = true [params.page.comment.gitalk] enable = true owner = \"lutianen\" repo = \"gitalk\" clientId = \"xxxxxxxxxxxxxxxxxxxx\" clientSecret = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\" ","date":"2024-04-17","objectID":"/posts/build-blog/:4:7","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"8. 网站运行时间统计 在 footer.html 加入以下内容即可： {{- /* runtime */ -}} \u003c/br\u003e\u003cscript\u003e function siteTime() { var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var today = new Date(); var startYear = 2024; var startMonth = 4; var startDate = 18; var startHour = 12; var startMinute = 57; var startSecond = 2; var todayYear = today.getFullYear(); var todayMonth = today.getMonth() + 1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond); var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond); var diff = t2 - t1; var diffYears = Math.floor(diff / years); var diffDays = Math.floor((diff / days) - diffYears * 365); var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours); var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes); var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds); if (startYear == todayYear) { document.getElementById(\"sitetime\").innerHTML = \"已安全运行 \" + diffDays + \" 天 \" + diffHours + \" 小时 \" + diffMinutes + \" 分钟 \" + diffSeconds + \" 秒\"; } else { document.getElementById(\"sitetime\").innerHTML = \"已安全运行 \" + diffYears + \" 年 \" + diffDays + \" 天 \" + diffHours + \" 小时 \" + diffMinutes + \" 分钟 \" + diffSeconds + \" 秒\"; } } setInterval(siteTime, 1000); \u003c/script\u003e \u003cspan id=\"sitetime\"\u003e载入运行时间...\u003c/span\u003e ","date":"2024-04-17","objectID":"/posts/build-blog/:4:8","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"V. 主题扩展 ","date":"2024-04-17","objectID":"/posts/build-blog/:5:0","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"Link kydance.github.io https://kydance.github.io ","date":"2024-04-17","objectID":"/posts/build-blog/:5:1","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"Admonition This is a note NOTE This is a abstract ABSTRACT This is a info INFO This is a tip TIP This is a success SUCCESS This is a question QUESTION This is a warning WARNING This is a failure FAILURE This is a danger danger This is a bug BUG This is a example EXAMPLE This is a quote QUOTE ","date":"2024-04-17","objectID":"/posts/build-blog/:5:2","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"Video ","date":"2024-04-17","objectID":"/posts/build-blog/:5:3","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"VI. Problem And Solution ","date":"2024-04-17","objectID":"/posts/build-blog/:6:0","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"添加图片不显示 Hugo 的配置文件和文章中的引用图片都是以 static 作为根目录，因此图片无法显示的解决方案如下： 将图片放入 static/img 目录下 在文章中的图片引用方式为：/img/xxx.png 无法采用 Typora 等软件进行预览，需要在网页中进行预览: http://localhost:1313/ ","date":"2024-04-17","objectID":"/posts/build-blog/:6:1","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"文章缩略 如果想要文章在某个地方缩略，只需要在该位置加入 \u003c!--more--\u003e 即可。 ","date":"2024-04-17","objectID":"/posts/build-blog/:6:2","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"},{"categories":["Github Pages","Hugo","博客","Linux"],"content":"VII. References Abot Github Pages Hugo Gitalk 评论系统安装 参考文章 ","date":"2024-04-17","objectID":"/posts/build-blog/:7:0","tags":["Github Pages","Hugo","博客","Linux"],"title":"建站指南(GitHub Pages + Hugo)","uri":"/posts/build-blog/"}]